<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  



  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar/portrait.png?v=5.1.4">


  <link rel="mask-icon" href="/images/avatar/portrait.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Ennis Wu" type="application/atom+xml" />






<meta name="description" content="We could, we could belong togeter, ARTPOP.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ennis Wu">
<meta property="og:url" content="http://blog.ennis.info/index.html">
<meta property="og:site_name" content="Ennis Wu">
<meta property="og:description" content="We could, we could belong togeter, ARTPOP.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ennis Wu">
<meta name="twitter:description" content="We could, we could belong togeter, ARTPOP.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.ennis.info/"/>





  <title>Ennis Wu</title>
  








  <script src="/lib/photo/photoswipe.min.js"></script>
  <script src="/lib/photo/photoswipe-ui-default.min.js"></script>
  <script src="/lib/public/jquery-3.3.1.min.js"></script>
  <link href="/lib/moment/jquery.fancybox.min.css" rel="stylesheet">
  <script src="/lib/moment/jquery.fancybox.min.js"></script>
  <script src="/lib/moment/moment.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ennis Wu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ARTPOP = artistic revolution through the potential of pop.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-瞬间">
          <a href="/moments/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bolt"></i> <br />
            
            瞬间
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-image"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-足迹">
          <a href="/footprints/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-map-marker"></i> <br />
            
            足迹
          </a>
        </li>
      
        
        <li class="menu-item menu-item-影视">
          <a href="/movies/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-film"></i> <br />
            
            影视
          </a>
        </li>
      
        
        <li class="menu-item menu-item-留言">
          <a href="/comments/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-comments"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>
    <script>
      let images = [
         'header0.jpg',
         'header1.jpg',
         'header2.png'
      ];
      let image = images[Math.floor(Math.random() * images.length)];
      window.document.getElementById('header').style.cssText 
      = 'background: url(/images/avatar/' 
      + image
      + '); no-repeat; background-size: auto 100%;';
    </script>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/05/24/算法模板/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/24/算法模板/" itemprop="url">「算法面试通关 40 讲」算法模板</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-24T17:21:12+08:00">
                2020-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《算法面试通关-40-讲》/" itemprop="url" rel="index">
                    <span itemprop="name">《算法面试通关 40 讲》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://time.geekbang.org/course/detail/100019701-73421" target="_blank" rel="noopener">58 | 课程重点回顾</a></p>
<h1 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(level, param1, param2, ...)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; MAX_LEVEL</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># process logic in current level</span></span><br><span class="line">    process_data(level, data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># drill down</span></span><br><span class="line">    self.recursion(level + <span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse the current level status if needed</span></span><br><span class="line">    reverse_state(level)</span><br></pre></td></tr></table></figure>
<h1 id="深度优先搜索模板"><a href="#深度优先搜索模板" class="headerlink" title="深度优先搜索模板"></a>深度优先搜索模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">visited = set()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, visited)</span>:</span></span><br><span class="line">    visited.add(node)</span><br><span class="line">    <span class="comment"># process current node here.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">            dif(next_node, visited)</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索模板"><a href="#广度优先搜索模板" class="headerlink" title="广度优先搜索模板"></a>广度优先搜索模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line"></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line"></span><br><span class="line">        process(node)</span><br><span class="line">        nodes = generate_related_nodes(node)</span><br><span class="line">        queue.push(nodes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># other processing work</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h1 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, len(array) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    <span class="comment"># (left + right) / 2 可能越界</span></span><br><span class="line">    mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target!!</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="动态规划模板"><a href="#动态规划模板" class="headerlink" title="动态规划模板"></a>动态规划模板</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态定义</span></span><br><span class="line">dp = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = x;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = y;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP状态的推导</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= n; ++i &#123;</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span>; j &lt;= m; ++j &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        d[i][j] = min &#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], etc.&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n]; 最优解</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/05/24/常用的位运算/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/24/常用的位运算/" itemprop="url">「算法面试通关 40 讲」常用的位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-24T17:10:26+08:00">
                2020-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《算法面试通关-40-讲》/" itemprop="url" rel="index">
                    <span itemprop="name">《算法面试通关 40 讲》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://time.geekbang.org/course/detail/100019701-67645" target="_blank" rel="noopener">39 | 理论讲解：位运算</a></p>
<h1 id="常用的位运算"><a href="#常用的位运算" class="headerlink" title="常用的位运算"></a>常用的位运算</h1><ul>
<li><p>判断奇数</p>
<p>  <code>x &amp; 1 == 1</code></p>
</li>
<li><p>清零最低位的 <code>1</code></p>
<p>  <code>X = X &amp; (X - 1)</code></p>
</li>
<li><p>得到最低位的 <code>1</code></p>
<p>  <code>X &amp; -X</code></p>
</li>
</ul>
<h1 id="更为复杂的位运算操作"><a href="#更为复杂的位运算操作" class="headerlink" title="更为复杂的位运算操作"></a>更为复杂的位运算操作</h1><ol>
<li><p>将 <code>x</code> 最右边的 <code>n</code> 位清零</p>
<p> <code>x &amp; (~0 &lt;&lt; n)</code></p>
</li>
<li><p>获取 <code>x</code> 的第 <code>n</code> 位值</p>
<p> <code>(x &gt;&gt; n) &amp; 1</code></p>
</li>
<li><p>获取 <code>x</code> 的第 <code>n</code> 位的幂值</p>
<p> <code>x &amp; (1 &lt;&lt; (n - 1))</code></p>
</li>
<li><p>仅将第 <code>n</code> 位置为 <code>1</code></p>
<p> <code>x | (1 &lt;&lt; n)</code></p>
</li>
<li><p>仅将第 <code>n</code> 为置为 <code>0</code></p>
<p> <code>x &amp; (~(1 &lt;&lt; n))</code></p>
</li>
<li><p>将 <code>x</code> 为高位至第 <code>n</code> 位（含）清零</p>
<p> <code>x &amp; ((1 &lt;&lt; n) - 1)</code></p>
</li>
<li><p>将第 <code>n</code> 位至第 <code>0</code> 位（含）清零</p>
<p> <code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/05/16/HTTP中GET与POST的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/16/HTTP中GET与POST的区别/" itemprop="url">「转载」HTTP 中 GET 与 POST 的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-16T15:39:44+08:00">
                2020-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="w3schools-答案"><a href="#w3schools-答案" class="headerlink" title="w3schools 答案"></a>w3schools 答案</h1><ol>
<li><p>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</p>
</li>
<li><p>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</p>
</li>
<li><p>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</p>
</li>
<li><p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</p>
</li>
<li><p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</p>
</li>
<li><p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</p>
</li>
<li><p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</p>
</li>
<li><p>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</p>
</li>
<li><p>GET 参数通过 URL 传递，POST 放在 Request body 中。</p>
</li>
</ol>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li><p>GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。</p>
<ul>
<li><p>对于 GET 方式的请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200（返回数据）。</p>
</li>
<li><p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p>
</li>
<li><p>只有部分浏览器会发两个数据包，且 header 要加相应参数，且服务端要支持。</p>
</li>
</ul>
</li>
<li><p>增删查改中，GET 语义对应查，POST 语义对应增。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/26/JVM内存区域与垃圾回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/26/JVM内存区域与垃圾回收/" itemprop="url">「笔记」JVM 内存区域与垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-26T14:56:32+08:00">
                2020-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul>
<li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener">JVM垃圾回收</a></p>
</li>
<li><p><a href="https://juejin.im/post/5df2ec71f265da33d7442433" target="_blank" rel="noopener">聊聊Java的GC机制</a></p>
</li>
<li><p><a href="https://juejin.im/post/5ccfa05af265da039f0f243b" target="_blank" rel="noopener">深入Java虚拟机之 – 总结面试篇</a></p>
</li>
</ul>
<h1 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h1><p><img src="/images/posts/JVM/jvm_memory.jpg" alt=""></p>
<ul>
<li><p>方法区</p>
<ul>
<li>存储已被虚拟机加载的类信息、常量、静态变量等</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li><p>JVM 管理的内存中最大的一块</p>
</li>
<li><p>存放对象实例</p>
</li>
<li><p>GC 主要作用的区域</p>
</li>
</ul>
</li>
<li><p>虚拟机栈：</p>
<ul>
<li><p>局部变量表、操作数栈</p>
</li>
<li><p>描述 Java 方法执行的内存模型</p>
</li>
</ul>
</li>
<li><p>本地方法栈</p>
<ul>
<li>与虚拟机栈类似，为 native 方法提供服务</li>
</ul>
</li>
<li><p>程序计数器</p>
<ul>
<li><p>记录当前线程执行的方法执行到了第几行</p>
</li>
<li><p>线程正在执行的是 Java 方法，计数器记录正在执行的虚拟机字节码指令的地址</p>
</li>
<li><p>线程正在执行的是 native 方法，这个计数器值则为空（Undefined）</p>
</li>
</ul>
</li>
<li><p>JDK 1.7 之前常量池在方法区，JDK 1.7 之后常量池在堆</p>
</li>
</ul>
<h2 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h2><p><img src="/images/posts/JVM/jvm_memory_heap.png" alt=""></p>
<ul>
<li>JDK 1.8 之前</li>
</ul>
<p>堆 = 新生代 + 老年代 + 永久代</p>
<p>新生代 = Eden 区 + Survivor from 区 + Survivor to 区</p>
<ul>
<li>JDK 1.8 之后</li>
</ul>
<p>堆 = 新生代 + 老年代 + 元空间（使用物理内存）</p>
<h1 id="GC-的分类"><a href="#GC-的分类" class="headerlink" title="GC 的分类"></a>GC 的分类</h1><ul>
<li><p>新生代 GC（Minor GC）</p>
<ul>
<li><p>发生新生代的的 GC</p>
</li>
<li><p>Minor GC 非常频繁</p>
</li>
<li><p>回收速度一般比较快</p>
</li>
</ul>
</li>
<li><p>老年代 GC（Major GC/Full GC）</p>
<ul>
<li><p>发生在老年代的 GC</p>
</li>
<li><p>出现 Major GC 通常会伴随至少一次的 Minor G</p>
</li>
<li><p>Major GC 速度一般比 Minor GC 慢 10 倍以上</p>
</li>
</ul>
</li>
</ul>
<h1 id="内存分配规则"><a href="#内存分配规则" class="headerlink" title="内存分配规则"></a>内存分配规则</h1><ul>
<li><p>对象优先在 Eden 区分配</p>
</li>
<li><p>Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
</ul>
<p>大对象指需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<ul>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
</li>
</ul>
<p>如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h1 id="GC-Roots-是什么"><a href="#GC-Roots-是什么" class="headerlink" title="GC Roots 是什么"></a>GC Roots 是什么</h1><blockquote>
<p><a href="https://help.eclipse.org/2019-09/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;resultof=%22%67%61%72%62%61%67%65%22%20%22%67%61%72%62%61%67%22%20" target="_blank" rel="noopener">Garbage Collection Roots</a><br>A garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:<br><strong>System Class</strong><br>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .<br><strong>JNI Local</strong><br>Local variable in native code, such as user defined JNI code or JVM internal code.<br><strong>JNI Global</strong><br>Global variable in native code, such as user defined JNI code or JVM internal code.<br><strong>Thread Block</strong><br>Object referred to from a currently active thread block.<br><strong>Thread</strong><br>A started, but not stopped, thread.<br><strong>Busy Monitor</strong><br>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.<br><strong>Java Local</strong><br>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.<br><strong>Native Stack</strong><br>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.<br><strong>Finalizable</strong><br>An object which is in a queue awaiting its finalizer to be run.<br><strong>Unfinalized</strong><br>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.<br><strong>Unreachable</strong><br>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.<br><strong>Java Stack Frame</strong><br>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.<br><strong>Unknown</strong><br>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</p>
</blockquote>
<ul>
<li><p>由系统类加载器（system class loader）加载的对象</p>
</li>
<li><p>活着的线程，包含处于等待或阻塞的线程</p>
</li>
<li><p>当前被调用的方法（Java 方法，native 方法）的一些参数和局部变量</p>
</li>
<li><p>方法区中静态变量，常量引用的对象</p>
</li>
<li><p>Held by JVM</p>
</li>
</ul>
<p>JVM 由于特殊目的为 GC 保留的对象，实际与 JVM 的实现有关。</p>
<p>可能已知的一些类型是：系统类加载器、一些 JVM 知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。</p>
<h1 id="常量池的-gc"><a href="#常量池的-gc" class="headerlink" title="常量池的 gc"></a>常量池的 gc</h1><ul>
<li>该常量没有任何引用</li>
</ul>
<h1 id="方法区的-gc"><a href="#方法区的-gc" class="headerlink" title="方法区的 gc"></a>方法区的 gc</h1><ul>
<li><p>该类不存在任何对象</p>
</li>
<li><p>该类 <code>GlassLoader</code> 已被回收</p>
</li>
<li><p><code>java.lang.Class</code> 对象不存在任何引用，任何地方无反射该类</p>
</li>
</ul>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><ul>
<li><p>Mark-Sweep（标记-清除）算法</p>
</li>
<li><p>Copying（复制）算法</p>
<ul>
<li><p>1:1 复制</p>
</li>
<li><p>8:1 复制</p>
</li>
</ul>
</li>
<li><p>Mark-Compact（标记-整理）算法</p>
</li>
<li><p>Generational Collection（分代收集）算法</p>
</li>
</ul>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><img src="/images/posts/JVM/gc_mark_sweep.jpg" alt=""></p>
<ol>
<li><p>标记所有需要回收的对象</p>
</li>
<li><p>统一回收所有被标记的对象</p>
</li>
</ol>
<ul>
<li>会产生大量不连续的碎片</li>
</ul>
<h2 id="复制算法（1-1）"><a href="#复制算法（1-1）" class="headerlink" title="复制算法（1:1）"></a>复制算法（1:1）</h2><p><img src="/images/posts/JVM/gc_copying.jpg" alt=""></p>
<ol>
<li><p>将内存分为两块</p>
</li>
<li><p>一块使用完后存活的对象复制到另一块</p>
</li>
<li><p>把已使用的空间清空</p>
</li>
</ol>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="/images/posts/JVM/gc_mark_compact.jpg" alt=""></p>
<ul>
<li>针对老年代</li>
</ul>
<ol>
<li><p>标记所有需要回收的对象</p>
</li>
<li><p>将存活的对象移到一端</p>
</li>
<li><p>清理端边界以外的内存</p>
</li>
</ol>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul>
<li><p>新生代使用复制算法</p>
</li>
<li><p>老年代使用标记-清除算法或标记-整理算法</p>
</li>
</ul>
<h3 id="复制算法（8-1）"><a href="#复制算法（8-1）" class="headerlink" title="复制算法（8:1）"></a>复制算法（8:1）</h3><ul>
<li>新生代内存分配比例： Eden 区 : Survivor from 区 : Survivor to 区 = 8 : 1 : 1</li>
</ul>
<ol>
<li><p>先使用 Eden 区和 from 区</p>
</li>
<li><p>GC 时将存活的对象复制到 to 区</p>
</li>
<li><p>清理 Eden 区和 to 区</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/17/转-Activity相关问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/17/转-Activity相关问题/" itemprop="url">「转载」Activity 的相关问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-17T12:35:27+08:00">
                2020-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自：<a href="https://www.jianshu.com/p/86c0a4afd28e" target="_blank" rel="noopener">Activity 的 36 大难点，你会几个？「建议收藏」</a></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="Dialog-弹出"><a href="#Dialog-弹出" class="headerlink" title="Dialog 弹出"></a>Dialog 弹出</h2><ul>
<li>如果是单纯是创建的 Dialog，Activity 并不会执行生命周期的方法</li>
</ul>
<h2 id="什么是-onNewIntent"><a href="#什么是-onNewIntent" class="headerlink" title="什么是 onNewIntent"></a>什么是 onNewIntent</h2><ul>
<li><p>如果 IntentActivity 处于任务栈的顶端，也就是说之前打开过的 Activity，现在处于 onPause、onStop 状态的话，其他应用再发送 Intent 的话</p>
</li>
<li><p>执行顺序为：onNewIntent，onRestart，onStart，onResume</p>
</li>
</ul>
<h1 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h1><p>Activity 一共有四种 launchMode：Standard、SingleTop、SingleTask、SingleInstance。</p>
<h2 id="Standard-模式（默认模式）"><a href="#Standard-模式（默认模式）" class="headerlink" title="Standard 模式（默认模式）"></a>Standard 模式（默认模式）</h2><ol>
<li><p>说明：每次启动一个 Activity 都会又一次创建一个新的实例入栈，无论这个实例是否存在。</p>
</li>
<li><p>生命周期：每次被创建的实例 Activity 的生命周期符合典型情况，它的 onCreate、onStart、onResume 都会被调用。</p>
</li>
<li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 Standard 模式。若在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是还有一个 C Activity 进入栈中，成为栈顶。</p>
</li>
</ol>
<h2 id="SingleTop-模式（栈顶复用模式）"><a href="#SingleTop-模式（栈顶复用模式）" class="headerlink" title="SingleTop 模式（栈顶复用模式）"></a>SingleTop 模式（栈顶复用模式）</h2><ol>
<li><p>说明：分两种处理情况：须要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity。不会再创建新的 Activity；若须要创建的 Activity 不处于栈顶，此时会又一次创建一个新的 Activity 入栈，同 Standard 模式一样。</p>
</li>
<li><p>生命周期：若情况一中栈顶的 Activity 被直接复用时，它的 onCreate、onStart 不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent 会被回调（Activity 被正常创建时不会回调此方法）。</p>
</li>
<li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 SingleTop 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity。结果是直接复用栈顶的 C Activity。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity。结果是创建一个新的 Activity 入栈。成为栈顶。</p>
</li>
</ol>
<h2 id="SingleTask-模式（栈内复用模式）"><a href="#SingleTask-模式（栈内复用模式）" class="headerlink" title="SingleTask 模式（栈内复用模式）"></a>SingleTask 模式（栈内复用模式）</h2><ol>
<li><p>说明：若须要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶。</p>
</li>
<li><p>如果是在别的应用程序中启动它，则会新建一个 task ，并在该 task 中启动这个 Activity ，SingleTask 允许别的 Activity 与其在一个 task 中共存，也就是说，如果我在这个 SingleTask 的实例中再打开新的 Activity ，这个新的 Activity 还是会在 SingleTask 的实例的 task 中。</p>
</li>
<li><p>生命周期：同 SingleTop 模式中的情况一同样。仅仅会又一次回调 Activity 中的 onNewIntent 方法</p>
</li>
<li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity 。此时 C 处于栈顶，启动模式为 SingleTask 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是直接用栈顶的 C Activity 。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity 。结果是将 A Activity 上面的 B、C 所有销毁，使 A Activity 成为栈顶。</p>
</li>
</ol>
<h2 id="SingleInstance-模式（单实例模式）"><a href="#SingleInstance-模式（单实例模式）" class="headerlink" title="SingleInstance 模式（单实例模式）"></a>SingleInstance 模式（单实例模式）</h2><ol>
<li><p>说明：SingleInstance 比较特殊，是全局单例模式，是一种加强的 SingleTask 模式。它除了具有它所有特性外，还加强了一点：只有一个实例，并且这个实例独立运行在一个 task 中，这个 task 只有这个实例，不允许有别的 Activity 存在。</p>
</li>
<li><p>这个经常使用于系统中的应用，比如 Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。</p>
</li>
<li><p>举例：比方 A Activity 是该模式，启动 A 后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的 Activity ，除非这个独特的任务栈被系统销毁。</p>
</li>
</ol>
<h2 id="SingleTask-模式的运用场景"><a href="#SingleTask-模式的运用场景" class="headerlink" title="SingleTask 模式的运用场景"></a>SingleTask 模式的运用场景</h2><ol>
<li><p>最常见的应用场景就是保持我们应用开启后仅仅有一个 Activity 的实例。</p>
</li>
<li><p>最典型的样例就是应用中展示的主页（Home 页）。</p>
</li>
<li><p>假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用 SingleTask 模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。</p>
</li>
</ol>
<h2 id="SingleTop-模式的运用场景"><a href="#SingleTop-模式的运用场景" class="headerlink" title="SingleTop 模式的运用场景"></a>SingleTop 模式的运用场景</h2><ol>
<li><p>假设你在当前的 Activity 中又要启动同类型的 Activity</p>
</li>
<li><p>此时建议将此类型 Activity 的启动模式指定为 SingleTop ，能够降低Activity的创建，节省内存！</p>
</li>
</ol>
<h2 id="注意：复用-Activity-时的生命周期回调"><a href="#注意：复用-Activity-时的生命周期回调" class="headerlink" title="注意：复用 Activity 时的生命周期回调"></a>注意：复用 Activity 时的生命周期回调</h2><ol>
<li><p>这里还须要考虑一个 Activity 跳转时携带页面參数的问题。</p>
</li>
<li><p>由于当一个 Activity 设置了 SingleTop 或者 SingleTask 模式后，跳转此 Activity 出现复用原有 Activity 的情况时，此 Activity 的 onCreate 方法将不会再次运行。onCreate 方法仅仅会在第一次创建 Activity 时被运行。</p>
</li>
<li><p>而一般 onCreate 方法中会进行该页面的数据初始化、UI 初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题</p>
</li>
<li><p>若页面展示的数据就是通过 getIntent() 方法来获取，那么问题就会出现：getIntent() 获取的一直都是老数据，根本无法接收跳转时传送的新数据！</p>
</li>
<li><p>这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的 intent ，这样我们就能够解决上述问题。这里建议的方法是又一次去 setIntent。然后又一次去初始化数据和 UI。</p>
</li>
</ol>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="Activity-间通过-Intent-传递数据大小限制"><a href="#Activity-间通过-Intent-传递数据大小限制" class="headerlink" title="Activity 间通过 Intent 传递数据大小限制"></a>Activity 间通过 Intent 传递数据大小限制</h2><ul>
<li><p>Intent 在传递数据时是有大小限制的，这里官方并未详细说明，不过通过实验的方法可以测出数据应该被限制在 1MB 之内（1024KB）</p>
</li>
<li><p>我们采用传递 Bitmap 的方法，发现当图片大小超过 1024（准确地说是 1020 左右）的时候，程序就会出现闪退、停止运行等异常(不同的手机反应不同)</p>
</li>
<li><p>因此可以判断 Intent 的传输容量在 1MB 之内。</p>
</li>
</ul>
<h2 id="内存不足时系统会杀掉后台的-Activity，若需要进行一些临时状态的保存，在哪个方法进行"><a href="#内存不足时系统会杀掉后台的-Activity，若需要进行一些临时状态的保存，在哪个方法进行" class="headerlink" title="内存不足时系统会杀掉后台的 Activity，若需要进行一些临时状态的保存，在哪个方法进行"></a>内存不足时系统会杀掉后台的 Activity，若需要进行一些临时状态的保存，在哪个方法进行</h2><ul>
<li><p>Activity 的 onSaveInstanceState() 和 onRestoreInstanceState() 并不是生命周期方法，它们不同于 onCreate()、onPause() 等生命周期方法，它们并不一定会被触发。</p>
</li>
<li><p>onSaveInstanceState() 方法，当应用遇到意外情况（如：内存不足、用户直接按 Home 键）由系统销毁一个 Activity， onSaveInstanceState() 会被调用。</p>
</li>
<li><p>但是当用户主动去销毁一个 Activity 时，例如在应用中按返回键，onSaveInstanceState() 就不会被调用。</p>
</li>
<li><p>除非该 Activity 不是被用户主动销毁的，通常 onSaveInstanceState() 只适合用于保存一些临时性的状态，而 onPause() 适合用于数据的持久化保存。</p>
</li>
</ul>
<h2 id="onSaveInstanceState-被执行的场景"><a href="#onSaveInstanceState-被执行的场景" class="headerlink" title="onSaveInstanceState() 被执行的场景"></a>onSaveInstanceState() 被执行的场景</h2><p>系统不知道你按下 HOME 后要运行多少其他的程序，自然也不知道 Activity A 是否会被销毁</p>
<p>因此系统都会调用 onSaveInstanceState() ，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则：</p>
<ol>
<li><p>当用户按下 HOME 键时</p>
</li>
<li><p>长按 HOME 键，选择运行其他的程序时</p>
</li>
<li><p>锁屏时</p>
</li>
<li><p>从 Activity A 中启动一个新的 Activity 时</p>
</li>
<li><p>屏幕方向切换时</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/17/HashMap之扰动函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/17/HashMap之扰动函数/" itemprop="url">「笔记」HashMap 之扰动函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-17T11:48:58+08:00">
                2020-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下源码基于 JDK11</p>
<p><code>HashMap</code> 添加数据时 <code>Key</code> 的 <code>hashCode</code> 值通过扰动函数重新计算 <code>hash</code> 值，<strong>新 <code>hash</code> 值与数组的长度取模得到数组目标下标</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长度等于 2 的 n 次幂时，这两种写法效果相同</span></span><br><span class="line"><span class="comment">//i = hash % (tab.length - 1)</span></span><br><span class="line">i = (tab.length - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p><strong>这也是为什么数组的长度始终保持 2 的 n 次幂大小的原因。</strong> 详细推理可以看<a href="https://www.cnblogs.com/ysocean/p/9054804.html" target="_blank" rel="noopener">由HashMap哈希算法引出的求余%和与运算&amp;转换问题</a></p>
<p>当哈希函数映射得比较松散时，碰撞就很难发生，<strong>但是 <code>HashMap</code> 的数组长度是有限的，要进行取模操作</strong>。这时就算散列值分布松散，<strong>只取最后几位碰撞也很严重</strong>。</p>
<p>JDK8 之后的扰动函数是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 <code>hashCode</code> 值无符号右移 16 位再与自身异或</strong>，这样混合了 <code>hashCode</code> 的高位和低位，增加低位的随机性，混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留。</p>
<p><img src="/images/posts/Java/Collection/perturbation_function.png" alt="" title="扰动函数"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/13/转-Glide面试问答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/转-Glide面试问答/" itemprop="url">「转载」Glide 面试问答</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T21:38:20+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自：<a href="https://juejin.im/post/5dd766e1e51d45233c7e857f" target="_blank" rel="noopener">聊一聊关于Glide在面试中的那些事</a></p>
<h1 id="来简单介绍下-Glide-的缓存"><a href="#来简单介绍下-Glide-的缓存" class="headerlink" title="来简单介绍下 Glide 的缓存"></a>来简单介绍下 Glide 的缓存</h1><p><strong>分析</strong></p>
<p>（这货滔滔不绝的说了一大通，从 LruCache 说到了 LinkedHashMap，巴拉巴拉。。。个人建议这块一定要简述，面试时原理说的太多，第一很多细节会被打断问到，第二点，说这么多，给人的感觉就是在背诵东西，原理概括能力很弱或者感觉根本就没有自己的体会。）</p>
<p><strong>答案</strong></p>
<p>Glide 的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。正式因为有着这两种缓存的结合，才构成了 Glide 极佳的缓存效果。</p>
<p>（先告诉人家有哪几种缓存，主要是为了什么目的才用的缓存，然后可以看着面试官，要么等着他继续问，如果他不问，等着你，这个时候你就可以继续的往细节处介绍）</p>
<h1 id="嗯，具体说一说-Glide-的三级缓存原理"><a href="#嗯，具体说一说-Glide-的三级缓存原理" class="headerlink" title="嗯，具体说一说 Glide 的三级缓存原理"></a>嗯，具体说一说 Glide 的三级缓存原理</h1><p><strong>分析</strong></p>
<p>（记得，如果需要具体谈原理时，要先宏观，后细节）</p>
<p><strong>答案</strong></p>
<p>读取一张图片的时候，获取顺序：Lru 算法缓存-》弱引用缓存-》磁盘缓存（如果设置了的话）。</p>
<p>当我们的 APP 中想要加载某张图片时，先去 LruCache 中寻找图片，如果 LruCache 中有，则直接取出来使用，并将该图片放入 WeakReference 中，如果 LruCache 中没有，则去 WeakReference 中寻找，如果 WeakReference 中有，则从 WeakReference 中取出图片使用，如果 WeakReference 中也没有图片，则从磁盘缓存/网络中加载图片。 </p>
<p>注：图片正在使用时存在于 activeResources 弱引用 map 中。流程如下图：</p>
<p><img src="/images/posts/android/glide/glide_cache.jpg" alt=""></p>
<p>将图片缓存的时候，写入顺序：弱引用缓存-》Lru算法缓存-》磁盘缓存中。</p>
<p>当图片不存在的时候，先从网络下载图片，然后将图片存入弱引用中，glide 会采用一个 acquired（int）变量用来记录图片被引用的次数， 当 acquired 变量大于 0 的时候，说明图片正在使用中，也就是将图片放到弱引用缓存当中；如果 acquired 变量等于 0 了，说明图片已经不再被使用了，那么此时会调用方法来释放资源，首先会将缓存图片从弱引用中移除，然后再将它 put 到 LruResourceCache 当中。这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。</p>
<h2 id="引深"><a href="#引深" class="headerlink" title="引深"></a>引深</h2><h3 id="关于-LruCache"><a href="#关于-LruCache" class="headerlink" title="关于 LruCache"></a>关于 LruCache</h3><p>最近最少使用算法，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致 OOM。LruCache 内部用 LinkHashMap 存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面 put 数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。</p>
<h3 id="关于-LinkedHashMap"><a href="#关于-LinkedHashMap" class="headerlink" title="关于 LinkedHashMap"></a>关于 LinkedHashMap</h3><p>LinkHashMap 继承 HashMap，在 HashMap 的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头 header 之前，这样就保证了链表头 header 节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在 map 中的位置是不变的）。</p>
<h1 id="Glide加载一个一兆的图片（100-x-100），是否会压缩后再加载，放到一个-300-x-300-的-View-上会怎样，800-x-800-呢，图片会很模糊，怎么处理？"><a href="#Glide加载一个一兆的图片（100-x-100），是否会压缩后再加载，放到一个-300-x-300-的-View-上会怎样，800-x-800-呢，图片会很模糊，怎么处理？" class="headerlink" title="Glide加载一个一兆的图片（100 x 100），是否会压缩后再加载，放到一个 300 x 300 的 View 上会怎样，800 x 800 呢，图片会很模糊，怎么处理？"></a>Glide加载一个一兆的图片（100 x 100），是否会压缩后再加载，放到一个 300 x 300 的 View 上会怎样，800 x 800 呢，图片会很模糊，怎么处理？</h1><p><strong>分析</strong></p>
<p>（因为你缓存机制无论是看博客还是看一些面试宝典，如果只是考原理或者定义，光把上面的文字背诵下来就可以了，但是背诵和真正的理解是两回事，自己没有形成感悟，不理解这个框架，只是一味的迎合面试，这个问题就可以卡住你，另外千万别和面试官嘚瑟，果然，这个面试的哥们，这块就卡住了，支支吾吾的半天没答上来，果然是只看了博客，没真正的阅读过源码）</p>
<p><strong>答案</strong></p>
<p>当我们调整 ImageView 的大小时，Picasso 会不管 ImageView 大小是什么，总是直接缓存整张图片，而 Glide 就不一样了，它会为每个不同尺寸的 ImageView 缓存一张图片，也就是说不管你的这张图片有没有加载过，只要 ImageView 的尺寸不一样，那么 Glide 就会重新加载一次，这时候，它会在加载的 ImageView 之前从网络上重新下载，然后再缓存。</p>
<p>举个例子，如果一个页面的 ImageView 是 300 x 300 像素，而另一个页面中的 ImageView 是 100 x 100 像素，这时候想要让两个 ImageView 像是同一张图片，那么 Glide 需要下载两次图片，并且缓存两张图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求参数得到缓存的键</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，缓存 Key 的生成条件之一就是控件的长宽。</p>
<h1 id="简单说一下内存泄漏的场景，如果在一个页面中使用-Glide-加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"><a href="#简单说一下内存泄漏的场景，如果在一个页面中使用-Glide-加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？" class="headerlink" title="简单说一下内存泄漏的场景，如果在一个页面中使用 Glide 加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"></a>简单说一下内存泄漏的场景，如果在一个页面中使用 Glide 加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？</h1><p><strong>分析</strong></p>
<p>（注意一定要审题，因为之前问了这个小伙，内存泄漏的原因，无非是长生命周期引用了短生命周期的对象等等，然后突然画风一变，直接问了 Glide 加载图片会不会引起图片泄漏，这个小伙想也没想，直接回答道会引起内存泄漏，可以用 LeakCanary 检测，巴拉巴拉。。。）</p>
<p><strong>答案</strong></p>
<p>因为 Glide 在加载资源的时候，如果是在 Activity、Fragment 这一类有生命周期的组件上进行的话，会创建一个透明的 RequestManagerFragment 加入到FragmentManager 之中，感知生命周期，当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源。但是如果，是在非生命周期的组件上进行时，会采用 Application 的生命周期贯穿整个应用，所以 ApplicationManager 只有在应用程序关闭的时候终止加载。</p>
<h1 id="如何设计一个大图加载框架"><a href="#如何设计一个大图加载框架" class="headerlink" title="如何设计一个大图加载框架"></a>如何设计一个大图加载框架</h1><p><strong>分析</strong></p>
<p>(这个孩子，总算是羞愧的低下了头，一脸懵逼的和我说，这个我忘记了) </p>
<p><strong>答案</strong></p>
<p>概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作。</p>
<p><img src="/images/posts/android/glide/picture_framwork.png" alt=""></p>
<ol>
<li><p>封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程；</p>
</li>
<li><p>解析路径：图片的来源有多种，格式也不尽相同，需要规范化；</p>
</li>
<li><p>读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（Bitmap）即可；</p>
</li>
<li><p>查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载；</p>
</li>
<li><p>解码：这一步是整个过程中最复杂的步骤之一，有不少细节，下个博客会说；</p>
</li>
<li><p>变换：解码出 Bitmap 之后，可能还需要做一些变换处理（圆角，滤镜等）；</p>
</li>
<li><p>缓存：得到最终 bitmap 之后，可以缓存起来，以便下次请求时直接取结果；</p>
</li>
<li><p>显示：显示结果，可能需要做些动画（淡入动画，CrossFade 等）。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/13/为什么View-post-能获取到View的宽高/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/为什么View-post-能获取到View的宽高/" itemprop="url">「笔记」为什么 View.post() 能获取到 View 的宽高</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T19:29:30+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么在-onCreate-和第一次-onResume-中无法获取到宽高"><a href="#为什么在-onCreate-和第一次-onResume-中无法获取到宽高" class="headerlink" title="为什么在 onCreate() 和第一次 onResume() 中无法获取到宽高"></a>为什么在 onCreate() 和第一次 onResume() 中无法获取到宽高</h1><p>我们知道 <code>View</code> 的绘制是从 <code>ViewRootImpl.performTraversals()</code> 方法开始的，而 <code>performTraversals()</code> 是在 <code>onResume()</code> 之后才被调用，所以在 <code>onCreate()</code> 和第一次 <code>onResume()</code> 中无法获取到 <code>View</code> 的宽高。</p>
<h1 id="为什么-View-post-能获取到宽高"><a href="#为什么-View-post-能获取到宽高" class="headerlink" title="为什么 View.post() 能获取到宽高"></a>为什么 View.post() 能获取到宽高</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class View</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>attachInfo</code> 不为空时直接发送事件</p>
</li>
<li><p><code>attachInfo</code> 为空时会暂时缓存任务</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class HandlerActionQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    postDelayed(action, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction(action, delayMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActions = <span class="keyword">new</span> HandlerAction[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存的任务何时发送"><a href="#缓存的任务何时发送" class="headerlink" title="缓存的任务何时发送"></a>缓存的任务何时发送</h2><p>在 <code>View.dispatchAttachedToWindow()</code> 方法中发送事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class View</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue.executeActions(info.mHandler);</span><br><span class="line">        mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class HandlerActionQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> HandlerAction[] actions = mActions;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> HandlerAction handlerAction = actions[i];</span><br><span class="line">            handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mActions = <span class="keyword">null</span>;</span><br><span class="line">        mCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dispatchAttachedToWindow-何时被调用"><a href="#dispatchAttachedToWindow-何时被调用" class="headerlink" title="dispatchAttachedToWindow() 何时被调用"></a>dispatchAttachedToWindow() 何时被调用</h2><p>在 <code>ViewRootImpl.performTraversals()</code> 方法中会调用 <code>dispatchAttachedToWindow()</code> 方法，该方法在 <code>View</code> 的测量、布局、绘制之前被调用。</p>
<p><code>dispatchAttachedToWindow()</code> 方法和测量、布局、绘制一样会递归调用子 <code>View</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ...</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mFirst || ...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (...) &#123;</span><br><span class="line">                ...</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为何-dispatchAttachedToWindow-先于测量调用却能获取到宽高"><a href="#为何-dispatchAttachedToWindow-先于测量调用却能获取到宽高" class="headerlink" title="为何 dispatchAttachedToWindow() 先于测量调用却能获取到宽高"></a>为何 dispatchAttachedToWindow() 先于测量调用却能获取到宽高</h2><p>实际上 <code>ViewRootImpl.performTraversals()</code> 也是在事件循环中被执行的，所以缓存的任务会在 <code>ViewRootImpl.performTraversals()</code> 之后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performTraversals();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>View.post()</code> 中的任务在 <code>ViewRootImpl.performTraversals()</code>，执行完之前会被缓存，待 <code>ViewRootImpl.performTraversals()</code> 执行完后执行，所以可以获取到宽高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/10/转-RenderObject和RenderBox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/10/转-RenderObject和RenderBox/" itemprop="url">「转载」RenderObject 和 RenderBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-10T19:28:51+08:00">
                2020-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自：<a href="https://book.flutterchina.club/chapter14/render_object.html" target="_blank" rel="noopener">14.3 RenderObject和RenderBox</a></p>
<p><code>RenderObject</code>就是渲染树中的一个对象，它拥有一个<code>parent</code>和一个<code>parentData</code> 插槽（slot），所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而<code>parentData</code>正是一个预留变量，它正是由<code>parent</code> 来赋值的，<code>parent</code>通常会通过子<code>RenderObject</code>的<code>parentData</code>存储一些和子元素相关的数据，如在Stack布局中，<code>RenderStack</code>就会将子元素的偏移数据存储在子元素的<code>parentData</code>中（具体可以查看<code>Positioned</code>实现）。</p>
<p><code>RenderObject</code>类本身实现了一套基础的layout和绘制协议，但是并没有定义子节点模型（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。 它也没有定义坐标系统（如子节点定位是在笛卡尔坐标中还是极坐标？）和具体的布局协议（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，Flutter提供了一个<code>RenderBox</code>类，它继承自<code>RenderObject</code>，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴，大多数情况下，我们直接使用<code>RenderBox</code>就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下<code>RenderBox</code>。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>在<code>RenderBox</code> 中，有个<code>size</code>属性用来保存控件的宽和高。<code>RenderBox</code>的layout是通过在组件树中从上往下传递<code>BoxConstraints</code>对象的实现的。<code>BoxConstraints</code>对象可以限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件。</p>
<p>在布局阶段，父节点会调用子节点的<code>layout()</code>方法，下面我们看看<code>RenderObject</code>中<code>layout()</code>方法的大致实现（删掉了一些无关代码和异常捕获）:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">   ...</span><br><span class="line">   RenderObject relayoutBoundary; </span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight </span><br><span class="line">        || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">      relayoutBoundary = parent._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">        performResize();</span><br><span class="line">    &#125;</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>layout</code>方法需要传入两个参数，第一个为<code>constraints</code>，即 父节点对子节点大小的限制，该值根据父节点的布局逻辑确定。另外一个参数是 <code>parentUsesSize</code>，该值用于确定 <code>relayoutBoundary</code>，该参数表示子节点布局变化是否影响父节点，如果为<code>true</code>，当子节点布局发生变化时父节点都会标记为需要重新布局，如果为<code>false</code>，则子节点布局发生变化后不会影响父节点。</p>
<h3 id="relayoutBoundary"><a href="#relayoutBoundary" class="headerlink" title="relayoutBoundary"></a>relayoutBoundary</h3><p>上面<code>layout()</code>源码中定义了一个<code>relayoutBoundary</code>变量，什么是 <code>relayoutBoundary</code>？在前面介绍<code>Element</code>时，我们讲过当一个<code>Element</code>标记为 dirty 时便会重新build，这时<code>RenderObject</code>便会重新布局，我们是通过调用 <code>markNeedsBuild()</code> 来标记<code>Element</code>为dirty的。在<code>RenderObject</code>中有一个类似的<code>markNeedsLayout()</code>方法，它会将<code>RenderObject</code>的布局状态标记为 dirty，这样在下一个frame中便会重新layout，我们看看<code>RenderObject</code>的<code>markNeedsLayout()</code>的部分源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">assert</span>(_relayoutBoundary != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码大致逻辑是先判断自身是不是<code>relayoutBoundary</code>，如果不是就继续向parent 查找，一直向上查找到是 <code>relayoutBoundary</code> 的 <code>RenderObject</code>为止，然后再将其标记为 dirty 的。这样来看它的作用就比较明显了，意思就是当一个控件的大小被改变时可能会影响到它的 parent，因此 parent 也需要被重新布局，那么到什么时候是个头呢？答案就是 <code>relayoutBoundary</code>，如果一个 <code>RenderObject</code> 是 <code>relayoutBoundary</code>，就表示它的大小变化不会再影响到 parent 的大小了，于是 parent 也就不用重新布局了。</p>
<h3 id="performResize-和-performLayout"><a href="#performResize-和-performLayout" class="headerlink" title="performResize 和 performLayout"></a>performResize 和 performLayout</h3><p><code>RenderBox</code>实际的测量和布局逻辑是在<code>performResize()</code> 和 <code>performLayout()</code>两个方法中，RenderBox子类需要实现这两个方法来定制自身的布局逻辑。根据<code>layout()</code> 源码可以看出只有 <code>sizedByParent</code> 为 <code>true</code> 时，<code>performResize()</code> 才会被调用，而 <code>performLayout()</code> 是每次布局都会被调用的。<code>sizedByParent</code> 意为该节点的大小是否仅通过 parent 传给它的 constraints 就可以确定了，即该节点的大小与它自身的属性和其子节点无关，比如如果一个控件永远充满 parent 的大小，那么 <code>sizedByParent</code>就应该返回<code>true</code>，此时其大小在 <code>performResize()</code> 中就确定了，在后面的 <code>performLayout()</code> 方法中将不会再被修改了，这种情况下 <code>performLayout()</code> 只负责布局子节点。</p>
<p>在 <code>performLayout()</code> 方法中除了完成自身布局，也必须完成子节点的布局，这是因为只有父子节点全部完成后布局流程才算真正完成。所以最终的调用栈将会变成：<em>layout() &gt; performResize()/performLayout() &gt; child.layout() &gt; …</em> ，如此递归完成整个UI的布局。</p>
<p><code>RenderBox</code>子类要定制布局算法不应该重写<code>layout()</code>方法，因为对于任何RenderBox的子类来说，它的layout流程基本是相同的，不同之处只在具体的布局算法，而具体的布局算法子类应该通过重写<code>performResize()</code> 和 <code>performLayout()</code>两个方法来实现，他们会在<code>layout()</code>中被调用。</p>
<h3 id="ParentData"><a href="#ParentData" class="headerlink" title="ParentData"></a>ParentData</h3><p>当layout结束后，每个节点的位置（相对于父节点的偏移）就已经确定了，<code>RenderObject</code>就可以根据位置信息来进行最终的绘制。但是在layout过程中，节点的位置信息怎么保存？对于大多数<code>RenderBox</code>子类来说如果子类只有一个子节点，那么子节点偏移一般都是<code>Offset.zero</code> ，如果有多个子节点，则每个子节点的偏移就可能不同。而子节点在父节点的偏移数据正是通过<code>RenderObject</code>的<code>parentData</code>属性来保存的。在<code>RenderBox</code>中，其<code>parentData</code>属性默认是一个<code>BoxParentData</code>对象，该属性只能通过父节点的<code>setupParentData()</code>方法来设置：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderBox</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setupParentData(covariant RenderObject child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.parentData <span class="keyword">is</span>! BoxParentData)</span><br><span class="line">      child.parentData = BoxParentData();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BoxParentData</code>定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parentdata 会被RenderBox和它的子类使用.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxParentData</span> <span class="keyword">extends</span> <span class="title">ParentData</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// offset表示在子节点在父节点坐标系中的绘制偏移  </span></span><br><span class="line">  Offset offset = Offset.zero;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">'offset=<span class="subst">$offset<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一定要注意，<code>RenderObject</code>的<code>parentData</code> 只能通过父元素设置.</p>
</blockquote>
<p>当然，<code>ParentData</code>并不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的<code>ParentData</code>中，如<code>ContainerBox</code>的<code>ParentData</code>就保存了指向兄弟节点的<code>previousSibling</code>和<code>nextSibling</code>，<code>Element.visitChildren()</code>方法也正是通过它们来实现对子节点的遍历。再比如<code>KeepAlive</code> 组件，它使用<code>KeepAliveParentDataMixin</code>（继承自<code>ParentData</code>） 来保存子节的<code>keepAlive</code>状态。</p>
<h1 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h1><p><code>RenderObject</code>可以通过<code>paint()</code>方法来完成具体绘制逻辑，流程和布局流程相似，子类可以实现<code>paint()</code>方法来完成自身的绘制逻辑，<code>paint()</code>签名如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>context.canvas</code>可以取到<code>Canvas</code>对象，接下来就可以调用<code>Canvas</code> API来实现具体的绘制逻辑。</p>
<p>如果节点有子节点，它除了完成自身绘制逻辑之外，还要调用子节点的绘制方法。我们以<code>RenderFlex</code>对象为例说明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果子元素未超出当前边界，则绘制子元素  </span></span><br><span class="line">  <span class="keyword">if</span> (_overflow &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">    defaultPaint(context, offset);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果size为空，则无需绘制</span></span><br><span class="line">  <span class="keyword">if</span> (size.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 剪裁掉溢出边界的部分</span></span><br><span class="line">  context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, defaultPaint);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> debugOverflowHints = <span class="string">'...'</span>; <span class="comment">//溢出提示内容，省略</span></span><br><span class="line">    <span class="comment">// 绘制溢出部分的错误提示样式</span></span><br><span class="line">    Rect overflowChildRect;</span><br><span class="line">    <span class="keyword">switch</span> (_direction) &#123;</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        overflowChildRect = Rect.fromLTWH(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width + _overflow, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        overflowChildRect = Rect.fromLTWH(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, size.height + _overflow);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    paintOverflowIndicator(context, offset, Offset.zero &amp; size,</span><br><span class="line">                           overflowChildRect, overflowHints: debugOverflowHints);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，首先判断有无溢出，如果没有则调用<code>defaultPaint(context, offset)</code>来完成绘制，该方法源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  ChildType child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData;</span><br><span class="line">    <span class="comment">//绘制子节点， </span></span><br><span class="line">    context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，由于Flex本身没有需要绘制的东西，所以直接遍历其子节点，然后调用<code>paintChild()</code>来绘制子节点，同时将子节点<code>ParentData</code>中在layout阶段保存的offset加上自身偏移作为第二个参数传递给<code>paintChild()</code>。而如果子节点还有子节点时，<code>paintChild()</code>方法还会调用子节点的<code>paint()</code>方法，如此递归完成整个节点树的绘制，最终调用栈为： <em>paint() &gt; paintChild() &gt; paint() …</em> 。</p>
<p>当需要绘制的内容大小溢出当前空间时，将会执行<code>paintOverflowIndicator()</code> 来绘制溢出部分提示，这个就是我们经常看到的溢出提示，如图所示：</p>
<p><img src="/images/posts/Flutter/overflow.png" alt="overflow"></p>
<h2 id="RepaintBoundary"><a href="#RepaintBoundary" class="headerlink" title="RepaintBoundary"></a>RepaintBoundary</h2><p>我们已经在<code>CustomPaint</code>一节中介绍过<code>RepaintBoundary</code>，现在我们深入的了解一些。与 <code>RelayoutBoundary</code> 相似，<code>RepaintBoundary</code>是用于在确定重绘边界的，与<code>RelayoutBoundary</code>不同的是，这个绘制边界需要由开发者通过<code>RepaintBoundary</code> 组件自己指定，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CustomPaint(</span><br><span class="line">  size: Size(<span class="number">300</span>, <span class="number">300</span>), <span class="comment">//指定画布大小</span></span><br><span class="line">  painter: MyPainter(),</span><br><span class="line">  child: RepaintBoundary(</span><br><span class="line">    child: Container(...),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>下面我们看看<code>RepaintBoundary</code>的原理，<code>RenderObject</code>有一个<code>isRepaintBoundary</code>属性，该属性决定这个<code>RenderObject</code>重绘时是否独立于其父元素，如果该属性值为<code>true</code> ，则独立绘制，反之则一起绘制。那独立绘制是怎么实现的呢？ 答案就在<code>paintChild()</code>源码中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    _compositeChild(child, offset);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在绘制子节点时，如果<code>child.isRepaintBoundary</code> 为 <code>true</code>则会调用<code>_compositeChild()</code>方法，<code>_compositeChild()</code>源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="comment">// 给子节点创建一个layer ，然后再上面绘制子节点 </span></span><br><span class="line">  <span class="keyword">if</span> (child._needsPaint) &#123;</span><br><span class="line">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(child._layer != <span class="keyword">null</span>);</span><br><span class="line">  child._layer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显了，独立绘制是通过在不同的layer（层）上绘制的。所以，很明显，正确使用<code>isRepaintBoundary</code>属性可以提高绘制效率，避免不必要的重绘。具体原理是：和触发重新build和layout类似，<code>RenderObject</code>也提供了一个<code>markNeedsPaint()</code>方法，其源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="comment">//如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制  </span></span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//找到最近的layer，绘制  </span></span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="comment">// 没有自己的layer, 会和一个祖先节点共用一个layer  </span></span><br><span class="line">    <span class="keyword">assert</span>(_layer == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="comment">// 向父级递归查找  </span></span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">this</span>.parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。  </span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，当调用 <code>markNeedsPaint()</code> 方法时，会从当前 <code>RenderObject</code> 开始一直向父节点查找，直到找到 一个<code>isRepaintBoundary</code> 为 <code>true</code>的<code>RenderObject</code> 时，才会触发重绘，这样便可以实现局部重绘。当 有<code>RenderObject</code> 绘制的很频繁或很复杂时，可以通过RepaintBoundary Widget来指定<code>isRepaintBoundary</code> 为 <code>true</code>，这样在绘制时仅会重绘自身而无需重绘它的 parent，如此便可提高性能。</p>
<p>还有一个问题，通过<code>RepaintBoundary</code> 如何设置<code>isRepaintBoundary</code>属性呢？其实，如果使用了<code>RepaintBoundary</code>，其对应的<code>RenderRepaintBoundary</code>会自动将<code>isRepaintBoundary</code>设为<code>true</code>的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderRepaintBoundary</span> <span class="keyword">extends</span> <span class="title">RenderProxyBox</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates a repaint boundary around [child].</span></span><br><span class="line">  RenderRepaintBoundary(&#123; RenderBox child &#125;) : <span class="keyword">super</span>(child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h1><p>一个对象是否可以响应事件，取决于其对命中测试的返回，当发生用户事件时，会从根节点（<code>RenderView</code>）开始进行命中测试，下面是<code>RenderView</code>的<code>hitTest()</code>源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child.hitTest(result, position: position); <span class="comment">//递归子RenderBox进行命中测试</span></span><br><span class="line">  result.add(HitTestEntry(<span class="keyword">this</span>)); <span class="comment">//将测试结果添加到result中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看看<code>RenderBox</code>默认的<code>hitTest()</code>实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; <span class="meta">@required</span> Offset position &#125;) &#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">if</span> (_size.contains(position)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;</span><br><span class="line">      result.add(BoxHitTestEntry(<span class="keyword">this</span>, position));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到默认的实现里调用了<code>hitTestSelf()</code>和<code>hitTestChildren()</code>两个方法，这两个方法默认实现如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">bool</span> hitTestSelf(Offset position) =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">bool</span> hitTestChildren(HitTestResult result, &#123; Offset position &#125;) =&gt; <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><code>hitTest</code> 方法用来判断该<code>RenderObject</code> 是否在被点击的范围内，同时负责将被点击的 <code>RenderBox</code> 添加到 <code>HitTestResult</code> 列表中，参数 <code>position</code> 为事件触发的坐标（如果有的话），返回 true 则表示有<code>RenderBox</code> 通过了命中测试，需要响应事件，反之则认为当前<code>RenderBox</code>没有命中。在继承<code>RenderBox</code>时，可以直接重写<code>hitTest()</code>方法，也可以重写 <code>hitTestSelf()</code> 或 <code>hitTestChildren()</code>, 唯一不同的是 <code>hitTest()</code>中需要将通过命中测试的节点信息添加到命中测试结果列表中，而 <code>hitTestSelf()</code> 和 <code>hitTestChildren()</code>则只需要简单的返回<code>true</code>或<code>false</code>。</p>
<h1 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h1><p>语义化即Semantics，主要是提供给读屏软件的接口，也是实现辅助功能的基础，通过语义化接口可以让机器理解页面上的内容，对于有视力障碍用户可以使用读屏软件来理解UI内容。如果一个<code>RenderObject</code>要支持语义化接口，可以实现 <code>describeApproximatePaintClip</code>和 <code>visitChildrenForSemantics</code>方法和<code>semanticsAnnotator</code> getter。更多关于语义化的信息可以查看API文档。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了<code>RenderObject</code>主要的功能和方法，理解这些内容可以帮助我们更好的理解Flutter UI底层原理。我们也可以看到，如果要从头到尾实现一个<code>RenderObject</code>是比较麻烦的，我们必须去实现layout、绘制和命中测试逻辑，但是值得庆幸的是，大多数时候我们可以直接在Widget层通过组合或者<code>CustomPaint</code>完成自定义UI。如果遇到只能定义一个新<code>RenderObject</code>的场景时（如要实现一个新的layout算法的布局容器），可以直接继承自<code>RenderBox</code>，这样可以帮我们减少一部分工作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ennis.info/2020/04/10/Flutter输入框获得焦点失效问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis Wu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/10/Flutter输入框获得焦点失效问题/" itemprop="url">「原创」Flutter 输入框获得焦点失效问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-10T13:46:57+08:00">
                2020-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Flutter 中 <code>TextField</code> 由 <code>disable</code> 状态变为 <code>enable</code> 状态时获取焦点会失效，比如下面这段代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> focusNode = FocusNode();</span><br><span class="line">  <span class="keyword">var</span> editable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      editable = !editable;</span><br><span class="line">      <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">        FocusScope.of(context).requestFocus(focusNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'输入框获得焦点'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: TextField(</span><br><span class="line">          focusNode: focusNode,</span><br><span class="line">          enabled: editable,</span><br><span class="line">          decoration: InputDecoration(hintText: <span class="string">'输入'</span>),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: _changeFocus,</span><br><span class="line">          child: Icon(Icons.edit),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是这样</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    editable = !editable;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">      FocusScope.of(context).requestFocus(focusNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望将 <code>TextField</code> 的状态改为 <code>enable</code> 并获得焦点，但这两种写法都是无法获取到焦点的。</p>
<p><img src="/images/posts/Flutter/focus_failure.gif" alt=""></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>我们知道 Flutter 是通过事件驱动更新 UI 的，通过 <code>setState()</code> 方法添加一个更新 UI 事件，当这个事件到达时就会更新 UI。</p>
<p>上述写法失效的原因就在于我们获取焦点时 UI 还未更新，<code>TextField</code> 还处于 <code>disable</code> 状态，是无法获取到焦点的。</p>
<p>我们应该在 <code>build()</code> 方法完成后获取焦点，这时 <code>TextField</code> 已处于 <code>enable</code> 状态。</p>
<h1 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback()"></a>addPostFrameCallback()</h1><p>通过 <code>SchedulerBinding.instance.addPostFrameCallback()</code> 方法可以<strong>注册下一帧绘制完成回调</strong>方法。</p>
<p>该回调只会在下一帧绘制结束时<strong>被调用一次</strong>，调用后会被系统移除。</p>
<p>可以通过该方法监听下一次 <code>build</code> 完成，然后获取焦点。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>下面的写法就可以成功获取到焦点</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    editable = !editable;</span><br><span class="line">    <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">      SchedulerBinding.instance.addPostFrameCallback(</span><br><span class="line">          (_) =&gt; FocusScope.of(context).requestFocus(focusNode));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/Flutter/focus_success.gif" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/portrait.png"
                alt="Ennis L.M. Wu" />
            
              <p class="site-author-name" itemprop="name">Ennis L.M. Wu</p>
              <p class="site-description motion-element" itemprop="description">We could, we could belong togeter, <br>ARTPOP.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:ennis.wu@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/EnnisWu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ennis L.M. Wu</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":80,"height":160,"hOffset":-15},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
