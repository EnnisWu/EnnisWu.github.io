<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="http://pcrioz2ch.bkt.clouddn.com/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="http://pcrioz2ch.bkt.clouddn.com/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="http://pcrioz2ch.bkt.clouddn.com/portrait.png?v=5.1.4">


  <link rel="mask-icon" href="http://pcrioz2ch.bkt.clouddn.com/portrait.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Ennis -Little Monster" type="application/atom+xml" />






<meta name="description" content="We could, we could belong togeter, ARTPOP.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ennis -Little Monster">
<meta property="og:url" content="http://ennis.info/page/5/index.html">
<meta property="og:site_name" content="Ennis -Little Monster">
<meta property="og:description" content="We could, we could belong togeter, ARTPOP.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ennis -Little Monster">
<meta name="twitter:description" content="We could, we could belong togeter, ARTPOP.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ennis.info/page/5/"/>





  <title>Ennis -Little Monster</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ennis -Little Monster</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ARTPOP = artistic revolution through the potential of pop.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/07/23/Android架构——Clean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/23/Android架构——Clean/" itemprop="url">Android架构——Clean</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-23T11:16:49+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android架构/" itemprop="url" rel="index">
                    <span itemprop="name">Android架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Clean架构的主要特点："><a href="#Clean架构的主要特点：" class="headerlink" title="Clean架构的主要特点："></a>Clean架构的主要特点：</h1><ul>
<li>框架独立</li>
<li>容易测试</li>
<li>UI独立</li>
<li>数据库独立</li>
<li>不依赖任何中介</li>
</ul>
<p>Clean的主要思想是外层依赖内层，<strong>内层完全不依赖外层</strong>（或者说内层不知道外层的存在，可以独立开发，复用性强）。</p>
<h1 id="Clean架构解析"><a href="#Clean架构解析" class="headerlink" title="Clean架构解析"></a>Clean架构解析</h1><p><img src="http://pcrioz2ch.bkt.clouddn.com/android/architecture/clean/CleanArchitecture-c.jpg" alt="image"></p>
<ul>
<li>Enterprise Business Rules：业务对象</li>
<li>Application Business Rules：用于处理我们的业务对象，业务逻辑所在，也称为Interactor</li>
<li>Interface Adapters： 接口转换，拿到我们需要的数据，主持者层（Presenters）和控制层（Controllers）就在这一层</li>
<li>Frameworks and Drivers: 这里是所有具体的实现了：比如：UI，工具类，基础框架等等。</li>
</ul>
<p>Clean框架不一定只有4层，这里以4层为例。<br>上面可能比较抽象，下面是简单的说法：</p>
<ul>
<li>第一层：实体类</li>
<li>第二层：也叫UseCase层，实现具体业务逻辑。</li>
<li>第三层：如果是MVP这一层为Presenter，MVC这一层为Controller。</li>
<li>第四层：具体实现。</li>
</ul>
<p><img src="http://pcrioz2ch.bkt.clouddn.com/android/architecture/clean/CleanSimple.jpg" alt="image"></p>
<ol>
<li><strong>内层均为纯Java代码</strong>，只需要jvm便可以运行。</li>
<li>内层代码不仅可以在Android平台，还可以在别的Java平台复用。</li>
<li>各层单独测试，各层之间通过接口通信，且独立，方便单元测试。</li>
<li><strong>层与层之间完全隔离</strong>，最主要的体现就是<strong>各层有自己的数据结构</strong>，不同层之间相互转换，完全没有依赖关系。</li>
<li>通过依赖注入的方式导致灵活修改逻辑、实现，这点与MVP的思想相似，Clean与MVP和Dagger结合使用是天然合适的。</li>
</ol>
<p>以mvp-clean为例，与纯mvp最主要的区别就是Presenter层剥离出UserCase层，一是方便测试，二是方便代码复用，减少Presenter层的代码冗余。</p>
<h1 id="Google-Demo-——-todo-mvp-clean-解析"><a href="#Google-Demo-——-todo-mvp-clean-解析" class="headerlink" title="Google Demo —— todo-mvp-clean 解析"></a>Google Demo —— todo-mvp-clean 解析</h1><blockquote>
<p>demo地址：<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/</a><br>mvp-clean基于mvp，加了 domain layer 介于 presentation 和 repositories。同时也将整个app 分为三个层次处理。</p>
</blockquote>
<h2 id="mvp-clean层次图"><a href="#mvp-clean层次图" class="headerlink" title="mvp-clean层次图"></a>mvp-clean层次图</h2><p><img src="http://pcrioz2ch.bkt.clouddn.com/android/architecture/clean/mvp-clean.png" alt="image"></p>
<ul>
<li>Presentation层 : MVP 设计准则。</li>
<li>Domain层 : 处理所有的业务逻辑，注意是所有的业务逻辑。对应use case（interactors）。</li>
<li>Data层 : 获取数据，以及数据的存储，分为本地和远程。</li>
</ul>
<h2 id="基本概念（摘自mvp-clean-GitHub主页部分原文翻译）"><a href="#基本概念（摘自mvp-clean-GitHub主页部分原文翻译）" class="headerlink" title="基本概念（摘自mvp-clean GitHub主页部分原文翻译）"></a>基本概念（摘自mvp-clean GitHub主页部分原文翻译）</h2><ul>
<li>mvp-clean 和 基本的mvp 最大的区别就是在domain层和UseCase 的使用上。从 presenter 层分离出domain 层好处是可以减少代码的冗余。</li>
<li><strong>UseCase 的好处是在domain的代码层上可以复用。</strong>CompleteTask在TaskDetailPresenter和TasksPresenter做到了很好的复用。</li>
<li>domain layer 是完全解耦与Android 层和第三方依赖的。是一个纯java层的处理。</li>
<li><strong>UseCase 从主线程剥离出来</strong>，对于Android app是个好的操作。这种操作是尽可能的减少占用UI 线程。我们决定使用 command pattern 将use case 在线程池里执行操作。同样的我们可以用RxJava 或者 Promises实现同样的功能。</li>
<li>我们使用异步的repositories 。 但是现在没有必要这么做了。因为UseCase 已经从主线程里剥离出来了。这是尽量保持 samples 和原来的是一致的。</li>
</ul>
<h2 id="项目主要关系图"><a href="#项目主要关系图" class="headerlink" title="项目主要关系图"></a>项目主要关系图</h2><p><img src="http://pcrioz2ch.bkt.clouddn.com/android/architecture/clean/mvpcleanproject.png" alt="image"></p>
<h2 id="具体用例流程"><a href="#具体用例流程" class="headerlink" title="具体用例流程"></a>具体用例流程</h2><p>未完待续。。。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>纯MVP架构会使项目变得复杂，Clean架构则会更复杂，大项目可以使项目的结构清晰，内层复用性强，便于测试。<br>小项目则会使项目过于复杂，反而使项目结构显得不清晰，就像MVVM不适合小型项目一样。MVP作为万金油可以说适合大部分项目，我个人的思考是小型项目使用MVP架构，但在MVP的基础上加入部分Clean的思想。</p>
<ol>
<li>从Presenter层分离出UseCase层，方便代码复用</li>
<li>各层独立，这里有一点需要注意，Clean中各层有各层的数据结构，在实际项目中各层可能写出类似的实体类，这里可以考虑只写一个通用实体类的作为最内层，虽然违背了Clean各层完全独立的思想，但是可以减少部分冗余，这一点根据自己项目来缺点。</li>
</ol>
<blockquote>
<p>参考资料</p>
<ul>
<li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</a></li>
<li><a href="https://www.jianshu.com/p/c6a1a5c9a49b" target="_blank" rel="noopener">https://www.jianshu.com/p/c6a1a5c9a49b</a></li>
<li><a href="https://blog.csdn.net/YANGDAHUAN/article/details/80388849" target="_blank" rel="noopener">https://blog.csdn.net/YANGDAHUAN/article/details/80388849</a></li>
<li><a href="https://www.jianshu.com/p/552c3a1c5fe5" target="_blank" rel="noopener">https://www.jianshu.com/p/552c3a1c5fe5</a></li>
<li><a href="https://www.jianshu.com/p/e0258ce7d392" target="_blank" rel="noopener">https://www.jianshu.com/p/e0258ce7d392</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/07/22/5种写法实现单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/5种写法实现单例模式/" itemprop="url">5种写法实现单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T09:37:52+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式在类加载时初始化。</p>
<p>优点：</p>
<ul>
<li>简单。</li>
<li>天生线程安全。</li>
</ul>
<p>缺点：</p>
<ul>
<li>初始化时机不能由开发者控制，初始化太早造成资源的浪费。</li>
<li>初始化依赖于其他数据，难以控制其他数据是否准备好。</li>
</ul>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventBus使用的方式。</p>
<p>优点：</p>
<ul>
<li>第一次使用时加载，避免了资源浪费。</li>
</ul>
<p>缺点：</p>
<ul>
<li>复杂。</li>
<li>即使是双重检查有时也会失效（可能性极低）。</li>
</ul>
<h1 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《Effective Java》第一版中推荐的写法。<br>内部类加载时初始化，内部类在第一次被调用时类加载。</p>
<p>优点：</p>
<ul>
<li>简单。</li>
<li>巧妙的利用内部类实现线程安全。</li>
</ul>
<h1 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">     INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《Effective Java》第二版中推荐的写法。</p>
<p>优点：</p>
<ul>
<li>极简。</li>
<li>线程安全。</li>
<li><strong>绝对完美单例，可以抵御反序列化、反射。</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>降低可读性。</li>
<li>无法被继承，降低扩展性。</li>
</ul>
<h1 id="容器模式"><a href="#容器模式" class="headerlink" title="容器模式"></a>容器模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用单例管理器统一管理所有单例，可以使用统一接口实现操作，这里只是写了简单的实现，没有优化获取操作，没有优化线程。</p>
<p>优点：</p>
<ul>
<li>方便统一管理。</li>
<li>降低耦合。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能及时找到获取途径，增加开发者的学习成本。</li>
<li>未得到广泛认可。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文一共提供了5种单例模式的实现，最推荐使用静态内部类的方式。饿汉式虽然简单但是容易造成资源浪费，懒汉式过于复杂，即便是双重检查版本也有可能DCL失效，枚举虽然是完美单例但是扩展性低，容器模式需要大量代码优化线程安全和获取操作并且增加了开发者的学习成本。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/dongyu666/p/6971783.html" target="_blank" rel="noopener">https://www.cnblogs.com/dongyu666/p/6971783.html</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">https://blog.csdn.net/itachi85/article/details/50510124</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/07/20/转-Java反射完全解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/转-Java反射完全解析/" itemprop="url">[转]Java反射完全解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T20:31:41+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java反射/" itemprop="url" rel="index">
                    <span itemprop="name">Java反射</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载请注明出处：<a href="https://www.jianshu.com/p/607ff4e79a13" target="_blank" rel="noopener">https://www.jianshu.com/p/607ff4e79a13</a></p>
</blockquote>
<p>本文相关知识点大部分总结自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html" target="_blank" rel="noopener">Oracle官方文档</a>，对于英文比较好的朋友，建议直接阅读原文档。</p>
<p>按例，首先描述一下定义：</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。</p>
</blockquote>
<p>简而言之，你可以在运行状态中通过反射机制做到：</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性;</li>
</ul>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>在我看来我们平时使用 Java 反射主要涉及两个类(接口) <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">Class</a>， <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html" target="_blank" rel="noopener">Member</a>，如果把这两个类搞清楚了，反射基本就 ok 了。</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>提到反射就不得不提到 Class，Class 可以说是反射能够实现的基础；注意这里说的 Class与 class 关键字<strong>不是同一种东西</strong>。class 关键字是在声明 java 类时使用的；而 Class 是 java JDK 提供的一个类,完整路径为 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">java.lang.Class</a>，本质上与 Math, String 或者你自己定义各种类没什么区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">GenericDeclaration</span>, <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 Class 到底在反射中起到什么作用呢？</p>
<blockquote>
<p>For every type of object, the Java virtual machine instantiates an immutable instance of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">java.lang.Class</a> which provides methods to examine the runtime properties of the object including its members and type information. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">Class</a> also provides the ability to create new classes and objects. Most importantly, it is the entry point for all of the Reflection APIs.</p>
</blockquote>
<p>对于每一种类，Java 虚拟机都会初始化出一个 Class 类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应 Class 对象，并且这个 Class 对象会被保存在同名 .class 文件里。当我们 new 一个新对象或者引用静态成员变量时，Java 虚拟机(JVM)中的类加载器系统会将对应 Class 对象加载到 JVM 中，然后 JVM 再根据这个类型信息相关的Class 对象创建我们需要实例对象或者提供静态变量的引用值。</p>
<p>比如创建编译一个 Shapes 类，那么，JVM 就会创建一个 Shapes 对应 Class 类的 Class实例，该 Class 实例保存了 Shapes 类相关的类型信息，包括属性，方法，构造方法等等，通过这个 Class 实例可以在运行时访问 Shapes 对象的属性和方法等。另外通过 Class类还可以创建出一个新的 Shapes 对象。这就是反射能够实现的原因，可以说 Class 是反射操作的基础。</p>
<p>需要特别注意的是，每个 class（注意 class 是小写，代表普通类）类，无论创建多少个实例对象，在 JVM 中都对应同一个 Class 对象。</p>
<p>下面就通过一个简单的例子来说明如何通过反射实例化一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal : name = "</span> + name + <span class="string">" age = "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Reflection"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取Animal类的Class对象</span></span><br><span class="line">        Class c = Animal.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过Class对象反射获取Animal类的构造方法</span></span><br><span class="line">            Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">            <span class="comment">//调用构造方法获取Animal实例</span></span><br><span class="line">            Animal animal = (Animal) constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="comment">//将构造出来的Animal对象打印出来</span></span><br><span class="line">            Log.d(TAG, animal.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看下打印值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03-28 20:12:00.958 2835-2835/? D/Reflection: Animal : name = Jack age = 3</span><br></pre></td></tr></table></figure>
<p>可以看出我们确实成功构造出了 Animal 对象，而且在这过程中 Class 功不可没。有人说你这也太费事了，都知道 Animal 对象了，我分分钟就能给你 new 出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Animal(<span class="string">"Jack"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>没错！但是如果并不能直接导入 Animal 类呢，如果构造方法都是 private 的呢？这个时候反射就能大展身手了。</p>
<h2 id="如何获取Class"><a href="#如何获取Class" class="headerlink" title="如何获取Class"></a>如何获取Class</h2><p>说 Class 是反射能够实现的基础的另一个原因是：Java 反射包 java.lang.reflect 中的所有类都没有 public 构造方法，要想获得这些类实例，只能通过 Class 类获取。所以说如果想使用反射，必须得获得 Class 对象。<br>下面列举了几种能够获取 Class 对象的方法。</p>
<ul>
<li>Object.getClass()<br>通过对象实例获取对应 Class 对象，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns the Class for String</span></span><br><span class="line">Class c = <span class="string">"foo"</span>.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E &#123; A, B &#125;</span><br><span class="line"><span class="comment">//Returns the Class corresponding to the enumeration type E.</span></span><br><span class="line">Class c = A.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//Returns the Class corresponding to an array with component type byte.</span></span><br><span class="line">Class c = bytes.getClass();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="comment">//Returns the Class corresponding to java.util.HashSet.</span></span><br><span class="line">Class c = s.getClass();</span><br></pre></td></tr></table></figure>
<p>然而对于基本类型无法使用这种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line">Class c = b.getClass();   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The .class Syntax<br>通过类的类型获取Class对象,基本类型同样可以使用这种方法，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The `.class` syntax returns the Class corresponding to the type `boolean`.</span></span><br><span class="line">Class c = <span class="keyword">boolean</span>.class;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the Class for String</span></span><br><span class="line">Class c = String.class;</span><br></pre></td></tr></table></figure>
<ul>
<li>Class.forName()<br>通过类的全限定名获取Class对象， 基本类型无法使用此方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>对于数组比较特殊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cDoubleArray = Class.forName(<span class="string">"[D"</span>);    <span class="comment">//相当于double[].class</span></span><br><span class="line"></span><br><span class="line">Class cStringArray = Class.forName(<span class="string">"[[Ljava.lang.String;"</span>);   <span class="comment">//相当于String[][].class</span></span><br></pre></td></tr></table></figure>
<ul>
<li>TYPE Field for Primitive Type Wrappers<br>基本类型和 void 类型的包装类可以使用 TYPE 字段获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = Double.TYPE;   <span class="comment">//等价于 double.class.</span></span><br><span class="line">Class c = Void.TYPE;</span><br></pre></td></tr></table></figure>
<ul>
<li>Methods that Return Classes<br>另外还有一些反射方法可以获取 Class 对象，但前提是你已经获取了一个 Class 对象。<br>有点拗口，比如说你已经获取了一个类的 Class 对象，就可以通过反射方法获取这个类的父类的 Class 对象。</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSuperclass--" target="_blank" rel="noopener">Class.getSuperclass()</a>获得给定类的父类 Class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javax.swing.JButton的父类是javax.swing.AbstractButton</span></span><br><span class="line">Class c = javax.swing.JButton.class.getSuperclass();</span><br></pre></td></tr></table></figure>
<p>类似方法还有：</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClasses--" target="_blank" rel="noopener">Class.getClasses()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredClasses--" target="_blank" rel="noopener">Class.getDeclaredClasses()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaringClass--" target="_blank" rel="noopener">Class.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getEnclosingClass--" target="_blank" rel="noopener">Class.getEnclosingClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Field.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Method.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Constructor.getDeclaringClass()</a></p>
<h2 id="通过Class获取类修饰符和类型"><a href="#通过Class获取类修饰符和类型" class="headerlink" title="通过Class获取类修饰符和类型"></a>通过Class获取类修饰符和类型</h2><p>我们知道类的声明一般如下表示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt5tL9GD0n77s3FwJiarzao9SKeiccYrAOy1qStMPfiadTQhuy4bmt3kx18tyf5zaq3ITOmRK3ib4Be6eA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>下面我们就以 HashMap 为例，通过一个 Demo 来说明如何获取这些信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Reflection"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = HashMap.class;</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        Log.d(TAG, <span class="string">"Class : "</span> + c.getCanonicalName());</span><br><span class="line">        <span class="comment">//获取类限定符</span></span><br><span class="line">        Log.d(TAG, <span class="string">"Modifiers : "</span> + Modifier.toString(c.getModifiers()));</span><br><span class="line">        <span class="comment">//获取类泛型信息</span></span><br><span class="line">        TypeVariable[] tv = c.getTypeParameters();</span><br><span class="line">        <span class="keyword">if</span> (tv.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder parameter = <span class="keyword">new</span> StringBuilder(<span class="string">"Parameters : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (TypeVariable t : tv) &#123;</span><br><span class="line">                parameter.append(t.getName());</span><br><span class="line">                parameter.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, parameter.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Type Parameters --"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类实现的所有接口</span></span><br><span class="line">        Type[] intfs = c.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (intfs.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder interfaces = <span class="keyword">new</span> StringBuilder(<span class="string">"Implemented Interfaces : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Type intf : intfs)&#123;</span><br><span class="line">                interfaces.append(intf.toString());</span><br><span class="line">                interfaces.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, interfaces.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Implemented Interfaces --"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类继承数上的所有父类</span></span><br><span class="line">        List&lt;Class&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        printAncestor(c, l);</span><br><span class="line">        <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder inheritance = <span class="keyword">new</span> StringBuilder(<span class="string">"Inheritance Path : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; cl : l)&#123;</span><br><span class="line">                inheritance.append(cl.getCanonicalName());</span><br><span class="line">                inheritance.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, inheritance.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Super Classes --%n%n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类的注解(只能获取到 RUNTIME 类型的注解)</span></span><br><span class="line">        Annotation[] ann = c.getAnnotations();</span><br><span class="line">        <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder annotation = <span class="keyword">new</span> StringBuilder(<span class="string">"Annotations : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : ann)&#123;</span><br><span class="line">                annotation.append(a.toString());</span><br><span class="line">                annotation.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, annotation.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Annotations --%n%n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAncestor</span><span class="params">(Class&lt;?&gt; c, List&lt;Class&gt; l)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; ancestor = c.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l.add(ancestor);</span><br><span class="line">            printAncestor(ancestor, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Class : java.util.HashMap</span><br><span class="line">03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Modifiers : public</span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Parameters : K  V  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Implemented Interfaces : java.util.Map&lt;K, V&gt;  interface java.lang.Cloneable  interface java.io.Serializable  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Inheritance Path : java.util.AbstractMap  java.lang.Object  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection:   -- No Annotations --</span><br></pre></td></tr></table></figure>
<h1 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h1><blockquote>
<p>Reflection defines an interface <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html" target="_blank" rel="noopener">java.lang.reflect.Member</a> which is implemented by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">java.lang.reflect.Field</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">java.lang.reflect.Method</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">java.lang.reflect.Constructor</a> .</p>
</blockquote>
<p>对于 Member 接口可能会有人不清楚是干什么的，但如果提到实现它的三个实现类，估计用过反射的人都能知道。我们知道类成员主要包括构造函数，变量和方法，Java 中的操作基本都和这三者相关，而 Member 的这三个实现类就分别对应他们。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">java.lang.reflect.Field</a> ：对应类变量<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">java.lang.reflect.Method</a> ：对应类方法<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">java.lang.reflect.Constructor</a> ：对应类构造函数</p>
<p>反射就是通过这三个类才能在运行时改变对象状态。下面就让我们通过一些例子来说明如何通过反射操作它们。</p>
<p>首先建一个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Cat.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"eat food "</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String... foods)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String food : foods)&#123;</span><br><span class="line">            s.append(food);</span><br><span class="line">            s.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"eat food "</span> + s.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name = "</span> + name + <span class="string">" age = "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>通过 Field 你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是 private 的。</p>
<ul>
<li><h3 id="获取-Field"><a href="#获取-Field" class="headerlink" title="获取 Field"></a>获取 Field</h3></li>
</ul>
<p>Class 提供了4种方法获得给定类的 Field</p>
<ul>
<li><ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredField-java.lang.String-" target="_blank" rel="noopener">getDeclaredField(String name)</a>     </p>
<p>获取指定的变量（只要是声明的变量都能获得，包括 private）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getField-java.lang.String-" target="_blank" rel="noopener">getField(String name)</a>      </p>
<p>获取指定的变量（只能获得 public 的）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--" target="_blank" rel="noopener">getDeclaredFields()</a>              </p>
<p>获取所有声明的变量（包括 private）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getFields--" target="_blank" rel="noopener">getFields()</a></p>
<p>获取所有的 public 变量</p>
</li>
</ul>
</li>
<li><h3 id="获取变量类型、修饰符、注解"><a href="#获取变量类型、修饰符、注解" class="headerlink" title="获取变量类型、修饰符、注解"></a>获取变量类型、修饰符、注解</h3></li>
</ul>
<p>一个例子说明问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class c = Cat.class;</span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//获取名称</span></span><br><span class="line">            builder.append(<span class="string">"filed name = "</span>);</span><br><span class="line">            builder.append(f.getName());</span><br><span class="line">            <span class="comment">//获取类型</span></span><br><span class="line">            builder.append(<span class="string">" type = "</span>);</span><br><span class="line">            builder.append(f.getType());</span><br><span class="line">            <span class="comment">//获取修饰符</span></span><br><span class="line">            builder.append(<span class="string">" modifiers = "</span>);</span><br><span class="line">            builder.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="comment">//获取注解</span></span><br><span class="line">            Annotation[] ann = f.getAnnotations();</span><br><span class="line">            <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">" annotations = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : ann)&#123;</span><br><span class="line">                    builder.append(a.toString());</span><br><span class="line">                    builder.append(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.append(<span class="string">"  -- No Annotations --"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filed name = age type = int modifiers = public annotations = @java.lang.Deprecated() </span><br><span class="line">filed name = name type = class java.lang.String modifiers = private  -- No Annotations --</span><br><span class="line">filed name = TAG type = class java.lang.String modifiers = public static final  -- No Annotations --</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="获取、设置变量值"><a href="#获取、设置变量值" class="headerlink" title="获取、设置变量值"></a>获取、设置变量值</h3></li>
</ul>
<p>给定一个对象和它的成员变量名称，就能通过反射获取和改变该变量的值。什么都不说了，没有什么是不能通过一个例子解决的， Easy~</p>
<p>仍然是上面的测试类，通过反射获取并改变 Cat 的 name 和 age.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>, <span class="number">2</span>);</span><br><span class="line">        Class c = cat.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意获取private变量时，需要用getDeclaredField</span></span><br><span class="line">            Field fieldName = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">            Field fieldAge = c.getField(<span class="string">"age"</span>);</span><br><span class="line">            <span class="comment">//反射获取名字, 年龄</span></span><br><span class="line">            String name = (String) fieldName.get(cat);</span><br><span class="line">            <span class="keyword">int</span> age = fieldAge.getInt(cat);</span><br><span class="line">            Log.d(TAG, <span class="string">"before set, Cat name = "</span> + name + <span class="string">" age = "</span> + age);</span><br><span class="line">            <span class="comment">//反射重新set名字和年龄</span></span><br><span class="line">            fieldName.set(cat, <span class="string">"Timmy"</span>);</span><br><span class="line">            fieldAge.setInt(cat, <span class="number">3</span>);</span><br><span class="line">            Log.d(TAG, <span class="string">"after set, Cat "</span> + cat.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯？竟然报错？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.err: java.lang.IllegalAccessException: Class java.lang.Class&lt;com.example.ming.testnestscrollview.TestReflection&gt; cannot access private  field java.lang.String com.example.ming.testnestscrollview.Cat.name of class java.lang.Class&lt;com.example.ming.testnestscrollview.Cat&gt;</span><br><span class="line">System.err:     at java.lang.reflect.Field.get(Native Method)</span><br><span class="line">System.err:     at com.example.ming.testnestscrollview.TestReflection.testField(TestReflection.java:22)</span><br><span class="line">System.err:     at com.example.ming.testnestscrollview.MainActivity.onCreate(MainActivity.java:17)</span><br></pre></td></tr></table></figure>
<p>观察一下异常信息 java.lang.IllegalAccessException，说我们没有权限操作变量 name；回到 Cat 类中查看一下 name 变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
<p>原来 name 变量是 private，Java 运行时会进行访问权限检查，private 类型的变量无法进行直接访问，刚刚进行的反射操作并没有打破这种封装，所以我们依然没有权限对 private属性进行直接访问。</p>
<p>难道就没有办法打破这种限制吗？必须有！强大的反射早已暗中为我们准备好了一切。反射包里为我们提供了一个强大的类。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">java.lang.reflect.AccessibleObject</a></li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 为我们提供了一个方法 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html#setAccessible-boolean-" target="_blank" rel="noopener">setAccessible(boolean flag)</a>，该方法的作用就是可以取消 Java 语言访问权限检查。所以任何继承 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final 类型变量也可以通过这种办法访问）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">Field</a> 正是 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 的子类，那么简单了，只要在访问私有变量前调用 filed.setAccessible(true) 就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fieldName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//反射获取名字, 年龄</span></span><br><span class="line">String name = (String) fieldName.get(cat);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestReflection: before set, Cat name = Tom age = 2</span><br><span class="line">TestReflection: after set, Cat name = Timmy age = 3</span><br></pre></td></tr></table></figure>
<p>Bingo!</p>
<p>注意 Method 和 Constructor 也都是继承 AccessibleObject，所以如果遇到私有方法和私有构造函数无法访问，记得处理方法一样。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><blockquote>
<p>The java.lang.reflect.Method class provides APIs to access information about a method’s modifiers, return type, parameters, annotations, and thrown exceptions. It also be used to invoke methods.</p>
</blockquote>
<p>这节主要介绍如何通过反射访问对象的方法。</p>
<ul>
<li><h3 id="获取-Method"><a href="#获取-Method" class="headerlink" title="获取 Method"></a>获取 Method</h3></li>
</ul>
<p>Class 依然提供了4种方法获取 Method:</p>
<ul>
<li><ul>
<li><p>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p>
<p>根据方法名获得指定的方法， 参数 name 为方法名，参数 parameterTypes 为方法的参数类型，如 getDeclaredMethod(“eat”, String.class)</p>
</li>
<li><p>getMethod(String name, Class&lt;?&gt;… parameterTypes)</p>
<p>根据方法名获取指定的 public 方法，其它同上</p>
</li>
<li><p>getDeclaredMethods()</p>
<p>获取所有声明的方法</p>
</li>
<li><p>getMethods()</p>
<p>获取所有的 public 方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：获取带参数方法时，如果参数类型错误会报 NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class）</p>
</blockquote>
<ul>
<li><h3 id="获取方法返回类型"><a href="#获取方法返回类型" class="headerlink" title="获取方法返回类型"></a>获取方法返回类型</h3></li>
<li><ul>
<li>getReturnType()   获取目标方法返回类型对应的 Class 对象</li>
<li>getGenericReturnType()  获取目标方法返回类型对应的 Type 对象</li>
</ul>
</li>
</ul>
<p>这两个方法有啥区别呢？</p>
<ul>
<li><p>getReturnType()返回类型为 Class，getGenericReturnType() 返回类型为 Type; Class 实现 Type。</p>
</li>
<li><p>返回值为普通简单类型如 Object, int, String 等，getGenericReturnType() 返回值和 getReturnType() 一样</p>
<p>例如 public String function1()，那么各自返回值为：</p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.String</li>
<li>getGenericReturnType() : class java.lang.String</li>
</ul>
</li>
<li><p>返回值为泛型</p>
<p>例如 public T function2()，那么各自返回值为：</p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.Object</li>
<li>getGenericReturnType() : T</li>
</ul>
</li>
<li><p>返回值为参数化类型</p>
<p>例如public Class<string> function3()，那么各自返回值为：</string></p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.Class</li>
<li>getGenericReturnType() : java.lang.Class&lt;java.lang.String&gt;</li>
</ul>
</li>
</ul>
<p>其实反射中所有形如 getGenericXXX()的方法规则都与上面所述类似。</p>
<ul>
<li><h3 id="获取方法参数类型"><a href="#获取方法参数类型" class="headerlink" title="获取方法参数类型"></a>获取方法参数类型</h3><p>getParameterTypes() 获取目标方法各参数类型对应的 Class 对象<br>getGenericParameterTypes() 获取目标方法各参数类型对应的 Type 对象<br>返回值为数组，它俩区别同上 “方法返回类型的区别” 。</p>
</li>
<li><h3 id="获取方法声明抛出的异常的类型"><a href="#获取方法声明抛出的异常的类型" class="headerlink" title="获取方法声明抛出的异常的类型"></a>获取方法声明抛出的异常的类型</h3><p>getExceptionTypes() 获取目标方法抛出的异常类型对应的 Class 对象<br>getGenericExceptionTypes()  获取目标方法抛出的异常类型对应的 Type 对象<br>返回值为数组，区别同上</p>
</li>
<li><h3 id="获取方法参数名称"><a href="#获取方法参数名称" class="headerlink" title="获取方法参数名称"></a>获取方法参数名称</h3><p>.class 文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上 -parameters 参数。(构造方法的参数获取方法同样)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的m可以是普通方法Method，也可以是构造方法Constructor</span></span><br><span class="line"><span class="comment">//获取方法所有参数</span></span><br><span class="line">Parameter[] params = m.getParameters();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    Parameter p = params[i];</span><br><span class="line">    p.getType();   <span class="comment">//获取参数类型</span></span><br><span class="line">    p.getName();  <span class="comment">//获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`, X为参数在方法声明中的位置，从0开始</span></span><br><span class="line">    p.getModifiers(); <span class="comment">//获取参数修饰符</span></span><br><span class="line">    p.isNamePresent();  <span class="comment">//.class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取方法参数名称的详细信息请参考 oracle 的官方例子 MethodParameterSpy</p>
<ul>
<li><h3 id="获取方法修饰符"><a href="#获取方法修饰符" class="headerlink" title="获取方法修饰符"></a>获取方法修饰符</h3></li>
</ul>
<p>方法与 Filed 等类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.getModifiers();</span><br></pre></td></tr></table></figure>
<p>Ps：顺便多介绍几个Method方法</p>
<ol>
<li>method.isVarArgs() //判断方法参数是否是可变参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span>  <span class="comment">//返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt; [] parameterTypes)</span>  <span class="comment">//返回flase</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>method.isSynthetic() //判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法</li>
<li>method.isBridge() //判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。可以参考：<a href="https://www.jianshu.com/u/ceba5da6bd7a" target="_blank" rel="noopener">https://www.jianshu.com/u/ceba5da6bd7a</a></li>
</ol>
<ul>
<li><h3 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h3></li>
</ul>
<p>反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<p>还是以上面测试类 Cat 为例</p>
<blockquote>
<p>注意：如果方法是private的，可以使用 method.setAccessible(true) 方法绕过权限检查</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Cat.class;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//构造Cat实例</span></span><br><span class="line">     Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">     Object cat = constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">//调用无参方法</span></span><br><span class="line">     Method sleep = c.getDeclaredMethod(<span class="string">"sleep"</span>);</span><br><span class="line">     sleep.invoke(cat);</span><br><span class="line">     <span class="comment">//调用定项参数方法</span></span><br><span class="line">     Method eat = c.getDeclaredMethod(<span class="string">"eat"</span>, String.class);</span><br><span class="line">     eat.invoke(cat, <span class="string">"grass"</span>);</span><br><span class="line">     <span class="comment">//调用不定项参数方法</span></span><br><span class="line">     <span class="comment">//不定项参数可以当成数组来处理</span></span><br><span class="line">     Class[] argTypes = <span class="keyword">new</span> Class[] &#123; String[].class &#125;;</span><br><span class="line">     Method varargsEat = c.getDeclaredMethod(<span class="string">"eat"</span>, argTypes);</span><br><span class="line">     String[] foods = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">          <span class="string">"grass"</span>, <span class="string">"meat"</span></span><br><span class="line">     &#125;;</span><br><span class="line">     varargsEat.invoke(cat, (Object)foods);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被调用的方法本身所抛出的异常在反射中都会以 InvocationTargetException 抛出。换句话说，反射调用过程中如果异常 InvocationTargetException 抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。</p>
</blockquote>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>这节主要介绍如何通过反射访问构造方法并通过构造方法构建新的对象。</p>
<ul>
<li><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3></li>
</ul>
<p>和 Method 一样，Class 也为 Constructor 提供了4种方法获取</p>
<ul>
<li><ul>
<li><p>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>获取指定构造函数，参数 parameterTypes 为构造方法的参数类型</p>
</li>
<li><p>getConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>获取指定 public 构造函数，参数 parameterTypes 为构造方法的参数类型</p>
</li>
<li><p>getDeclaredConstructors()</p>
<p>获取所有声明的构造方法</p>
</li>
<li><p>getConstructors()</p>
<p>获取所有的 public 构造方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>构造方法的名称、限定符、参数、声明的异常等获取方法都与 Method 类似，请参照Method。</p>
</blockquote>
<ul>
<li><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3></li>
</ul>
<p>通过反射有两种方法可以创建对象：</p>
<ul>
<li>java.lang.reflect.Constructor.newInstance()</li>
<li>Class.newInstance()</li>
</ul>
<p>一般来讲，我们优先使用第一种方法；那么这两种方法有何异同呢？</p>
<ol>
<li>Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法。</li>
<li>Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出; Constructor.newInstance()会将构造方法中抛出的异常都包装成 InvocationTargetException 抛出。</li>
<li>Class.newInstance()需要拥有构造方法的访问权限; Constructor.newInstance()可以通过 setAccessible(true) 方法绕过访问权限访问 private 构造方法。</li>
</ol>
<p>例子在 Method 一节已经写过，这里直接截取过来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Cat.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Cat cat = (Cat) constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间）</p>
</blockquote>
<h2 id="数组和枚举"><a href="#数组和枚举" class="headerlink" title="数组和枚举"></a>数组和枚举</h2><p>数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以 Java 反射为数组和枚举提供了一些特定的 API 接口。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4></li>
</ul>
<p>数组类型：数组本质是一个对象，所以它也有自己的类型。</p>
<p>例如对于int[] intArray，数组类型为class [I。数组类型中的[个数代表数组的维度，例如[代表一维数组，[[ 代表二维数组；[ 后面的字母代表数组元素类型，I 代表 int，一般为类型的首字母大写(long 类型例外，为 J)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class [B    //byte类型一维数组</span><br><span class="line">class [S    //short类型一维数组</span><br><span class="line">class [I    //int类型一维数组</span><br><span class="line">class [C    //char类型一维数组</span><br><span class="line">class [J    //long类型一维数组，J代表long类型，因为L被引用对象类型占用了</span><br><span class="line">class [F    //float类型一维数组</span><br><span class="line">class [D    //double类型一维数组</span><br><span class="line">class [Lcom.dada.Season    //引用类型一维数组</span><br><span class="line">class [[Ljava.lang.String  //引用类型二维数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个变量的类型</span></span><br><span class="line">Class&lt;?&gt; c = field.getType();</span><br><span class="line"><span class="comment">//判断该变量是否为数组</span></span><br><span class="line"><span class="keyword">if</span> (c.isArray()) &#123;</span><br><span class="line">   <span class="comment">//获取数组的元素类型</span></span><br><span class="line">   c.getComponentType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h4></li>
</ul>
<p>Java 反射为我们提供了 java.lang.reflect.Array 类用来创建和初始化数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组， 参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度</span></span><br><span class="line">Array.newInstance(Class&lt;?&gt; componentType, <span class="keyword">int</span>... dimensions)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值</span></span><br><span class="line">Array.set(Object array, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组的值，array为数组对象，index为数组的下标</span></span><br><span class="line">Array.get(Object array, <span class="keyword">int</span> index)</span><br></pre></td></tr></table></figure>
<p>例子,用反射创建 int[] array = new int[]{1, 2}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Array.setInt(array , <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(array , <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：反射支持对数据自动加宽，但不允许数据 narrowing(变窄?真难翻译)。意思是对于上述 set 方法，你可以在 int 类型数组中 set short 类型数据，但不可以 set long 类型数据，否则会报 IllegalArgumentException。</p>
</blockquote>
<ul>
<li><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4></li>
</ul>
<p>Java 反射没有提供能够直接访问多维数组元素的 API，但你可以把多维数组当成数组的数组处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.get(matrix, <span class="number">0</span>);</span><br><span class="line">Object row1 = Array.get(matrix, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row1 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Array.set(matrix, <span class="number">0</span>, row0);</span><br><span class="line">Array.set(matrix, <span class="number">1</span>, row1);</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举隐式继承自 java.lang.Enum，Enum 继承自 Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外 java 反射额外提供了几个方法为枚举服务。</p>
<ul>
<li><p><code>Class.isEnum()</code></p>
<p>Indicates whether this class represents an enum type</p>
</li>
<li><p><code>Class.getEnumConstants()</code></p>
<p>Retrieves the list of enum constants defined by the enum in the order they’re declared</p>
</li>
<li><p><code>java.lang.reflect.Field.isEnumConstant()</code></p>
<p>Indicates whether this field represents an element of an enumerated type</p>
</li>
</ul>
<h1 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h1><p>没有任何一项技术是十全十美的，Java 反射拥有强大功能的同时也带来了一些副作用。</p>
<ul>
<li><p>性能开销</p>
<p>反射涉及类型动态解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p>安全限制</p>
<p>使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p>内部曝光</p>
<p>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
</ul>
<blockquote>
<p>使用反射的一个原则：如果使用常规方法能够实现，那么就不要用反射。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/06/13/《TCPIP详解卷1》010阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/《TCPIP详解卷1》010阅读笔记/" itemprop="url">《TCPIP详解卷1》010阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T20:05:37+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><table>
<thead>
<tr>
<th>缩写</th>
<th>英文全称</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>AS</td>
<td>Autonomous System</td>
<td>自治系统</td>
</tr>
<tr>
<td>IGP</td>
<td>Interior Gateway Protocol</td>
<td>内部网关协议/域内选路协议</td>
</tr>
<tr>
<td>EGP</td>
<td>Exterier Gateway Protocol</td>
<td>外部网关协议/域内选路协议的分隔选路协议</td>
</tr>
<tr>
<td>BGP</td>
<td>Border Gateway Protocol</td>
<td>边界网关协议</td>
</tr>
<tr>
<td>RIP</td>
<td>Routing Infomation Protocol</td>
<td>选路信息协议</td>
</tr>
<tr>
<td>OSPF</td>
<td>Open Shortest Path First</td>
<td>开放最短路径优先协议</td>
</tr>
<tr>
<td>CIDR</td>
<td>Classless Inter-Domain Routing</td>
<td>无类别域间路由</td>
</tr>
</tbody>
</table>
<ul>
<li>IGP用于自治系统内。</li>
<li>EGP用于自治系统之间。</li>
<li>BGP意在取代EGP。<br><br></li>
</ul>
<h4 id="动态选路"><a href="#动态选路" class="headerlink" title="动态选路"></a>动态选路</h4><ul>
<li>相邻路由器之间进行通信，告知对方每个路由器当前所连接的网络。</li>
<li>路由守护程序根据从相邻路由器收到的信息更新内核中的路由表。</li>
<li>随时间变化时，路由是由路由守护程序动态地增加或删除。</li>
<li>如果路由守护程序发现前往同一信宿存在多条路由，选择最佳路由加入内核路由表。</li>
<li>如果路由守护程序发现一条链路已经断开，删除受影响的路由或增加一条路由绕过。</li>
<li>每个自治系统由单个<strong>实体</strong>管理。==什么是实体？==<br><br></li>
</ul>
<h4 id="RIP：选路信息协议"><a href="#RIP：选路信息协议" class="headerlink" title="RIP：选路信息协议"></a>RIP：选路信息协议</h4><ul>
<li>正式描述文件RFC 1058 [Hedrick 1988a]。</li>
<li>RIP报文包含在UDP数据报中。</li>
<li>RIP的度量是以跳计数的。</li>
<li>最多携带25个路由。<br><br></li>
</ul>
<h6 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h6><ul>
<li>直接连接接口的跳数为1。</li>
<li>一个路由器到一个网络有多条路由，路由器选择跳数最小的路由。</li>
<li>度量为16表示无路由到达该IP地址。<br><br></li>
</ul>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul>
<li>RIP没有子网地址的概念。</li>
<li>路由器或链路发生故障后在稳定下来这段时间可能发生路由环路。</li>
<li>度量最大值限制了可以使用RIP的网络的大小。<br><br></li>
</ul>
<h4 id="RIP版本2"><a href="#RIP版本2" class="headerlink" title="RIP版本2"></a>RIP版本2</h4><ul>
<li>RFC 1388 [Malkin 1993a] 对RIP定义进行了扩充。</li>
<li>路由域字段：数据报的所有者。</li>
<li>选路标记字段：携带一个EGP和BGP的自治系统号。</li>
<li>子网掩码字段：应用于相应的IP地址。</li>
<li>下一站IP地址字段：指明发往目的IP地址的报文应该发往哪里。</li>
<li>除了支持广播，还支持多播。<br><br></li>
</ul>
<h4 id="OSPF：开放最短路径优先"><a href="#OSPF：开放最短路径优先" class="headerlink" title="OSPF：开放最短路径优先"></a>OSPF：开放最短路径优先</h4><ul>
<li>RFC 1247 [Moy 1991] 对第2版OSPF进行了描述。</li>
<li>OSPF克服了RIP所有限制。</li>
<li>路由器不与临站交换距离信息，主动测试与临站相连的链路状态。</li>
<li>信息发给其他临站，临站将这些信息在自治系统中传播出去。</li>
<li>路由器接收这些链路状态信息，建立完整的路由表。</li>
<li>链路状态协议总是比距离向量协议稳定更快。</li>
<li>OSPF直接使用IP，不使用UDP或TCP。</li>
<li>优于RIP的特点：</li>
<li><ol>
<li>可以对每个IP服务类型计算各自的路由集。</li>
</ol>
</li>
<li><ol start="2">
<li>给每个接口指派一个无维数的费用。</li>
</ol>
</li>
<li><ol start="3">
<li>同一个目的地址存在多个相同费用的路由时，平均分配流量。</li>
</ol>
</li>
<li><ol start="4">
<li>支持子网，子网掩码与每个通告相连。</li>
</ol>
</li>
<li><ol start="5">
<li>无编号网络。</li>
</ol>
</li>
<li><ol start="6">
<li>简单鉴别机制。</li>
</ol>
</li>
<li><ol start="7">
<li>采用多播而不是广播形式，减少系统负载。<br><br></li>
</ol>
</li>
</ul>
<h4 id="BGP：边界网关协议"><a href="#BGP：边界网关协议" class="headerlink" title="BGP：边界网关协议"></a>BGP：边界网关协议</h4><ul>
<li>RFC 1267 [Lougheed and Rekhter 1991] 对第3版BGP进行描述。</li>
<li>BGP系统之间交换网络可到达信息，包括所必须经过的自治系统的所有路径。</li>
<li>使用BGP的一个目的是减少通过流量。</li>
<li>允许使用基于策略的选路。</li>
<li>使用TCP作为其传输层协议。</li>
<li>BGP是一个距离测量协议，列举了到每个目的地址的路由，排除了一些距离向量协议的问题。</li>
<li>定期发送keepalive报文给临站来监测TCP连接对端的链路或主机失败。</li>
<li>应用层的keepalive报文与TCP的keepalive报文选项相互独立。<br><br></li>
</ul>
<h4 id="CIDR：无类型域间选路"><a href="#CIDR：无类型域间选路" class="headerlink" title="CIDR：无类型域间选路"></a>CIDR：无类型域间选路</h4><ul>
<li>RFC 1518 [Rekher and Li 1993], RFC 1519 [Fuller et al. 1993]对它描述。</li>
<li>[Ford, Rekhter, and Braun 1993] 综述。</li>
<li>一个防止路由表膨胀的方法，也成为超网。</li>
<li>采用分配多个IP地址的方式，使许多表项总和成更少的数目</li>
<li>必须满足3种特性：</li>
<li><ol>
<li>IP地址必须具有相同的高位地址比特。</li>
</ol>
</li>
<li><ol start="2">
<li>路由表和选路算法必须扩展成根据32 bit IP地址和32 bit 掩码做出选路决策。</li>
</ol>
</li>
<li><ol start="3">
<li>选路协议要有32 bit掩码。</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/06/12/《TCPIP详解卷1》007、008、009阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》007、008、009阅读笔记/" itemprop="url">《TCPIP详解卷1》007、008、009阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T20:32:56+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="007，Ping的工作原理"><a href="#007，Ping的工作原理" class="headerlink" title="007，Ping的工作原理"></a>007，Ping的工作原理</h4><h6 id="Unix系统的实现"><a href="#Unix系统的实现" class="headerlink" title="Unix系统的实现"></a>Unix系统的实现</h6><ul>
<li>把ICMP报文中标识符字段设置成发送进程的ID号（识别多个Ping程序实例）。</li>
<li>序列号从0开始，每发送一次新的回显请求就 + 1。</li>
<li>Ping程序允许我们查看是否有分组丢失、失序或重复。<br><br></li>
</ul>
<h6 id="旧版本Ping程序"><a href="#旧版本Ping程序" class="headerlink" title="旧版本Ping程序"></a>旧版本Ping程序</h6><ul>
<li>每秒发送一个回显请求。</li>
<li>打印返回的每个分组的每个回显应答。<br><br></li>
</ul>
<h6 id="新版本Ping程序"><a href="#新版本Ping程序" class="headerlink" title="新版本Ping程序"></a>新版本Ping程序</h6><ul>
<li>需要加上 - s 选项以旧版本模式运行。</li>
<li>Ping程序只发送一个回显请求。</li>
<li>收到回显应答输出“host is alive”，20秒内没收到输出“no answer”。<br><br></li>
</ul>
<h4 id="008，Traceroute的工作原理"><a href="#008，Traceroute的工作原理" class="headerlink" title="008，Traceroute的工作原理"></a>008，Traceroute的工作原理</h4><ul>
<li>每个处理数据报的路由器都要把TTL的值减1或停留的秒数。</li>
<li>大多数路由器转发数据报的时延都小于1秒，TTL最终成为一个跳站计数器。</li>
<li>如果TTL字段是1，路由器将该数据报丢弃，并向信源机放一份ICMP“超时”信息。</li>
<li>Traceroute程序发送一份TTL字段为1的IP数据报为目的主机，第一个路由器丢弃并发回超时ICMP报文，然后Traceroute程序发送一份TTL字段为2的数据报，得到第二个路由器的地址，以此类推。</li>
<li>目的主机收到TTL值为1的IP数据报，不会丢弃并产生ICMP超时报文。</li>
<li>Traceroute程序发送一份不可能值作为UDP端口号（大于30000）的UDP数据报给目的主机，目的主机产生一份“端口不可达”错误的ICMP报文。</li>
<li>Traceroute程序区分收到的ICMP报文是超时还是端口不可达判断是否结束。<br><br></li>
</ul>
<h4 id="009，IP包选路的工作原理"><a href="#009，IP包选路的工作原理" class="headerlink" title="009，IP包选路的工作原理"></a>009，IP包选路的工作原理</h4><h6 id="选路的原理"><a href="#选路的原理" class="headerlink" title="选路的原理"></a>选路的原理</h6><ul>
<li>IP搜索路由表的步骤：</li>
<li><ol>
<li>搜索匹配的主机地址。</li>
</ol>
</li>
<li><ol start="2">
<li>搜索比配的网络地址。</li>
</ol>
</li>
<li><ol start="3">
<li>搜索默认表项。</li>
</ol>
</li>
<li>IP层进行的选路是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。</li>
<li>选路策略决定把哪些路由放入路由表的规则，路由守护程序提供选路策略。<br><br></li>
</ul>
<h6 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h6><ul>
<li>在系统引导时显示地的在初始化文件中运行route命令。<br><br></li>
</ul>
<h6 id="没有到达目的地的路由"><a href="#没有到达目的地的路由" class="headerlink" title="没有到达目的地的路由"></a>没有到达目的地的路由</h6><p>路由表中没有默认项，又没有找到匹配项。</p>
<ul>
<li>数据报由本地主机产生：向应用程序返回一个“主机不可达差错”或“网络不可达差错”。</li>
<li>被转发的数据报：向原始发送端发送一份ICMP主机不可达差错报文。<br><br></li>
</ul>
<h6 id="ICMP重定向差错"><a href="#ICMP重定向差错" class="headerlink" title="ICMP重定向差错"></a>ICMP重定向差错</h6><ul>
<li>当数据报应该被发送到另一个路由器时，收到数据报的路由器要发送ICMP重定向差错报文给IP数据报的发送端。</li>
<li>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。<br><br></li>
</ul>
<h6 id="ICMP重定向报文"><a href="#ICMP重定向报文" class="headerlink" title="ICMP重定向报文"></a>ICMP重定向报文</h6><ul>
<li>重定向报文只能由路由器生成。</li>
<li>重定向报文是为主机使用的。<br><br></li>
</ul>
<h6 id="ICMP路由器发现报文"><a href="#ICMP路由器发现报文" class="headerlink" title="ICMP路由器发现报文"></a>ICMP路由器发现报文</h6><ul>
<li>一份报文可以通告多个地址。</li>
<li>路由器启动时定期在所有广播或多播传送接口上发送通告报文。</li>
<li>某个接口被关闭时，该接口上发送一份通告报文，生命周期值设为0。</li>
<li>监听来自主机的请求报文，并发送通告报文以响应。</li>
<li>主机在引导期间发送请求报文。</li>
<li>监听来自相邻路由器的请求报文。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/06/12/《TCPIP详解卷1》006阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》006阅读笔记/" itemprop="url">《TCPIP详解卷1》006阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T16:34:53+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ICMP的正式规范参见 RFC 792<br><br></p>
<p>ICMP是IP层的一个组成部分，传递差错报文和其他需要注意的信息。<br>通常被IP层或更高层协议使用。<br><br></p>
<p><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/ICMP.png" alt="image"></p>
<ul>
<li>校验和覆盖整个ICMP报文，算法与IP首部相同</li>
<li>不同类型和代码有不同的内容<br><br></li>
</ul>
<h4 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h4><ul>
<li>类型字段和代码字段共同决定。</li>
<li><p>ICMO差错报文始终包含IP首部和产生差错的IP数据报的前8个字节。<br>接收ICMP差错报文的模块可以与某个协议和用户进程联系起来。</p>
</li>
<li><p>下面情况不产生差错报文：</p>
</li>
<li><ol>
<li>ICMP差错报文</li>
</ol>
</li>
<li><ol start="2">
<li>目的地址是广播或多播地址</li>
</ol>
</li>
<li><ol start="3">
<li>作为链路层广播的数据报</li>
</ol>
</li>
<li><ol start="4">
<li>不是IP分片的第一片</li>
</ol>
</li>
<li><ol start="5">
<li>源地址不是单个主机的数据报<br><br></li>
</ol>
</li>
</ul>
<h4 id="ICMP地址掩码请求与应答"><a href="#ICMP地址掩码请求与应答" class="headerlink" title="ICMP地址掩码请求与应答"></a>ICMP地址掩码请求与应答</h4><p><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/mask.png" alt="iamge"></p>
<ul>
<li>用于无盘系统在引导过程中获取自己的子网掩码。</li>
<li>系统广播他的ICMP请求报文（类似RARP获取IP地址）。</li>
<li>标识符和序列号由发送端任意设定，在应答中返回进行匹配。<br><br></li>
</ul>
<h4 id="ICMP时间戳请求与应答"><a href="#ICMP时间戳请求与应答" class="headerlink" title="ICMP时间戳请求与应答"></a>ICMP时间戳请求与应答</h4><p><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/time_stamp_request_response.png" alt="image"></p>
<ul>
<li>请求允许系统向另一个系统查询当前时间。</li>
<li>返回的建议值是自午夜计算的毫秒数，协调的统一时间。</li>
<li>缺陷：必须通过其他方法获知当时的日期。</li>
<li>请求端填写发起时间戳，应答系统收到时填写接收时间戳，发送时填写传送时间戳。<br><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/time_stamp_request.png" alt="image"><br><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/RTT.png" alt="image"></li>
<li>调整值是difference - RTT / 2。<br><br></li>
</ul>
<h4 id="ICMP端口不可达差错"><a href="#ICMP端口不可达差错" class="headerlink" title="ICMP端口不可达差错"></a>ICMP端口不可达差错</h4><p>以UDP端口不可达为例。<br><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/unreachable_response.png" alt="image"></p>
<ul>
<li>IP首部后面前8个字节是UDP首部（源端口号和目的端口号）。<br><img src="http://pcrioz2ch.bkt.clouddn.com/TCPIP1/06/unreachable.png" alt="image"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/06/12/《TCPIP详解卷1》004阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》004阅读笔记/" itemprop="url">《TCPIP详解卷1》004阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T15:38:11+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RFC 826 [Plummer 1982] 是ARP规范描述文档。<br>ARP（地址解析协议）<br>RARP（逆地址解析协议）<br><br></p>
<p>ARP为IP地址到对应硬件地址之间提供动态映射，因为是自动完成的。<br>RARP被没有磁盘驱动器的系统使用，需要系统管理员手工设置。<br><br></p>
<p>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。称作广播。<br><br></p>
<p>点对点链路不使用ARP。设置这些链路时，必须告知内核链路每一端的IP地址，而不需要硬件地址。<br><br></p>
<p>ARP高效运行因为每个主机上都有一个ARP高速缓存<br><br></p>
<h4 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h4><table>
<thead>
<tr>
<th>以太网目的地址</th>
<th>以太网源地址</th>
<th>帧类型</th>
<th>硬件类型</th>
<th>协议类型</th>
<th>硬件地址长度</th>
<th>协议地址长度</th>
<th>op</th>
<th>发送端以太网地址</th>
<th>发送端IP地址</th>
<th>目的以太网地址</th>
<th>目的IP地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>6</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>全1</td>
<td></td>
<td>0x0806</td>
<td>1</td>
<td>0x0800</td>
<td>6 bytes</td>
<td>4 bytes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>广播地址</td>
<td></td>
<td>ARP请求或应答</td>
<td>表示以太网地址</td>
<td>表示IP地址</td>
<td>MAC地址长度</td>
<td>IP地址长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>目的地址：全1的特殊地址是广播地址，电缆上的所有以太网接口都要接收广播的数据帧。</li>
<li>操作字段（OP）：ARP请求（1）、ARP应答（2）、RARP请求（3）、RARP应答（4），必须字段，因为ARP请求和应答的帧类型字段相同。<br><br></li>
</ul>
<h4 id="ARP高速缓存超时设置"><a href="#ARP高速缓存超时设置" class="headerlink" title="ARP高速缓存超时设置"></a>ARP高速缓存超时设置</h4><ul>
<li>BSD演变来的系统一般设置完整表项超时20分钟，不完整表项超时3分钟。</li>
<li>表项再次使用时，超时值重设为20分钟。<br><br></li>
</ul>
<h4 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h4><ul>
<li>路由器相当于目的主机的代理，把分组从其他主机转发给它。<br><br></li>
</ul>
<h4 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h4><ul>
<li>是指发送ARP查找自己的IP地址。</li>
<li>两方面作用：</li>
<li><ol>
<li>验证IP是否冲突，一个主机能够通过它来确定是否还有一个主机设置了相同的IP地址。</li>
</ol>
</li>
<li><ol>
<li>更换物理网卡，假设发送ARP的主机正好改变了物理地址，能够使用此方法通知网络中其他主机及时更新ARP缓存。<br><br></li>
</ol>
</li>
</ul>
<h4 id="ARP命令"><a href="#ARP命令" class="headerlink" title="ARP命令"></a>ARP命令</h4><ul>
<li>arp -a 显示ARP高速缓存。</li>
<li>arp -d 删除ARP高速缓存中某一项。</li>
<li>arp -s 增加高速缓存中的内容，是永久性的，除非末尾加上关键字temp。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/06/02/《TCPIP详解卷1》003阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/02/《TCPIP详解卷1》003阅读笔记/" itemprop="url">《TCP/IP详解卷1》003阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-02T15:07:17+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IP的正式规范文件：RFC 791</p>
<p>所有TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。<br>不可靠：不能保证IP数据报能够成功到达目的地。可靠性必须由上层提供。<br>无连接：IP不维护后续数据报的状态信息。每个数据报的处理相互独立。IP数据报可以不按发送顺序接收。</p>
<p>传输次序：网络字节序/big endian（大端）字节序</p>
<h4 id="IP首部字段"><a href="#IP首部字段" class="headerlink" title="IP首部字段"></a>IP首部字段</h4><table>
<thead>
<tr>
<th>字段名</th>
<th>长度</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>版本</td>
<td>4位</td>
<td>4</td>
</tr>
<tr>
<td>首部长度</td>
<td>4位</td>
<td>首部占32bit字的数目，没有任何选项，值为5，首部最长60字节</td>
</tr>
<tr>
<td>服务类型（TOS）</td>
<td>8位</td>
<td>3bit优先权子字段（已忽略），4bitTOS子字段，1bit未用位（置为0）</td>
</tr>
<tr>
<td>总长度</td>
<td>16位</td>
<td>字节为单位，最长65535字节。<strong>必要内容</strong></td>
</tr>
<tr>
<td>位标识</td>
<td>16位</td>
<td>唯一标识主机发送的每一份数据报</td>
</tr>
<tr>
<td>位标志</td>
<td>3位</td>
<td></td>
</tr>
<tr>
<td>位片偏移</td>
<td>13位</td>
<td></td>
</tr>
<tr>
<td>生存时间（TTL）</td>
<td>8位</td>
<td>经过的最多路由器数，初始值通常为64或32，源主机设置。</td>
</tr>
<tr>
<td>协议</td>
<td>8位</td>
<td></td>
</tr>
<tr>
<td>首部校验和</td>
<td>16位</td>
<td>根据IP首部计算校验和码。</td>
</tr>
<tr>
<td>选项</td>
<td></td>
<td>可选，可变长。32bit为界限，不够时插入值为0的填充字节。</td>
</tr>
</tbody>
</table>
<ul>
<li>首部长度：从包头格式图看出，是以32bit为一行的，一行包括若干字段。首部长度的数值是以32bit为单位来描述的，比如四位全为1，十六进制本来是0X0F，也就是十进制的15但是，<strong>这个字段的1不是数值1，而是指1个单位即一个32bit。</strong>所以如果该字段是1111的话。就是15*32bit=60Byte了。 </li>
<li>4bit的TOS代表：最小时延、最大吞吐量、最高可靠性、最小费用。</li>
<li>首部长度、总长度计算数据内容的起始位置和长度。</li>
<li>TTL为0时丢弃数据报，发送ICMP报文通知源主机。</li>
<li>首部校验和：如果校验和错误，丢弃数据报，但不生成差错报文，由上层发现并重传。</li>
</ul>
<h4 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h4><p>目的主机与源主机直接相连，或都在一个共享网络上，IP数据报直接送到目的主机。<br>否则发往默认路由，由路由器转发。<br><br></p>
<h6 id="IP层可以配置成路由器或主机"><a href="#IP层可以配置成路由器或主机" class="headerlink" title="IP层可以配置成路由器或主机"></a>IP层可以配置成路由器或主机</h6><p>主机：不转发<br>路由器：转发<br>内含路由器的主机：不转发<br><br></p>
<h6 id="收到数据报来自网络接口时（即非本地生成的数据报）"><a href="#收到数据报来自网络接口时（即非本地生成的数据报）" class="headerlink" title="收到数据报来自网络接口时（即非本地生成的数据报）"></a>收到数据报来自网络接口时（即非本地生成的数据报）</h6><ul>
<li>检查IP地址<ul>
<li>是本机IP地址之一或IP广播地址：发送到指定协议模块<ul>
<li>IP层设置为路由器：转发</li>
<li>否则：丢弃<br><br></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h6><table>
<thead>
<tr>
<th>项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的IP地址</td>
<td>表中标志字段指定类型。完整的主机地址：非0主机号。网络地址：主机号为0。</td>
</tr>
<tr>
<td>下一跳路由器IP地址</td>
<td>或者有直接连接的网络IP地址。</td>
</tr>
<tr>
<td>标志</td>
<td>一个指明目的IP地址类型，==<strong>一个标志下一站路由器时真下一站路由器还是直接相连的接口。</strong>看不懂这句==</td>
</tr>
<tr>
<td>指定网络接口</td>
</tr>
</tbody>
</table>
<p>IP不知道目的的完整路径<br><br></p>
<h6 id="IP路由选择主要功能"><a href="#IP路由选择主要功能" class="headerlink" title="IP路由选择主要功能"></a>IP路由选择主要功能</h6><p>搜索路由表</p>
<ol>
<li>寻找与目的IP完全匹配（网络号和主机号）的条目</li>
<li>寻找与目的网络号相匹配的条目（必须考虑子网掩码）</li>
<li>寻找“默认”的条目</li>
</ol>
<p>如果找到，报文发送指定的下一站路由器或直接相连的网络接口。<br>如果都未成功，则不能被传送，向应用返回错误<br><br></p>
<h4 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h4><p>==看不懂图==</p>
<ul>
<li>所有主机都要求支持子网寻址。</li>
<li>IP地址 = 网络号 + 子网号 + 主机号</li>
<li>B类IP地址 = 网络号（16位）+ 子网号（8位）+ 主机号（8位）</li>
<li>子网对外部路由器来说隐藏了内部网络组织。</li>
<li>子网划分缩减了路由表的规模。</li>
<li>子网对于子网内部的路由器不透明。==不懂==</li>
</ul>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><ul>
<li>标识多少bit用于子网号，多少bit用于主机号。</li>
<li>掩码是32bit的值，值为1留给网络号和子网号，值为0留给主机号。</li>
<li>给定IP地址和子网掩码后可以确定：</li>
<li><ol>
<li>本子网上的主机。</li>
</ol>
</li>
<li><ol start="2">
<li>本网络中其他子网中的主机。</li>
</ol>
</li>
<li><ol start="3">
<li>其他网络上的主机。</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/05/31/《TCPIP详解卷1》002阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/《TCPIP详解卷1》002阅读笔记/" itemprop="url">《TCPIP详解卷1》002阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T11:45:10+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>LLC：逻辑链路控制（Logic Link Control）</li>
<li>SNAPL：自网络访问协议（SubNetwork Access Protocol）</li>
<li>IEEE：电子电气工程师协会</li>
<li>CRC：循环冗余校验（Cyclic Redundancy Check ）</li>
<li>pad字节：padding byte，填充字节</li>
<li>RS-232：异步传输标准接口</li>
<li>BSD：Berkeley Software Distribution，Unix的衍生系统<br><br></li>
</ul>
<h4 id="链路层主要三个目的"><a href="#链路层主要三个目的" class="headerlink" title="链路层主要三个目的"></a>链路层主要三个目的</h4><ol>
<li>为IP模块发送接受IP数据报。</li>
<li>为ARP模块发送ARP请求和接受ARP应答。</li>
<li>为RARP发送RARP请求和接受RARP应答。<br><br></li>
</ol>
<h4 id="以太网与IEEE-802封装对比"><a href="#以太网与IEEE-802封装对比" class="headerlink" title="以太网与IEEE 802封装对比"></a>以太网与IEEE 802封装对比</h4><table>
<thead>
<tr>
<th></th>
<th>以太网</th>
<th>IEEE 802</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据报封装</td>
<td>RFC 894中定义</td>
<td>RFC 1042中定义</td>
<td></td>
</tr>
<tr>
<td>长度字段</td>
<td></td>
<td>后续数据的长度字段（不包括CRC）</td>
<td></td>
</tr>
<tr>
<td>类型字段</td>
<td>后续数据的类型</td>
<td>由后续子网接入协议的首部给出</td>
<td>格式相同</td>
</tr>
<tr>
<td>最小长度</td>
<td>46字节</td>
<td>38字节</td>
<td>不足空间填充pad字节</td>
</tr>
</tbody>
</table>
<p>有效类型值都不相同，可以对两种帧格式进行区分。<br>以太网：类型字段后是数据。<br>IEEE 802：长度字段后是802.2LLC、802.2SNAP。<br>CRC字段（FCS/帧校验序列）：后续字节差错的循环冗余码校验。<br><br></p>
<h4 id="尾部封装"><a href="#尾部封装" class="headerlink" title="尾部封装"></a>尾部封装</h4><ul>
<li>在RFC 89C被描述。</li>
<li>通过调整IP数据报中字段次序提高性能。</li>
<li>将IP首部和TCP首部移到尾部CRC之前。</li>
<li>==<strong>当把数据复制到内核是，可以绑数据帧中的数据部分映射到一个硬件页面，节省到内存的复制过程。</strong>看不懂？？？==</li>
<li><strong>尾部封装已遭到反对。</strong><br><br></li>
</ul>
<h4 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a>SLIP：串行线路IP</h4><ul>
<li>串行线路上对IP数据报封装的简单形式。</li>
<li>适用于RS-232串行端口、高速调制解调器接入网络。</li>
<li>以END(0XC0)的特殊字符结束。</li>
<li>如果有线路噪声，开始也传一个END(0XC0)字符。</li>
<li>IP报文中END用0XDB和0XDC取代（称为ESC字符）。</li>
<li>IP报文中ESC用0XDB和0XDD取代。</li>
<li>缺陷：</li>
<li><ol>
<li>每一端必须知道对方的IP地址。</li>
</ol>
</li>
<li><ol start="2">
<li>没有类型字段，不能和其他协议同时使用。</li>
</ol>
</li>
<li><ol start="3">
<li>没有校验和。<br><br></li>
</ol>
</li>
</ul>
<h4 id="压缩的SLIP（CSLIP）"><a href="#压缩的SLIP（CSLIP）" class="headerlink" title="压缩的SLIP（CSLIP）"></a>压缩的SLIP（CSLIP）</h4><ul>
<li>在RFC 1144中被描述。</li>
<li>为了在SLIP上传输1个字节总共需要40字节，CSLIP能把它们压缩到3或5个字节。</li>
<li>每一端维持多达16个TCP连接。</li>
<li>知道每个连接的首部哪些字段一般不会发生变化。</li>
<li>被压缩的首部大大缩短了交互响应时间。<br><br></li>
</ul>
<h4 id="PPP点对点协议"><a href="#PPP点对点协议" class="headerlink" title="PPP点对点协议"></a>PPP点对点协议</h4><p><strong>修改了SLIP协议中的所有缺陷，最终应该取代SLIP。</strong><br><br></p>
<h6 id="PPP包括三个部分："><a href="#PPP包括三个部分：" class="headerlink" title="PPP包括三个部分："></a>PPP包括三个部分：</h6><ol>
<li>在串行链路上封装IP数据报的方法。</li>
<li>建立、配置及测试数据链路的链路控制协议。</li>
<li>针对不同网络层协议的网络控制协议体系。<br><br><h6 id="数据报帧的格式："><a href="#数据报帧的格式：" class="headerlink" title="数据报帧的格式："></a>数据报帧的格式：</h6></li>
</ol>
<ul>
<li>以0X7E开始和结束。</li>
<li>地址字节值始终为0XFF。</li>
<li>协议字段（类似以太网类型字段）：<br>| 协议字段的值 | 标识信息字段的类型 |<br>| ———- | —————-|<br>| 0X0021 | IP数据报 |<br>| 0XC021 | 链路控制数据 |<br>| 0X8021 | 网络控制数据 |<br>信息字段出现0X7E时需要转义。<br><br><br>利用链路控制协议，大多数可以省略标识符和地址字段。<br>使用IP网络控制协议，大多数可以采用Van Jacobson报文首部压缩方法。不懂？？？<br><br><br>对比SLIP具有的优点</li>
</ul>
<ol>
<li>PPP支持在单根串行线路上运行多种协议。</li>
<li>每一帧都有循环冗余校验。</li>
<li>通信双方可以进行IP地址的动态协商。</li>
<li>与CSLIP类似，对TCP和IP报文首部压缩。</li>
<li>链路控制协议可以对多个数据链路选项进行设置。<br><br></li>
</ol>
<h4 id="环回接口（localhost）"><a href="#环回接口（localhost）" class="headerlink" title="环回接口（localhost）"></a>环回接口（localhost）</h4><ul>
<li>大多数系统把IP地址127.0.0.1分配给这个接口。</li>
<li>一个传给环回接口的IP数据报不能在任何网络上出现。<br><br></li>
</ul>
<h4 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h4><ul>
<li>如果IP层有一个长度大于链路层的MTU的数据报要传，需要进行分片。</li>
<li>MTU不是物理特性，它是一个逻辑限制。</li>
<li>目的：为交互使用提供足够快的响应时间。<br><br></li>
</ul>
<h4 id="路径MTU"><a href="#路径MTU" class="headerlink" title="路径MTU"></a>路径MTU</h4><p>==<strong>两台主机路径中的最小MTU被称作路径MTU（不一定是个常数）。</strong>看不懂这句话==<br><br></p>
<h4 id="串行线路吞吐量计算"><a href="#串行线路吞吐量计算" class="headerlink" title="串行线路吞吐量计算"></a>串行线路吞吐量计算</h4><blockquote>
<p>如果线路速率是9600b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960B/s（字节/秒）。</p>
</blockquote>
<ul>
<li>这句话是指每个bit加一个起始一个停止，所有9600 / (8 + 2) = 960 B/s。</li>
<li>如果把SLIP的MTU降到256以下，将降低传输大块数据的最大吞吐量。</li>
<li>平均等待时间的计算（传输大数据帧所需时间的一半）只适用于SLIP或PPP链路。<br>==为什么要等一半的时间？？==<br><br></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ennis.info/2018/04/09/Toolbar的setTitle问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pcrioz2ch.bkt.clouddn.com/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/Toolbar的setTitle问题/" itemprop="url">Toolbar的setTitle问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T23:28:53+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android视图/" itemprop="url" rel="index">
                    <span itemprop="name">Android视图</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在setSupportActionBar(toolbar)之后调用toolbar.setTitle()，<br>在onCreate()中调用无效，<br>在onStart()中调用无效。</p>
<p>解决方案：</p>
<ol>
<li>在onResume()中调用有效。</li>
<li>getSupportActionBar.setTitle()有效</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://pcrioz2ch.bkt.clouddn.com/portrait.png"
                alt="Ennis L.M. Wu" />
            
              <p class="site-author-name" itemprop="name">Ennis L.M. Wu</p>
              <p class="site-description motion-element" itemprop="description">We could, we could belong togeter, ARTPOP.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/EnnisWu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/EnnisWu" target="_blank" title="Gitee">
                      
                        <i class="fa fa-fw fa-git"></i>Gitee</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/EnnisWu" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/ennis_wu" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wkf1997@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ennis L.M. Wu</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
