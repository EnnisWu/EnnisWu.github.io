<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/portrait.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/portrait.png?v=5.1.4">


  <link rel="mask-icon" href="/images/portrait.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Ennis -Little Monster" type="application/atom+xml" />






<meta name="description" content="We could belong togeter, ARTPOP .">
<meta property="og:type" content="website">
<meta property="og:title" content="Ennis -Little Monster">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Ennis -Little Monster">
<meta property="og:description" content="We could belong togeter, ARTPOP .">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ennis -Little Monster">
<meta name="twitter:description" content="We could belong togeter, ARTPOP .">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Ennis -Little Monster</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ennis -Little Monster</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ARTPOP = artistic revolution through the potential of pop</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            所有
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/笔记-深入拆解Java虚拟机-02Java的基本类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/笔记-深入拆解Java虚拟机-02Java的基本类型/" itemprop="url">笔记-深入拆解Java虚拟机-02Java的基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T14:46:02+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。</p>
<p>Java 则不同，它引进了<strong>八个基本类型</strong>，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用<strong>基本类型能够在执行效率以及内存使用两方面提升软件性能</strong>。</p>
<h1 id="Java虚拟机的-boolean类型"><a href="#Java虚拟机的-boolean类型" class="headerlink" title="Java虚拟机的 boolean类型"></a>Java虚拟机的 boolean类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> 吃过饭没 = <span class="number">2</span>; <span class="comment">// 直接编译的话 javac 会报错</span></span><br><span class="line">		<span class="keyword">if</span> (吃过饭没) </span><br><span class="line">			System.out.println(<span class="string">" 吃了 "</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">true</span> == 吃过饭没) </span><br><span class="line">			System.out.println(<span class="string">" 真吃了 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范中，boolean类型的值只有两种，用“true”和“false”表示。</p>
<p><strong>Java虚拟机规范中，boolean类型被映射成int类型，“true”映射为整数1，“false”映射为整数0。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Foo.main 编译后的字节码</span><br><span class="line"> 0: iconst_2       // 我们用 AsmTools 更改了这一指令</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: ifeq 14        // 第一个 if 语句，即操作数栈上数值为 0 时跳转</span><br><span class="line"> 6: getstatic java.lang.System.out</span><br><span class="line"> 9: ldc &quot; 吃了 &quot;</span><br><span class="line">11: invokevirtual java.io.PrintStream.println</span><br><span class="line">14: iload_1</span><br><span class="line">15: iconst_1</span><br><span class="line">16: if_icmpne 27   // 第二个 if 语句，即操作数栈上两个数值不相同时跳转</span><br><span class="line">19: getstatic java.lang.System.out</span><br><span class="line">22: ldc &quot; 真吃了 &quot;</span><br><span class="line">24: invokevirtual java.io.PrintStream.println</span><br><span class="line">27: return</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。  </p>
<p>而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。  </p>
<h1 id="Java的基本类型"><a href="#Java的基本类型" class="headerlink" title="Java的基本类型"></a>Java的基本类型</h1><p><img src="../images/Java基本数据类型.png" alt="image"></p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p><strong>在内存中，默认值都是0。</strong></p>
<h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h2><ul>
<li>boolean和char是唯二的无符号类型。</li>
<li>boolean类型的取值范围是0或1。</li>
<li>char类型的取值范围是[0, 65535]。</li>
</ul>
<p>boolean, byte, char, short的<strong>局部变量储存可以超过取值范围</strong>。</p>
<p><strong>正常使用Java编译器的情况下，生成的字节码会遵守Java虚拟机规范对编译器的约束。</strong></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数类型采用IEEE 754 浮点数格式。</p>
<p>以float为例，<strong>浮点类型通常有两个0，+0.0F 和 -0.0F</strong>。</p>
<p>在Java里，前者为0，后者符号位为1，其他位为0。</p>
<p>虽然内存数值不同，但 +0.0F == -0.0F 会返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = +<span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> b = -<span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> c = Float.intBitsToFloat(<span class="number">0x80000000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>在内存中，正无穷等于0x7F800000，负无穷等于0xFF800000。</strong></p>
<p><strong>[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应NaN （Not-a-Number）。</strong></p>
<p>一般我们计算得出的NaN（+0.0F/+0.0F），在内存中为0x7FC00000。</p>
<p>这个数值称为标准的NaN，其他的称为不标准的NaN。</p>
<p><strong>NaN有一个特性：“!=” 始终返回true，其他比较结果都回返回false。</strong></p>
<h1 id="Java基本类型的大小"><a href="#Java基本类型的大小" class="headerlink" title="Java基本类型的大小"></a>Java基本类型的大小</h1><p>Java虚拟机没调用一个Java方法，便会创建一个栈帧，这里<strong>只讨论供解释器使用的解释栈帧（interpreted frame）</strong>。</p>
<h2 id="解释栈帧"><a href="#解释栈帧" class="headerlink" title="解释栈帧"></a>解释栈帧</h2><p>这种栈帧有两个主要组成部分：广义的局部变量区，字节码的操作栈。</p>
<p>广义局部变量包含：普遍意义的局部变量，this指针，方法参数。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在Java虚拟机规范中，<strong>局部变量区等价于一个数组</strong>。除了long、double的值用两个数组单元存储，其他基本类型以及引用类型的值均占用一个数组单元。</p>
<p><strong>boolean、byte、char、short在栈上占用的空间和int、引用类型一样。</strong>32位HotSpot中占用4字节，64位HotSport中，占用8字节。这种情况<strong>仅存在于局部变量，不会出现在存储于堆中的字段或数组元素</strong>。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><strong>将int类型的值存到其他类型的字段或数组时，相当于做了一次隐式的掩码操作。</strong></p>
<p>把0xFFFFFFFF(-1)储存到一个声明为char类型的字段里时，高两位字节被截取掉，存入“\uFFFF”。</p>
<p>HotSpot在<strong>存储boolean时显示进行掩码操作</strong>，只取最后一位的值存入boolean字段或数组中。</p>
<p>HotSpot中boolean字段占用一字节，boolean数组直接用byte数组实现。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>Java虚拟机的算数运算几乎全部依赖于操作数栈，堆中的boolean、byte、char和short加载到操作数栈上，当成int类型运算。</p>
<p>对于boolean、char这两个无符号类型，加载伴随零扩展。</p>
<p>对于byte、short加载伴随符号扩展。</p>
<h1 id="将boolean类型的值存入字段中时，Java-虚拟机所做的掩码操作"><a href="#将boolean类型的值存入字段中时，Java-虚拟机所做的掩码操作" class="headerlink" title="将boolean类型的值存入字段中时，Java 虚拟机所做的掩码操作"></a>将boolean类型的值存入字段中时，Java 虚拟机所做的掩码操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">boolean</span> boolValue;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		boolValue = <span class="keyword">true</span>; <span class="comment">// 将这个 true 替换为 2 或者 3，再看看打印结果</span></span><br><span class="line">		<span class="keyword">if</span> (boolValue) </span><br><span class="line">			System.out.println(<span class="string">"Hello, Java!"</span>);</span><br><span class="line">		<span class="keyword">if</span> (boolValue == <span class="keyword">true</span>) </span><br><span class="line">			System.out.println(<span class="string">"Hello, JVM!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当替换为2的时候无输出</strong><br><strong>当替换为3的时候打印HelloJava及HelloJVM</strong><br>因为将boolean 保存在静态域中,指定了其类型为’Z’,当修改为2时取低位最后一位为0,当修改为3时取低位最后一位为1<br>则说明boolean的掩码处理是取低位的最后一位</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：“也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。”</p>
<p>但是我记得boolean在内存中占1字节，char占2字节，这里是什么个意思？</p>
<p>A：你说的是在堆里的情况。在解释器栈上是不一样的。至于原因吗，主要是<strong>变长数组不好控制</strong>，所以就选择浪费一些空间，以便访问时直接通过下标来计算地址。</p>
<hr>
<p>Q：使用基本类型能够在执行效率以及内存使用两方面提升软件性能。具体是什么原理呢？</p>
<p>A：<strong>占的空间更小，不需要类型转换</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://time.geekbang.org/column/article/11503" target="_blank" rel="noopener">https://time.geekbang.org/column/article/11503</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/27/笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？/" itemprop="url">笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T15:04:15+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么Java要在虚拟机里运行？"><a href="#为什么Java要在虚拟机里运行？" class="headerlink" title="为什么Java要在虚拟机里运行？"></a>为什么Java要在虚拟机里运行？</h1><ol>
<li>Java作为一门高级程序语言，<strong>语法复杂，抽象程度高</strong>，直接在硬件上运行这种复杂的程序不现实。</li>
<li>Java虚拟机既可以硬件实现也可以软件实现，常见平台上都是软件实现，意义：“<strong>一次编写，到处运行</strong>”。</li>
<li>虚拟机<strong>提供了托管环境</strong>。能代替我们处理一些代码中冗长而且容易出错的部分。如：自动内存管理，垃圾回收，提供如数组越界、动态类型、安全权限等的动态检测。</li>
</ol>
<h1 id="Java虚拟机具体怎样运行Java字节码的？"><a href="#Java虚拟机具体怎样运行Java字节码的？" class="headerlink" title="Java虚拟机具体怎样运行Java字节码的？"></a>Java虚拟机具体怎样运行Java字节码的？</h1><p>下面以标准JDK中的HotSpot虚拟机为例。</p>
<p>Java虚拟机会在<strong>内存中划分出堆（stack）、栈（heap）和方法区（method）</strong></p>
<p>其中<strong>栈</strong>细分为：</p>
<ol>
<li>面向Java方法的<strong>Java方法栈</strong></li>
<li>面向本地方法的<strong>本地方法栈</strong></li>
<li>各个线程执行位置的<strong>PC寄存器</strong></li>
</ol>
<p>class文件加载后存放于方法区，运行时执行方法区内的代码。</p>
<p><img src="../images/笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？/JVM内存划分.png" alt="image"></p>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><ul>
<li>提供所有<strong>类实例</strong>和<strong>数组对象</strong>存储区域。</li>
<li>JVM只有一个堆区(heap)被所有<strong>线程共享</strong>，堆中不存放基本类型和对象引用，只存放对象本身。</li>
</ul>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><ul>
<li>每个线程包含一个栈区，栈中只保存<strong>基础数据类型</strong>的对象和自定义对象的<strong>引用</strong>(不是对象)，对象都存放在堆区中。</li>
<li>每个栈中的数据（原始类型和对象引用）都是私有的，<strong>其他栈不能访问</strong>。</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>又叫静态区，跟堆一样，被所有的<strong>线程共享</strong>。方法区包含<strong>所有的class和static变量</strong>。</li>
<li>方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</li>
<li>运行时<strong>常量池</strong>都分配在 Java 虚拟机的方法区之中。</li>
</ul>
<h2 id="Java方法调用过程"><a href="#Java方法调用过程" class="headerlink" title="Java方法调用过程"></a>Java方法调用过程</h2><ul>
<li><p>进入一个Java方法，在当前线程的Java方法栈中生成一个栈帧。<br>栈帧的大小提前计算好。<br>存放局部变量和字节码的操作数。<br>不要求栈帧在内存中连续分布。</p>
</li>
<li><p>退出方法（正常或异常），弹出当前线程的当前栈帧，并舍弃。</p>
</li>
</ul>
<p>Java字节码无法直接执行，要翻译成机器码。</p>
<h2 id="HotSpot翻译字节码的两种形式"><a href="#HotSpot翻译字节码的两种形式" class="headerlink" title="HotSpot翻译字节码的两种形式"></a>HotSpot翻译字节码的两种形式</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>逐条将字节码翻译成机器码并执行。<br>无需等待编译。</p>
<h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><p>Just-In-Time compilation, JIT<br>将方法中包含的所有字节码编译成机器码后再执行。<br>实际运行速度更快。</p>
<p><img src="../images/笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？/JVM执行Java代码.png" alt="image"></p>
<p>HotSpot默认采用<strong>混合模式</strong>。先解释执行，热点代码以方法为单位即时编译。</p>
<h1 id="Java虚拟机的运行效率究竟是怎样的？"><a href="#Java虚拟机的运行效率究竟是怎样的？" class="headerlink" title="Java虚拟机的运行效率究竟是怎样的？"></a>Java虚拟机的运行效率究竟是怎样的？</h1><p><strong>即时编译</strong>建立再程序符合<strong>二八定律</strong>的假设上。</p>
<p>HotSpot内置了多个即时编译器：C1、C2和Graal。</p>
<h2 id="Graal"><a href="#Graal" class="headerlink" title="Graal"></a>Graal</h2><p>Java 10正式引入的实验性编译器。</p>
<h2 id="C1（Client编译器）"><a href="#C1（Client编译器）" class="headerlink" title="C1（Client编译器）"></a>C1（Client编译器）</h2><ul>
<li>面向客户端GUI程序。</li>
<li>对启动性能有要求。</li>
<li>优化手段相对简单。</li>
<li>编译时间短。</li>
</ul>
<h2 id="C2（Server编译器）"><a href="#C2（Server编译器）" class="headerlink" title="C2（Server编译器）"></a>C2（Server编译器）</h2><ul>
<li>面向服务端程序。</li>
<li>对峰值性能有要求。</li>
<li>优化手段相对复杂。</li>
<li>编译时间较长。</li>
<li>生成代码执行效率较高。</li>
</ul>
<p>Java 7 开始，HotSpot默认采用<strong>分层编译</strong>：</p>
<ul>
<li>热点方法被C1编译。</li>
<li>热点方法中的热点进一步被C2编译。</li>
</ul>
<p>HotSpot的即时编译放在额外的<strong>编译线程</strong>中。<br>HotSpot根据CPU数量设置编译线程数目。<br>1:2的比例配置C1和C2。</p>
<p>资源充足的情况下，<strong>解释执行和即时编译可同行进行</strong>。</p>
<h1 id="Java-语言和-Java-虚拟机看待-boolean-类型的方式是否不同？"><a href="#Java-语言和-Java-虚拟机看待-boolean-类型的方式是否不同？" class="headerlink" title="Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同？"></a>Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同？</h1><p>$ echo ‘<br>public class Foo {<br> public static void main(String[] args) {<br>  boolean flag = true;<br>  if (flag) System.out.println(“Hello, Java!”);<br>  if (flag == true) System.out.println(“Hello, JVM!”);<br> }<br>}’ &gt; Foo.java<br>$ javac Foo.java<br>$ java Foo<br>$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1<br>$ awk ‘NR==1,/iconst_1/{sub(/iconst_1/, “iconst_2”)} 1’ Foo.jasm.1 &gt; Foo.jasm<br>$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm<br>$ java Foo</p>
<p><strong>JVM把boolean当做int来处理</strong><br>flag = iconst_1 = true<br>awk把stackframe中的flag改为iconst_2<br>if（flag）比较时ifeq指令做是否为零判断，常数2仍为true，打印输出<br>if（true == flag）比较时if_cmpne做整数比较，iconst_1是否等于flag，比较失败，不再打印输出</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：对于服务端，很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。<strong>为什么不把java代码全部编译成机器码</strong>？如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益。</p>
<p>A：对于这种发布频率不频繁(也就是长时间运行吧？)的程序，其实选择线下编译和即时编译都一样，因为至多一两个小时后该即时编译的都已经编译完成了。另外，<strong>即时编译器因为有程序的运行时信息，优化效果更好，也就是说峰值性能更好</strong>。</p>
<p>A：解释执行，执行时才翻译成机器指令，无需保存不占内存。但即时编译类似预编译，<strong>编译之后的指令需要保存在内存中，这种方式吃内存</strong>，按照二八原则这种混合模式最恰当的，热点代码编译之后放入内存避免重复编译，而其他运行次数较少代码则解释执行，避免占用过多内存。</p>
<hr>
<p>Q：什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？</p>
<p>A：JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)<br>默认的分层编译应该是达到两千调C1，达到一万五调C2。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://time.geekbang.org/column/article/11289" target="_blank" rel="noopener">https://time.geekbang.org/column/article/11289</a><br><a href="https://blog.csdn.net/zly921112/article/details/61192747" target="_blank" rel="noopener">https://blog.csdn.net/zly921112/article/details/61192747</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/23/Android架构——Clean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/23/Android架构——Clean/" itemprop="url">Android架构——Clean</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-23T11:16:49+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Clean架构的主要特点："><a href="#Clean架构的主要特点：" class="headerlink" title="Clean架构的主要特点："></a>Clean架构的主要特点：</h1><ul>
<li>框架独立</li>
<li>容易测试</li>
<li>UI独立</li>
<li>数据库独立</li>
<li>不依赖任何中介</li>
</ul>
<p>Clean的主要思想是外层依赖内层，<strong>内层完全不依赖外层</strong>（或者说内层不知道外层的存在，可以独立开发，复用性强）。</p>
<h1 id="Clean架构解析"><a href="#Clean架构解析" class="headerlink" title="Clean架构解析"></a>Clean架构解析</h1><p><img src="../images/Android架构——Clean/CleanArchitecture-c.jpg" alt="image"></p>
<ul>
<li>Enterprise Business Rules：业务对象</li>
<li>Application Business Rules：用于处理我们的业务对象，业务逻辑所在，也称为Interactor</li>
<li>Interface Adapters： 接口转换，拿到我们需要的数据，主持者层（Presenters）和控制层（Controllers）就在这一层</li>
<li>Frameworks and Drivers: 这里是所有具体的实现了：比如：UI，工具类，基础框架等等。</li>
</ul>
<p>Clean框架不一定只有4层，这里以4层为例。<br>上面可能比较抽象，下面是简单的说法：</p>
<ul>
<li>第一层：实体类</li>
<li>第二层：也叫UseCase层，实现具体业务逻辑。</li>
<li>第三层：如果是MVP这一层为Presenter，MVC这一层为Controller。</li>
<li>第四层：具体实现。</li>
</ul>
<p><img src="../images/Android架构——Clean/CleanSimple" alt="image"></p>
<ol>
<li><strong>内层均为纯Java代码</strong>，只需要jvm便可以运行。</li>
<li>内层代码不仅可以在Android平台，还可以在别的Java平台复用。</li>
<li>各层单独测试，各层之间通过接口通信，且独立，方便单元测试。</li>
<li><strong>层与层之间完全隔离</strong>，最主要的体现就是<strong>各层有自己的数据结构</strong>，不同层之间相互转换，完全没有依赖关系。</li>
<li>通过依赖注入的方式导致灵活修改逻辑、实现，这点与MVP的思想相似，Clean与MVP和Dagger结合使用是天然合适的。</li>
</ol>
<p>以mvp-clean为例，与纯mvp最主要的区别就是Presenter层剥离出UserCase层，一是方便测试，二是方便代码复用，减少Presenter层的代码冗余。</p>
<h1 id="Google-Demo-——-todo-mvp-clean-解析"><a href="#Google-Demo-——-todo-mvp-clean-解析" class="headerlink" title="Google Demo —— todo-mvp-clean 解析"></a>Google Demo —— todo-mvp-clean 解析</h1><blockquote>
<p>demo地址：<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/</a><br>mvp-clean基于mvp，加了 domain layer 介于 presentation 和 repositories。同时也将整个app 分为三个层次处理。</p>
</blockquote>
<h2 id="mvp-clean层次图"><a href="#mvp-clean层次图" class="headerlink" title="mvp-clean层次图"></a>mvp-clean层次图</h2><p><img src="../images/Android架构——Clean/mvp-clean.png" alt="image"></p>
<ul>
<li>Presentation层 : MVP 设计准则。</li>
<li>Domain层 : 处理所有的业务逻辑，注意是所有的业务逻辑。对应use case（interactors）。</li>
<li>Data层 : 获取数据，以及数据的存储，分为本地和远程。</li>
</ul>
<h2 id="基本概念（摘自mvp-clean-GitHub主页部分原文翻译）"><a href="#基本概念（摘自mvp-clean-GitHub主页部分原文翻译）" class="headerlink" title="基本概念（摘自mvp-clean GitHub主页部分原文翻译）"></a>基本概念（摘自mvp-clean GitHub主页部分原文翻译）</h2><ul>
<li>mvp-clean 和 基本的mvp 最大的区别就是在domain层和UseCase 的使用上。从 presenter 层分离出domain 层好处是可以减少代码的冗余。</li>
<li><strong>UseCase 的好处是在domain的代码层上可以复用。</strong>CompleteTask在TaskDetailPresenter和TasksPresenter做到了很好的复用。</li>
<li>domain layer 是完全解耦与Android 层和第三方依赖的。是一个纯java层的处理。</li>
<li><strong>UseCase 从主线程剥离出来</strong>，对于Android app是个好的操作。这种操作是尽可能的减少占用UI 线程。我们决定使用 command pattern 将use case 在线程池里执行操作。同样的我们可以用RxJava 或者 Promises实现同样的功能。</li>
<li>我们使用异步的repositories 。 但是现在没有必要这么做了。因为UseCase 已经从主线程里剥离出来了。这是尽量保持 samples 和原来的是一致的。</li>
</ul>
<h2 id="项目主要关系图"><a href="#项目主要关系图" class="headerlink" title="项目主要关系图"></a>项目主要关系图</h2><p><img src="../images/Android架构——Clean/mvpcleanproject.png" alt="image"></p>
<h2 id="具体用例流程"><a href="#具体用例流程" class="headerlink" title="具体用例流程"></a>具体用例流程</h2><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>纯MVP架构会使项目变得复杂，Clean架构则会更复杂，大项目可以使项目的结构清晰，内层复用性强，便于测试。<br>小项目则会使项目过于复杂，反而使项目结构显得不清晰，就像MVVM不适合小型项目一样。MVP作为万金油可以说适合大部分项目，我个人的思考是小型项目使用MVP架构，但在MVP的基础上加入部分Clean的思想。</p>
<ol>
<li>从Presenter层分离出UseCase层，方便代码复用</li>
<li>各层独立，这里有一点需要注意，Clean中各层有各层的数据结构，在实际项目中各层可能写出类似的实体类，这里可以考虑只写一个通用实体类的作为最内层，虽然违背了Clean各层完全独立的思想，但是可以减少部分冗余，这一点根据自己项目来缺点。</li>
</ol>
<blockquote>
<p>参考资料</p>
<ul>
<li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</a></li>
<li><a href="https://www.jianshu.com/p/c6a1a5c9a49b" target="_blank" rel="noopener">https://www.jianshu.com/p/c6a1a5c9a49b</a></li>
<li><a href="https://blog.csdn.net/YANGDAHUAN/article/details/80388849" target="_blank" rel="noopener">https://blog.csdn.net/YANGDAHUAN/article/details/80388849</a></li>
<li><a href="https://www.jianshu.com/p/552c3a1c5fe5" target="_blank" rel="noopener">https://www.jianshu.com/p/552c3a1c5fe5</a></li>
<li><a href="https://www.jianshu.com/p/e0258ce7d392" target="_blank" rel="noopener">https://www.jianshu.com/p/e0258ce7d392</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/阅读列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/阅读列表/" itemprop="url">阅读列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T10:24:57+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h1><p>一步步带你深入了解神秘的Java反射机制<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825931&amp;idx=1&amp;sn=b61ed2ad2665cbc3a89351b161223769&amp;chksm=80b7b055b7c03943f10f1e8b3697d3d33bbfc98d38e40c9ecbc6a3ab34f700a065858f8c8ce9&amp;mpshare=1&amp;scene=24&amp;srcid=0725l7efM9uiVCnqubGXAtBc#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825931&amp;idx=1&amp;sn=b61ed2ad2665cbc3a89351b161223769&amp;chksm=80b7b055b7c03943f10f1e8b3697d3d33bbfc98d38e40c9ecbc6a3ab34f700a065858f8c8ce9&amp;mpshare=1&amp;scene=24&amp;srcid=0725l7efM9uiVCnqubGXAtBc#rd</a></p>
<p>我的杭州面试之旅<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825928&amp;idx=1&amp;sn=4891b8969e387223f8a17ff292788ed1&amp;chksm=80b7b056b7c03940eb1325c724fec6f95d047c70c220701d97c2f4ad15113956877a2f6af991&amp;mpshare=1&amp;scene=24&amp;srcid=07258CGkMQ9yVZgQUVQCmLM3#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825928&amp;idx=1&amp;sn=4891b8969e387223f8a17ff292788ed1&amp;chksm=80b7b056b7c03940eb1325c724fec6f95d047c70c220701d97c2f4ad15113956877a2f6af991&amp;mpshare=1&amp;scene=24&amp;srcid=07258CGkMQ9yVZgQUVQCmLM3#rd</a></p>
<h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><p>Android View的工作流程<br><a href="https://mp.weixin.qq.com/s/3Av9dEuXkZsBLA0X295qYw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Av9dEuXkZsBLA0X295qYw</a></p>
<p>基于Android 8.0的源码分析(View的绘制流程)<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243397&amp;idx=1&amp;sn=e50ac7703832f723922c1fd4b2f733d0&amp;chksm=8863702abf14f93c5a672ef8083b413b2abcb77a29c2ffc24198c43d78bd62c98e902dc438d4&amp;mpshare=1&amp;scene=24&amp;srcid=0703olc6EjioraMbYZsZbGwz#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243397&amp;idx=1&amp;sn=e50ac7703832f723922c1fd4b2f733d0&amp;chksm=8863702abf14f93c5a672ef8083b413b2abcb77a29c2ffc24198c43d78bd62c98e902dc438d4&amp;mpshare=1&amp;scene=24&amp;srcid=0703olc6EjioraMbYZsZbGwz#rd</a></p>
<p>自定义View之跑马灯效果<br><a href="https://mp.weixin.qq.com/s/9FGix16HMd_YeBM2KMNGyg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9FGix16HMd_YeBM2KMNGyg</a></p>
<p>一步步分析知乎中CoordinatorLayout的实现<br><a href="https://mp.weixin.qq.com/s/Kbv8e61L6i2N8JxHJo0lLA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Kbv8e61L6i2N8JxHJo0lLA</a></p>
<p>Android中的缓存艺术，对比RecyclerView与ListView的缓存机制<br><a href="https://mp.weixin.qq.com/s/LAm4m9klItuQpr4Sd2_mvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LAm4m9klItuQpr4Sd2_mvQ</a></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>你不能错过的View事件分发机制分析<br><a href="https://mp.weixin.qq.com/s/-dS1M0eFKJEAA-7viMi8Vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-dS1M0eFKJEAA-7viMi8Vw</a></p>
<p>Android View事件体系全面总结+实践分析<br><a href="https://mp.weixin.qq.com/s/rcUXiA4FXrdMYQYYEOJFiw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rcUXiA4FXrdMYQYYEOJFiw</a></p>
<p>触摸事件实践之路<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242914&amp;idx=1&amp;sn=87e0e66951a9c102053cab8551916dd9&amp;chksm=88638e0dbf14071b9ed1a8d0c935f0b0c66c96c348f667117d88cf4c29a13b8bed1e77c2f239&amp;mpshare=1&amp;scene=24&amp;srcid=0502B3zbXNFpp1bZsYoAWfoe#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242914&amp;idx=1&amp;sn=87e0e66951a9c102053cab8551916dd9&amp;chksm=88638e0dbf14071b9ed1a8d0c935f0b0c66c96c348f667117d88cf4c29a13b8bed1e77c2f239&amp;mpshare=1&amp;scene=24&amp;srcid=0502B3zbXNFpp1bZsYoAWfoe#rd</a></p>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>自定义View之文字路径动画控件<br><a href="https://mp.weixin.qq.com/s/dnN9z1KFHaIxJgHiqTMyLA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dnN9z1KFHaIxJgHiqTMyLA</a></p>
<p>用四行代码来实现复杂动画<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046285&amp;idx=1&amp;sn=77dddbfea05c61e47303fd4bfb827e37&amp;chksm=808ca388b7fb2a9e0c4f1d1c2dc902b7f4b5b6a200962b9d8e2adc685ff6277182740dc498f7&amp;mpshare=1&amp;scene=24&amp;srcid=0522zyEQobtWO0046vI79vkE#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046285&amp;idx=1&amp;sn=77dddbfea05c61e47303fd4bfb827e37&amp;chksm=808ca388b7fb2a9e0c4f1d1c2dc902b7f4b5b6a200962b9d8e2adc685ff6277182740dc498f7&amp;mpshare=1&amp;scene=24&amp;srcid=0522zyEQobtWO0046vI79vkE#rd</a></p>
<p>Android自定义之圆弧滑动效果<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243493&amp;idx=1&amp;sn=96aeeb99d5e465c9f6583752d809ba94&amp;chksm=886370cabf14f9dcc9569c36001a4b0329d2e5707dd5a2647cf982e227922b507603c133677d&amp;mpshare=1&amp;scene=24&amp;srcid=0711HED57GdKGlqmV2Qv21WE#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243493&amp;idx=1&amp;sn=96aeeb99d5e465c9f6583752d809ba94&amp;chksm=886370cabf14f9dcc9569c36001a4b0329d2e5707dd5a2647cf982e227922b507603c133677d&amp;mpshare=1&amp;scene=24&amp;srcid=0711HED57GdKGlqmV2Qv21WE#rd</a></p>
<p>Android实现圆弧滑动效果之FanLayout篇<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243582&amp;idx=1&amp;sn=bb8d0a8f850cc0de91b4bfc420cdcc59&amp;chksm=88637091bf14f9876b09f319772668d5969806d06c4c600c81f54c2819c4827b173b752869ff&amp;mpshare=1&amp;scene=24&amp;srcid=07186BypWWdDu8Ypp0xjJVzH#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243582&amp;idx=1&amp;sn=bb8d0a8f850cc0de91b4bfc420cdcc59&amp;chksm=88637091bf14f9876b09f319772668d5969806d06c4c600c81f54c2819c4827b173b752869ff&amp;mpshare=1&amp;scene=24&amp;srcid=07186BypWWdDu8Ypp0xjJVzH#rd</a></p>
<p>仿炫酷头条小视频拖拽动画<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243546&amp;idx=1&amp;sn=0b4e2723558fc5e584c43c44b0eb8350&amp;chksm=886370b5bf14f9a3cdd4f9e8dd42a8ded97ba649223ef17f913de182396561d0bbee84428b67&amp;mpshare=1&amp;scene=24&amp;srcid=0717urmJU7gbjIYORkMuvmmm#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243546&amp;idx=1&amp;sn=0b4e2723558fc5e584c43c44b0eb8350&amp;chksm=886370b5bf14f9a3cdd4f9e8dd42a8ded97ba649223ef17f913de182396561d0bbee84428b67&amp;mpshare=1&amp;scene=24&amp;srcid=0717urmJU7gbjIYORkMuvmmm#rd</a></p>
<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p>【大揭秘】Android架构组件ViewModel来龙去脉<br><a href="https://mp.weixin.qq.com/s?srcid=0415o7Ok7xyv7c2KeH53uhCH&amp;scene=23&amp;mid=2247484312&amp;sn=aecdd31dd8d4edf8f43ad9f174b6cc98&amp;idx=1&amp;__biz=MzIxMTg5NjQyMA%3D%3D&amp;chksm=974f1293a0389b85cb6b15090ed12ea37ce43a0840739076a9d5a08e051961684105089262d2&amp;mpshare=1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?srcid=0415o7Ok7xyv7c2KeH53uhCH&amp;scene=23&amp;mid=2247484312&amp;sn=aecdd31dd8d4edf8f43ad9f174b6cc98&amp;idx=1&amp;__biz=MzIxMTg5NjQyMA%3D%3D&amp;chksm=974f1293a0389b85cb6b15090ed12ea37ce43a0840739076a9d5a08e051961684105089262d2&amp;mpshare=1#rd</a></p>
<p>【Android】Fragment懒加载和ViewPager的坑<br><a href="https://www.cnblogs.com/dasusu/p/5926731.html" target="_blank" rel="noopener">https://www.cnblogs.com/dasusu/p/5926731.html</a></p>
<p>一起来学习Android 8.0系统的通知栏适配吧<br><a href="https://mp.weixin.qq.com/s/Ez-G_9hzUCOjU8rRnsW8SA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ez-G_9hzUCOjU8rRnsW8SA</a></p>
<p>轻松掌握Notification的各种用法<br><a href="https://mp.weixin.qq.com/s/2TaWICQ4nWV3TuPG71CBGw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2TaWICQ4nWV3TuPG71CBGw</a></p>
<p>探讨View、Window和Activity的关系<br><a href="https://mp.weixin.qq.com/s/wNdRSs-U05LLK_ZT2p2SFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wNdRSs-U05LLK_ZT2p2SFg</a></p>
<p>教你编写一个手势解锁控件<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243035&amp;idx=1&amp;sn=b7cb92927bfe3148b8936b5786f3a751&amp;chksm=88638eb4bf1407a2f89cbb68def8ab4068c5899b18ad1d34a36f3677493d0f7039e4bd40461a&amp;mpshare=1&amp;scene=24&amp;srcid=0517qRwLJ7QlBW0xAJHO3PEc#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243035&amp;idx=1&amp;sn=b7cb92927bfe3148b8936b5786f3a751&amp;chksm=88638eb4bf1407a2f89cbb68def8ab4068c5899b18ad1d34a36f3677493d0f7039e4bd40461a&amp;mpshare=1&amp;scene=24&amp;srcid=0517qRwLJ7QlBW0xAJHO3PEc#rd</a></p>
<p>从零实现灵活且可高度定制的Android图片选择架构<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243083&amp;idx=1&amp;sn=3ff3429479489791c32dc385b516ad1c&amp;chksm=88637164bf14f8727775e4156d2b2de565342e87ff1a44f4047b76410b3fdbe059b85516d968&amp;mpshare=1&amp;scene=24&amp;srcid=0524S5VFqz4WOw5TxDKotk0V#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243083&amp;idx=1&amp;sn=3ff3429479489791c32dc385b516ad1c&amp;chksm=88637164bf14f8727775e4156d2b2de565342e87ff1a44f4047b76410b3fdbe059b85516d968&amp;mpshare=1&amp;scene=24&amp;srcid=0524S5VFqz4WOw5TxDKotk0V#rd</a></p>
<p>Activity生命周期回调是如何被回调的？<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825792&amp;idx=1&amp;sn=27600bd57a33a8e4d3c1e02fdc49fe7a&amp;chksm=80b7b0deb7c039c8697fbfd64160f62ec9e2c289baaf1c4f1bbfb602c502831c0595f8f8b00d&amp;mpshare=1&amp;scene=24&amp;srcid=0713tEiQ6WuvMGukrMm0lCr4#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825792&amp;idx=1&amp;sn=27600bd57a33a8e4d3c1e02fdc49fe7a&amp;chksm=80b7b0deb7c039c8697fbfd64160f62ec9e2c289baaf1c4f1bbfb602c502831c0595f8f8b00d&amp;mpshare=1&amp;scene=24&amp;srcid=0713tEiQ6WuvMGukrMm0lCr4#rd</a></p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>APT注解处理器，让你的代码变得更简单<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242955&amp;idx=1&amp;sn=11040755b0df385c5d1facccfc21e107&amp;chksm=88638ee4bf1407f23bb123e61d01e5a454223ce91c05e99a84ee38e9c6a870757d020b1f9f87&amp;mpshare=1&amp;scene=24&amp;srcid=0509tcRd99aWsM0iK0wrrKB8#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242955&amp;idx=1&amp;sn=11040755b0df385c5d1facccfc21e107&amp;chksm=88638ee4bf1407f23bb123e61d01e5a454223ce91c05e99a84ee38e9c6a870757d020b1f9f87&amp;mpshare=1&amp;scene=24&amp;srcid=0509tcRd99aWsM0iK0wrrKB8#rd</a></p>
<p>在Android中优雅地使用注解<br><a href="https://mp.weixin.qq.com/s/fJKAwpqn_hXRXRS4oh1dEw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fJKAwpqn_hXRXRS4oh1dEw</a></p>
<p>轻松打造一个自己的注解框架<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243038&amp;idx=1&amp;sn=b7bf615ba652ace8623e826926f24ea1&amp;chksm=88638eb1bf1407a71153101a2eb5a6d478fd1fbf129aac9f6c9b29af0084aed9c6c7ede15762&amp;mpshare=1&amp;scene=24&amp;srcid=0518u6VLLt7hWdoWG1ipnmtZ#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243038&amp;idx=1&amp;sn=b7bf615ba652ace8623e826926f24ea1&amp;chksm=88638eb1bf1407a71153101a2eb5a6d478fd1fbf129aac9f6c9b29af0084aed9c6c7ede15762&amp;mpshare=1&amp;scene=24&amp;srcid=0518u6VLLt7hWdoWG1ipnmtZ#rd</a></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>大众点评App的短视频耗电量优化实战<br><a href="https://juejin.im/entry/5aa629846fb9a028d566c183" target="_blank" rel="noopener">https://juejin.im/entry/5aa629846fb9a028d566c183</a></p>
<p>Android 优化二 Java内存分配机制及内存泄漏<br><a href="https://www.jianshu.com/p/85f49e1ff813" target="_blank" rel="noopener">https://www.jianshu.com/p/85f49e1ff813</a></p>
<p>Android内存泄漏总结<br><a href="https://mp.weixin.qq.com/s/Ncm0JVc_j0WVWKHR-BxkyQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ncm0JVc_j0WVWKHR-BxkyQ</a></p>
<p>实践App内存优化：如何有序地做内存分析与优化<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825714&amp;idx=1&amp;sn=bc44930c20143c3d5228575a7c20f14f&amp;chksm=80b7b76cb7c03e7a3698839d9fb79a65e372a06b7a51e168d857951fd325266ca5498d239aac&amp;mpshare=1&amp;scene=24&amp;srcid=0628o26uR6HAi0crmOZAquQj#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825714&amp;idx=1&amp;sn=bc44930c20143c3d5228575a7c20f14f&amp;chksm=80b7b76cb7c03e7a3698839d9fb79a65e372a06b7a51e168d857951fd325266ca5498d239aac&amp;mpshare=1&amp;scene=24&amp;srcid=0628o26uR6HAi0crmOZAquQj#rd</a></p>
<p>如何排查列表卡顿问题 | 性能优化技巧知识梳理<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825772&amp;idx=1&amp;sn=09a75adf73449891931c80692cd2fb43&amp;chksm=80b7b0b2b7c039a44eb862c0096eaa8c7935e7764d4d388f9854a288389a2adcf58e3b8dbf93&amp;mpshare=1&amp;scene=24&amp;srcid=0710sC48tyjZT5rRHd6NwzKG#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825772&amp;idx=1&amp;sn=09a75adf73449891931c80692cd2fb43&amp;chksm=80b7b0b2b7c039a44eb862c0096eaa8c7935e7764d4d388f9854a288389a2adcf58e3b8dbf93&amp;mpshare=1&amp;scene=24&amp;srcid=0710sC48tyjZT5rRHd6NwzKG#rd</a></p>
<p>Android 性能优化最佳实践<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492955&amp;idx=1&amp;sn=fea32aad2214cd448b584b74a06f7934&amp;chksm=8eec8624b99b0f321315e8bd73665cdee6467b5801a027b36548407b7fe4c844fd92bab6040b&amp;mpshare=1&amp;scene=24&amp;srcid=0720ysEyg85pzD6YzTNM44Et#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492955&amp;idx=1&amp;sn=fea32aad2214cd448b584b74a06f7934&amp;chksm=8eec8624b99b0f321315e8bd73665cdee6467b5801a027b36548407b7fe4c844fd92bab6040b&amp;mpshare=1&amp;scene=24&amp;srcid=0720ysEyg85pzD6YzTNM44Et#rd</a></p>
<p>记一次Activity的内存泄漏和分析过程<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243606&amp;idx=1&amp;sn=5e0fbea09b650bc3a6063904742113d2&amp;chksm=88637379bf14fa6f03e4548ba016b4c5167a980863be139b3cc7c3c9f1bf454c803ac840c67a&amp;mpshare=1&amp;scene=24&amp;srcid=0725SSYypMiGbjti2E4iabde#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243606&amp;idx=1&amp;sn=5e0fbea09b650bc3a6063904742113d2&amp;chksm=88637379bf14fa6f03e4548ba016b4c5167a980863be139b3cc7c3c9f1bf454c803ac840c67a&amp;mpshare=1&amp;scene=24&amp;srcid=0725SSYypMiGbjti2E4iabde#rd</a></p>
<p>Android vitals 帮您解决应用质量问题<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046741&amp;idx=1&amp;sn=bc20065d84bf6d2d52cd4d5b563396bd&amp;chksm=808ca5d0b7fb2cc643c5852a0643b5866f1f5b96fc5e2e838b67973a98977960d102b17fd320&amp;mpshare=1&amp;scene=24&amp;srcid=0725bNa7F0qzIDGzOuURXL4k#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046741&amp;idx=1&amp;sn=bc20065d84bf6d2d52cd4d5b563396bd&amp;chksm=808ca5d0b7fb2cc643c5852a0643b5866f1f5b96fc5e2e838b67973a98977960d102b17fd320&amp;mpshare=1&amp;scene=24&amp;srcid=0725bNa7F0qzIDGzOuURXL4k#rd</a></p>
<h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>教你打造一个Android组件化开发框架<br><a href="https://mp.weixin.qq.com/s/XQktvPbytMEljebFo9B_ww" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XQktvPbytMEljebFo9B_ww</a></p>
<p>电商APP组件化探索<br><a href="https://mp.weixin.qq.com/s/hey2ZcsgucLVEGYJ2qfVWA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hey2ZcsgucLVEGYJ2qfVWA</a></p>
<p>组件化在项目中的使用姿势<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243065&amp;idx=1&amp;sn=013d54ab819fc239bb2bc0b9183e80ae&amp;chksm=88638e96bf140780dad45ee03eb65406a03d11c545969899aef5cd74189a6e402f976841bcac&amp;mpshare=1&amp;scene=24&amp;srcid=0523FW0ZQO2EHKLKwszs21mv#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243065&amp;idx=1&amp;sn=013d54ab819fc239bb2bc0b9183e80ae&amp;chksm=88638e96bf140780dad45ee03eb65406a03d11c545969899aef5cd74189a6e402f976841bcac&amp;mpshare=1&amp;scene=24&amp;srcid=0523FW0ZQO2EHKLKwszs21mv#rd</a></p>
<p>Android基于注解IOC组件化/模块化的架构实践<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243088&amp;idx=1&amp;sn=2b113144a6e9f792201b9ea505d78b52&amp;chksm=8863717fbf14f8692be8e0f00274f042d0d1291ef6bc6ba336483a8ee34a01b9bb2b6361521e&amp;mpshare=1&amp;scene=24&amp;srcid=0528sVDFTK2ZNGLLKgPSvQha#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243088&amp;idx=1&amp;sn=2b113144a6e9f792201b9ea505d78b52&amp;chksm=8863717fbf14f8692be8e0f00274f042d0d1291ef6bc6ba336483a8ee34a01b9bb2b6361521e&amp;mpshare=1&amp;scene=24&amp;srcid=0528sVDFTK2ZNGLLKgPSvQha#rd</a></p>
<p>MVPArms官方快速组件化方案开源，来自5K Star的信赖<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243120&amp;idx=1&amp;sn=5d107b487ca7c29ec74c739e9aedc868&amp;chksm=8863715fbf14f84947644451553183b70d6f31090c75e35aced0a0d44b00ca70cf584c08df57&amp;mpshare=1&amp;scene=24&amp;srcid=0530QEUdUHYk6XwCcHWCeVPe#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243120&amp;idx=1&amp;sn=5d107b487ca7c29ec74c739e9aedc868&amp;chksm=8863715fbf14f84947644451553183b70d6f31090c75e35aced0a0d44b00ca70cf584c08df57&amp;mpshare=1&amp;scene=24&amp;srcid=0530QEUdUHYk6XwCcHWCeVPe#rd</a></p>
<p>从零开始搭建Android组件化框架<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825738&amp;idx=1&amp;sn=7d94a4fd7e87199c3353e74dd817829c&amp;chksm=80b7b094b7c039827ff7157b488be08adce7328f7ad4f3bbe578651a3e9d6657a819da16b7e9&amp;mpshare=1&amp;scene=24&amp;srcid=0704GmorrhTzmnGw7RzIlssg#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825738&amp;idx=1&amp;sn=7d94a4fd7e87199c3353e74dd817829c&amp;chksm=80b7b094b7c039827ff7157b488be08adce7328f7ad4f3bbe578651a3e9d6657a819da16b7e9&amp;mpshare=1&amp;scene=24&amp;srcid=0704GmorrhTzmnGw7RzIlssg#rd</a></p>
<p>业内首个支持渐进式组件化的开源框架<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825886&amp;idx=1&amp;sn=2545efbb9268dbe2978adea3168fd1e6&amp;chksm=80b7b000b7c03916ecbd0e34fe19465540cd28dc6d1eb1d7e5f9a280bdf930720c212014bac9&amp;mpshare=1&amp;scene=24&amp;srcid=0719j97wHEKJn2ZU0R9Oi2W9#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825886&amp;idx=1&amp;sn=2545efbb9268dbe2978adea3168fd1e6&amp;chksm=80b7b000b7c03916ecbd0e34fe19465540cd28dc6d1eb1d7e5f9a280bdf930720c212014bac9&amp;mpshare=1&amp;scene=24&amp;srcid=0719j97wHEKJn2ZU0R9Oi2W9#rd</a></p>
<p>Android新组件Lifecycle详解<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243273&amp;idx=1&amp;sn=b89696c4a009638c087fbca5b6d76cd3&amp;chksm=886371a6bf14f8b0a828855055f54c7e7fa063a57dea2c2fe69b8b5d24a03aef73f450fc5af4&amp;mpshare=1&amp;scene=24&amp;srcid=0629cVz7HqAanApllVepn9iz#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243273&amp;idx=1&amp;sn=b89696c4a009638c087fbca5b6d76cd3&amp;chksm=886371a6bf14f8b0a828855055f54c7e7fa063a57dea2c2fe69b8b5d24a03aef73f450fc5af4&amp;mpshare=1&amp;scene=24&amp;srcid=0629cVz7HqAanApllVepn9iz#rd</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>APP接口开发的入门指南<br><a href="https://mp.weixin.qq.com/s/CFV5ucVdLXEoBx5r2vuCMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CFV5ucVdLXEoBx5r2vuCMw</a></p>
<p>最火视频库FFmpeg在Android上的移植封装<br><a href="https://mp.weixin.qq.com/s/Z79a-kVyN8TS2a_iuheHPg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Z79a-kVyN8TS2a_iuheHPg</a></p>
<p>详细讲解Android Studio中使用Git<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825717&amp;idx=1&amp;sn=c530dfb9cd5419aed439b71941393711&amp;chksm=80b7b76bb7c03e7dda8fb492f280aaae386ca042a2510b2faf3904e76c5695b6e32b68337a11&amp;mpshare=1&amp;scene=24&amp;srcid=0629qBHRRYAuzjtfZnxc0uTs#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825717&amp;idx=1&amp;sn=c530dfb9cd5419aed439b71941393711&amp;chksm=80b7b76bb7c03e7dda8fb492f280aaae386ca042a2510b2faf3904e76c5695b6e32b68337a11&amp;mpshare=1&amp;scene=24&amp;srcid=0629qBHRRYAuzjtfZnxc0uTs#rd</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>我所了解的Android数据库框架——DBFlow<br><a href="https://mp.weixin.qq.com/s/x4xLkbbN8o13oLGdDEAntw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/x4xLkbbN8o13oLGdDEAntw</a></p>
<p>我所了解的 DBFlow<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243177&amp;idx=1&amp;sn=542c07c55758377e7e89b94ce34734bd&amp;chksm=88637106bf14f8109145b950fa5ef46fd3c3b8437dd1444b11d8fb1810c6ef13f5275eedd960&amp;mpshare=1&amp;scene=24&amp;srcid=0608mrsN5dlSw8JbZQXPH6zP#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243177&amp;idx=1&amp;sn=542c07c55758377e7e89b94ce34734bd&amp;chksm=88637106bf14f8109145b950fa5ef46fd3c3b8437dd1444b11d8fb1810c6ef13f5275eedd960&amp;mpshare=1&amp;scene=24&amp;srcid=0608mrsN5dlSw8JbZQXPH6zP#rd</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>关于HTTPS的那些事<br><a href="https://mp.weixin.qq.com/s/E75toyRukUHEtt34-snEgQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E75toyRukUHEtt34-snEgQ</a></p>
<p>Android持久化保存cookie<br><a href="https://blog.csdn.net/shimiso/article/details/39033353" target="_blank" rel="noopener">https://blog.csdn.net/shimiso/article/details/39033353</a></p>
<p>使用OKHttp模拟登陆知乎，兼谈OKHttp中Cookie的使用！<br><a href="https://blog.csdn.net/u012702547/article/details/52156315" target="_blank" rel="noopener">https://blog.csdn.net/u012702547/article/details/52156315</a></p>
<p>Retrofit2与服务端实例讲解<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243222&amp;idx=1&amp;sn=62545983dd4d62527b64b2a28ea103fe&amp;chksm=886371f9bf14f8efc89c79d863ee0394b424901cde2f75104aed3822057da3d13cbef3eea73e&amp;mpshare=1&amp;scene=24&amp;srcid=06221gMVq1zqi4k9CVNRqoep#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243222&amp;idx=1&amp;sn=62545983dd4d62527b64b2a28ea103fe&amp;chksm=886371f9bf14f8efc89c79d863ee0394b424901cde2f75104aed3822057da3d13cbef3eea73e&amp;mpshare=1&amp;scene=24&amp;srcid=06221gMVq1zqi4k9CVNRqoep#rd</a></p>
<p>HTTP 必知必会的那些<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492918&amp;idx=1&amp;sn=40030cd46cbba2bc639602aa341f3739&amp;chksm=8eec8649b99b0f5f09aedc590901f61e1729ff03e6381a3127890381841dfcdd14af282a13fc&amp;mpshare=1&amp;scene=24&amp;srcid=07114zp2ahQQs9qXzlstH08u#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492918&amp;idx=1&amp;sn=40030cd46cbba2bc639602aa341f3739&amp;chksm=8eec8649b99b0f5f09aedc590901f61e1729ff03e6381a3127890381841dfcdd14af282a13fc&amp;mpshare=1&amp;scene=24&amp;srcid=07114zp2ahQQs9qXzlstH08u#rd</a></p>
<p>Android Gson使用详解<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243206&amp;idx=1&amp;sn=28c1d807ae3a8a5ef32c91095f264ab1&amp;chksm=886371e9bf14f8ffdd8507252315c96e371fc4f916c854bce85a178222104b1d9684e9ab4bae&amp;mpshare=1&amp;scene=24&amp;srcid=06135ehU2SGSvL4wR7nzq3EQ#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243206&amp;idx=1&amp;sn=28c1d807ae3a8a5ef32c91095f264ab1&amp;chksm=886371e9bf14f8ffdd8507252315c96e371fc4f916c854bce85a178222104b1d9684e9ab4bae&amp;mpshare=1&amp;scene=24&amp;srcid=06135ehU2SGSvL4wR7nzq3EQ#rd</a></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>浅谈Android中的MVP与动态代理<br><a href="https://mp.weixin.qq.com/s/Bktzl66Twp3jsuYLZrQPfQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Bktzl66Twp3jsuYLZrQPfQ</a></p>
<p>Java 动态代理<br><a href="http://wiki.jikexueyuan.com/project/java-reflection/java-dynamic.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-reflection/java-dynamic.html</a></p>
<p>3分钟理解android-architecture 之 todo-mvp-clean<br><a href="https://www.jianshu.com/p/e0258ce7d392" target="_blank" rel="noopener">https://www.jianshu.com/p/e0258ce7d392</a></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>Java线程池线程复用的秘密<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243061&amp;idx=1&amp;sn=89013ccef91c82edc844a57889da95ca&amp;chksm=88638e9abf14078c881dc41ab67ddd9bb41d61291ea335a474b63d99129e9133b9f857f2a863&amp;mpshare=1&amp;scene=24&amp;srcid=05227AG1S00EDsDqLiTkTG2w#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243061&amp;idx=1&amp;sn=89013ccef91c82edc844a57889da95ca&amp;chksm=88638e9abf14078c881dc41ab67ddd9bb41d61291ea335a474b63d99129e9133b9f857f2a863&amp;mpshare=1&amp;scene=24&amp;srcid=05227AG1S00EDsDqLiTkTG2w#rd</a></p>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><p>31 天，从浅到深轻松学习 Kotlin<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046391&amp;idx=1&amp;sn=46efa48076a4533f355af6351b76c012&amp;chksm=808ca472b7fb2d64afc89edf6beba1540e5a6ff49ad6346bd5d72b3957fa5f9323e07b8aab03&amp;mpshare=1&amp;scene=24&amp;srcid=0530wg2L5DyZCmcUzPoa7UNy#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046391&amp;idx=1&amp;sn=46efa48076a4533f355af6351b76c012&amp;chksm=808ca472b7fb2d64afc89edf6beba1540e5a6ff49ad6346bd5d72b3957fa5f9323e07b8aab03&amp;mpshare=1&amp;scene=24&amp;srcid=0530wg2L5DyZCmcUzPoa7UNy#rd</a></p>
<p>快速高效学习 Kotlin | Kotlin Bootcamp 课程介绍<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046397&amp;idx=1&amp;sn=4346017b0b6494beb6c7f85d127802f8&amp;chksm=808ca478b7fb2d6e93bc2521db30bdc14db4a9841fd6051030231181f35680e9120d8353b61a&amp;mpshare=1&amp;scene=24&amp;srcid=0530aGxOV6X0MBl3CLEqZdiv#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046397&amp;idx=1&amp;sn=4346017b0b6494beb6c7f85d127802f8&amp;chksm=808ca478b7fb2d6e93bc2521db30bdc14db4a9841fd6051030231181f35680e9120d8353b61a&amp;mpshare=1&amp;scene=24&amp;srcid=0530aGxOV6X0MBl3CLEqZdiv#rd</a></p>
<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><p>一篇文章带你了解Gradle插件的所有创建方式<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492683&amp;idx=1&amp;sn=834c7dd084af2d446e84a2865a5c2b9c&amp;chksm=8eec8734b99b0e221407fbf95004fd1a0abc5a2bb2a78a5a66edb1841fda6149874cbebc0295&amp;mpshare=1&amp;scene=24&amp;srcid=0530SjyhdEWapyQwXNm60pTz#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492683&amp;idx=1&amp;sn=834c7dd084af2d446e84a2865a5c2b9c&amp;chksm=8eec8734b99b0e221407fbf95004fd1a0abc5a2bb2a78a5a66edb1841fda6149874cbebc0295&amp;mpshare=1&amp;scene=24&amp;srcid=0530SjyhdEWapyQwXNm60pTz#rd</a></p>
<p>为什么我们需要掌握Gradle的这些知识？<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243271&amp;idx=1&amp;sn=60aae09cb53bebc89dad3906c83cf594&amp;chksm=886371a8bf14f8bee7d6ecad6c708608f05c0d2566d7b1683484613f6f2be599a78e76c6cb68&amp;mpshare=1&amp;scene=24&amp;srcid=0628YVAvjfmNkSeWLF6Dd5UJ#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243271&amp;idx=1&amp;sn=60aae09cb53bebc89dad3906c83cf594&amp;chksm=886371a8bf14f8bee7d6ecad6c708608f05c0d2566d7b1683484613f6f2be599a78e76c6cb68&amp;mpshare=1&amp;scene=24&amp;srcid=0628YVAvjfmNkSeWLF6Dd5UJ#rd</a></p>
<p>Android Studio项目模板全面解析<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243486&amp;idx=1&amp;sn=096cacf159eef9ff531ca4c905dfeb9b&amp;chksm=886370f1bf14f9e797b27941b9568162afd5ed90ef615b0980527d9ecd4ee9e5da653c435db0&amp;mpshare=1&amp;scene=24&amp;srcid=0710aY57WChAgUGESyATymeM#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243486&amp;idx=1&amp;sn=096cacf159eef9ff531ca4c905dfeb9b&amp;chksm=886370f1bf14f9e797b27941b9568162afd5ed90ef615b0980527d9ecd4ee9e5da653c435db0&amp;mpshare=1&amp;scene=24&amp;srcid=0710aY57WChAgUGESyATymeM#rd</a></p>
<h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><p>Android音频管理之AudioManager<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243609&amp;idx=1&amp;sn=9420ef29a0aa2bdd56c55076e686524c&amp;chksm=88637376bf14fa60b0b7e8530e88ced32f2c481161d34a907185e100f0cd42e7b6be83423ccf&amp;mpshare=1&amp;scene=24&amp;srcid=0725VfT0yIGfO8ZgczaVne9M#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243609&amp;idx=1&amp;sn=9420ef29a0aa2bdd56c55076e686524c&amp;chksm=88637376bf14fa60b0b7e8530e88ced32f2c481161d34a907185e100f0cd42e7b6be83423ccf&amp;mpshare=1&amp;scene=24&amp;srcid=0725VfT0yIGfO8ZgczaVne9M#rd</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/5种写法实现单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/5种写法实现单例模式/" itemprop="url">5种写法实现单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T09:37:52+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式在类加载时初始化。</p>
<p>优点：</p>
<ul>
<li>简单。</li>
<li>天生线程安全。</li>
</ul>
<p>缺点：</p>
<ul>
<li>初始化时机不能由开发者控制，初始化太早造成资源的浪费。</li>
<li>初始化依赖于其他数据，难以控制其他数据是否准备好。</li>
</ul>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventBus使用的方式。</p>
<p>优点：</p>
<ul>
<li>第一次使用时加载，避免了资源浪费。</li>
</ul>
<p>缺点：</p>
<ul>
<li>复杂。</li>
<li>即使是双重检查有时也会失效（可能性极低）。</li>
</ul>
<h1 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《Effective Java》第一版中推荐的写法。<br>内部类加载时初始化，内部类在第一次被调用时类加载。</p>
<p>优点：</p>
<ul>
<li>简单。</li>
<li>巧妙的利用内部类实现线程安全。</li>
</ul>
<h1 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">     INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《Effective Java》第二版中推荐的写法。</p>
<p>优点：</p>
<ul>
<li>极简。</li>
<li>线程安全。</li>
<li><strong>绝对完美单例，可以抵御反序列化、反射。</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>降低可读性。</li>
<li>无法被继承，降低扩展性。</li>
</ul>
<h1 id="容器模式"><a href="#容器模式" class="headerlink" title="容器模式"></a>容器模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用单例管理器统一管理所有单例，可以使用统一接口实现操作，这里只是写了简单的实现，没有优化获取操作，没有优化线程。</p>
<p>优点：</p>
<ul>
<li>方便统一管理。</li>
<li>降低耦合。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能及时找到获取途径，增加开发者的学习成本。</li>
<li>未得到广泛认可。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文一共提供了5种单例模式的实现，最推荐使用静态内部类的方式。饿汉式虽然简单但是容易造成资源浪费，懒汉式过于复杂，即便是双重检查版本也有可能DCL失效，枚举虽然是完美单例但是扩展性低，容器模式需要大量代码优化线程安全和获取操作并且增加了开发者的学习成本。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/dongyu666/p/6971783.html" target="_blank" rel="noopener">https://www.cnblogs.com/dongyu666/p/6971783.html</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">https://blog.csdn.net/itachi85/article/details/50510124</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/转-Java反射完全解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/转-Java反射完全解析/" itemprop="url">[转]Java反射完全解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T20:31:41+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载请注明出处：<a href="https://www.jianshu.com/p/607ff4e79a13" target="_blank" rel="noopener">https://www.jianshu.com/p/607ff4e79a13</a></p>
</blockquote>
<p>本文相关知识点大部分总结自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html" target="_blank" rel="noopener">Oracle官方文档</a>，对于英文比较好的朋友，建议直接阅读原文档。</p>
<p>按例，首先描述一下定义：</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。</p>
</blockquote>
<p>简而言之，你可以在运行状态中通过反射机制做到：</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性;</li>
</ul>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>在我看来我们平时使用 Java 反射主要涉及两个类(接口) <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">Class</a>， <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html" target="_blank" rel="noopener">Member</a>，如果把这两个类搞清楚了，反射基本就 ok 了。</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>提到反射就不得不提到 Class，Class 可以说是反射能够实现的基础；注意这里说的 Class与 class 关键字<strong>不是同一种东西</strong>。class 关键字是在声明 java 类时使用的；而 Class 是 java JDK 提供的一个类,完整路径为 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">java.lang.Class</a>，本质上与 Math, String 或者你自己定义各种类没什么区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">GenericDeclaration</span>, <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 Class 到底在反射中起到什么作用呢？</p>
<blockquote>
<p>For every type of object, the Java virtual machine instantiates an immutable instance of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">java.lang.Class</a> which provides methods to examine the runtime properties of the object including its members and type information. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">Class</a> also provides the ability to create new classes and objects. Most importantly, it is the entry point for all of the Reflection APIs.</p>
</blockquote>
<p>对于每一种类，Java 虚拟机都会初始化出一个 Class 类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应 Class 对象，并且这个 Class 对象会被保存在同名 .class 文件里。当我们 new 一个新对象或者引用静态成员变量时，Java 虚拟机(JVM)中的类加载器系统会将对应 Class 对象加载到 JVM 中，然后 JVM 再根据这个类型信息相关的Class 对象创建我们需要实例对象或者提供静态变量的引用值。</p>
<p>比如创建编译一个 Shapes 类，那么，JVM 就会创建一个 Shapes 对应 Class 类的 Class实例，该 Class 实例保存了 Shapes 类相关的类型信息，包括属性，方法，构造方法等等，通过这个 Class 实例可以在运行时访问 Shapes 对象的属性和方法等。另外通过 Class类还可以创建出一个新的 Shapes 对象。这就是反射能够实现的原因，可以说 Class 是反射操作的基础。</p>
<p>需要特别注意的是，每个 class（注意 class 是小写，代表普通类）类，无论创建多少个实例对象，在 JVM 中都对应同一个 Class 对象。</p>
<p>下面就通过一个简单的例子来说明如何通过反射实例化一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal : name = "</span> + name + <span class="string">" age = "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Reflection"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取Animal类的Class对象</span></span><br><span class="line">        Class c = Animal.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过Class对象反射获取Animal类的构造方法</span></span><br><span class="line">            Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">            <span class="comment">//调用构造方法获取Animal实例</span></span><br><span class="line">            Animal animal = (Animal) constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="comment">//将构造出来的Animal对象打印出来</span></span><br><span class="line">            Log.d(TAG, animal.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看下打印值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03-28 20:12:00.958 2835-2835/? D/Reflection: Animal : name = Jack age = 3</span><br></pre></td></tr></table></figure>
<p>可以看出我们确实成功构造出了 Animal 对象，而且在这过程中 Class 功不可没。有人说你这也太费事了，都知道 Animal 对象了，我分分钟就能给你 new 出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Animal(<span class="string">"Jack"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>没错！但是如果并不能直接导入 Animal 类呢，如果构造方法都是 private 的呢？这个时候反射就能大展身手了。</p>
<h2 id="如何获取Class"><a href="#如何获取Class" class="headerlink" title="如何获取Class"></a>如何获取Class</h2><p>说 Class 是反射能够实现的基础的另一个原因是：Java 反射包 java.lang.reflect 中的所有类都没有 public 构造方法，要想获得这些类实例，只能通过 Class 类获取。所以说如果想使用反射，必须得获得 Class 对象。<br>下面列举了几种能够获取 Class 对象的方法。</p>
<ul>
<li>Object.getClass()<br>通过对象实例获取对应 Class 对象，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns the Class for String</span></span><br><span class="line">Class c = <span class="string">"foo"</span>.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E &#123; A, B &#125;</span><br><span class="line"><span class="comment">//Returns the Class corresponding to the enumeration type E.</span></span><br><span class="line">Class c = A.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//Returns the Class corresponding to an array with component type byte.</span></span><br><span class="line">Class c = bytes.getClass();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="comment">//Returns the Class corresponding to java.util.HashSet.</span></span><br><span class="line">Class c = s.getClass();</span><br></pre></td></tr></table></figure>
<p>然而对于基本类型无法使用这种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line">Class c = b.getClass();   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The .class Syntax<br>通过类的类型获取Class对象,基本类型同样可以使用这种方法，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The `.class` syntax returns the Class corresponding to the type `boolean`.</span></span><br><span class="line">Class c = <span class="keyword">boolean</span>.class;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the Class for String</span></span><br><span class="line">Class c = String.class;</span><br></pre></td></tr></table></figure>
<ul>
<li>Class.forName()<br>通过类的全限定名获取Class对象， 基本类型无法使用此方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>对于数组比较特殊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cDoubleArray = Class.forName(<span class="string">"[D"</span>);    <span class="comment">//相当于double[].class</span></span><br><span class="line"></span><br><span class="line">Class cStringArray = Class.forName(<span class="string">"[[Ljava.lang.String;"</span>);   <span class="comment">//相当于String[][].class</span></span><br></pre></td></tr></table></figure>
<ul>
<li>TYPE Field for Primitive Type Wrappers<br>基本类型和 void 类型的包装类可以使用 TYPE 字段获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = Double.TYPE;   <span class="comment">//等价于 double.class.</span></span><br><span class="line">Class c = Void.TYPE;</span><br></pre></td></tr></table></figure>
<ul>
<li>Methods that Return Classes<br>另外还有一些反射方法可以获取 Class 对象，但前提是你已经获取了一个 Class 对象。<br>有点拗口，比如说你已经获取了一个类的 Class 对象，就可以通过反射方法获取这个类的父类的 Class 对象。</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSuperclass--" target="_blank" rel="noopener">Class.getSuperclass()</a>获得给定类的父类 Class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javax.swing.JButton的父类是javax.swing.AbstractButton</span></span><br><span class="line">Class c = javax.swing.JButton.class.getSuperclass();</span><br></pre></td></tr></table></figure>
<p>类似方法还有：</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClasses--" target="_blank" rel="noopener">Class.getClasses()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredClasses--" target="_blank" rel="noopener">Class.getDeclaredClasses()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaringClass--" target="_blank" rel="noopener">Class.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getEnclosingClass--" target="_blank" rel="noopener">Class.getEnclosingClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Field.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Method.getDeclaringClass()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#getDeclaringClass--" target="_blank" rel="noopener">java.lang.reflect.Constructor.getDeclaringClass()</a></p>
<h2 id="通过Class获取类修饰符和类型"><a href="#通过Class获取类修饰符和类型" class="headerlink" title="通过Class获取类修饰符和类型"></a>通过Class获取类修饰符和类型</h2><p>我们知道类的声明一般如下表示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt5tL9GD0n77s3FwJiarzao9SKeiccYrAOy1qStMPfiadTQhuy4bmt3kx18tyf5zaq3ITOmRK3ib4Be6eA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>下面我们就以 HashMap 为例，通过一个 Demo 来说明如何获取这些信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Reflection"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = HashMap.class;</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        Log.d(TAG, <span class="string">"Class : "</span> + c.getCanonicalName());</span><br><span class="line">        <span class="comment">//获取类限定符</span></span><br><span class="line">        Log.d(TAG, <span class="string">"Modifiers : "</span> + Modifier.toString(c.getModifiers()));</span><br><span class="line">        <span class="comment">//获取类泛型信息</span></span><br><span class="line">        TypeVariable[] tv = c.getTypeParameters();</span><br><span class="line">        <span class="keyword">if</span> (tv.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder parameter = <span class="keyword">new</span> StringBuilder(<span class="string">"Parameters : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (TypeVariable t : tv) &#123;</span><br><span class="line">                parameter.append(t.getName());</span><br><span class="line">                parameter.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, parameter.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Type Parameters --"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类实现的所有接口</span></span><br><span class="line">        Type[] intfs = c.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (intfs.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder interfaces = <span class="keyword">new</span> StringBuilder(<span class="string">"Implemented Interfaces : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Type intf : intfs)&#123;</span><br><span class="line">                interfaces.append(intf.toString());</span><br><span class="line">                interfaces.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, interfaces.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Implemented Interfaces --"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类继承数上的所有父类</span></span><br><span class="line">        List&lt;Class&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        printAncestor(c, l);</span><br><span class="line">        <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder inheritance = <span class="keyword">new</span> StringBuilder(<span class="string">"Inheritance Path : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; cl : l)&#123;</span><br><span class="line">                inheritance.append(cl.getCanonicalName());</span><br><span class="line">                inheritance.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, inheritance.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Super Classes --%n%n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类的注解(只能获取到 RUNTIME 类型的注解)</span></span><br><span class="line">        Annotation[] ann = c.getAnnotations();</span><br><span class="line">        <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder annotation = <span class="keyword">new</span> StringBuilder(<span class="string">"Annotations : "</span>);</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : ann)&#123;</span><br><span class="line">                annotation.append(a.toString());</span><br><span class="line">                annotation.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, annotation.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"  -- No Annotations --%n%n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAncestor</span><span class="params">(Class&lt;?&gt; c, List&lt;Class&gt; l)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; ancestor = c.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l.add(ancestor);</span><br><span class="line">            printAncestor(ancestor, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Class : java.util.HashMap</span><br><span class="line">03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Modifiers : public</span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Parameters : K  V  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Implemented Interfaces : java.util.Map&lt;K, V&gt;  interface java.lang.Cloneable  interface java.io.Serializable  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Inheritance Path : java.util.AbstractMap  java.lang.Object  </span><br><span class="line">03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection:   -- No Annotations --</span><br></pre></td></tr></table></figure>
<h1 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h1><blockquote>
<p>Reflection defines an interface <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html" target="_blank" rel="noopener">java.lang.reflect.Member</a> which is implemented by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">java.lang.reflect.Field</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">java.lang.reflect.Method</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">java.lang.reflect.Constructor</a> .</p>
</blockquote>
<p>对于 Member 接口可能会有人不清楚是干什么的，但如果提到实现它的三个实现类，估计用过反射的人都能知道。我们知道类成员主要包括构造函数，变量和方法，Java 中的操作基本都和这三者相关，而 Member 的这三个实现类就分别对应他们。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">java.lang.reflect.Field</a> ：对应类变量<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">java.lang.reflect.Method</a> ：对应类方法<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">java.lang.reflect.Constructor</a> ：对应类构造函数</p>
<p>反射就是通过这三个类才能在运行时改变对象状态。下面就让我们通过一些例子来说明如何通过反射操作它们。</p>
<p>首先建一个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Cat.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"eat food "</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String... foods)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String food : foods)&#123;</span><br><span class="line">            s.append(food);</span><br><span class="line">            s.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"eat food "</span> + s.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name = "</span> + name + <span class="string">" age = "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>通过 Field 你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是 private 的。</p>
<ul>
<li><h3 id="获取-Field"><a href="#获取-Field" class="headerlink" title="获取 Field"></a>获取 Field</h3></li>
</ul>
<p>Class 提供了4种方法获得给定类的 Field</p>
<ul>
<li><ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredField-java.lang.String-" target="_blank" rel="noopener">getDeclaredField(String name)</a>     </p>
<p>获取指定的变量（只要是声明的变量都能获得，包括 private）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getField-java.lang.String-" target="_blank" rel="noopener">getField(String name)</a>      </p>
<p>获取指定的变量（只能获得 public 的）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--" target="_blank" rel="noopener">getDeclaredFields()</a>              </p>
<p>获取所有声明的变量（包括 private）</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getFields--" target="_blank" rel="noopener">getFields()</a></p>
<p>获取所有的 public 变量</p>
</li>
</ul>
</li>
<li><h3 id="获取变量类型、修饰符、注解"><a href="#获取变量类型、修饰符、注解" class="headerlink" title="获取变量类型、修饰符、注解"></a>获取变量类型、修饰符、注解</h3></li>
</ul>
<p>一个例子说明问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class c = Cat.class;</span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//获取名称</span></span><br><span class="line">            builder.append(<span class="string">"filed name = "</span>);</span><br><span class="line">            builder.append(f.getName());</span><br><span class="line">            <span class="comment">//获取类型</span></span><br><span class="line">            builder.append(<span class="string">" type = "</span>);</span><br><span class="line">            builder.append(f.getType());</span><br><span class="line">            <span class="comment">//获取修饰符</span></span><br><span class="line">            builder.append(<span class="string">" modifiers = "</span>);</span><br><span class="line">            builder.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="comment">//获取注解</span></span><br><span class="line">            Annotation[] ann = f.getAnnotations();</span><br><span class="line">            <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">" annotations = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : ann)&#123;</span><br><span class="line">                    builder.append(a.toString());</span><br><span class="line">                    builder.append(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.append(<span class="string">"  -- No Annotations --"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filed name = age type = int modifiers = public annotations = @java.lang.Deprecated() </span><br><span class="line">filed name = name type = class java.lang.String modifiers = private  -- No Annotations --</span><br><span class="line">filed name = TAG type = class java.lang.String modifiers = public static final  -- No Annotations --</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="获取、设置变量值"><a href="#获取、设置变量值" class="headerlink" title="获取、设置变量值"></a>获取、设置变量值</h3></li>
</ul>
<p>给定一个对象和它的成员变量名称，就能通过反射获取和改变该变量的值。什么都不说了，没有什么是不能通过一个例子解决的， Easy~</p>
<p>仍然是上面的测试类，通过反射获取并改变 Cat 的 name 和 age.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>, <span class="number">2</span>);</span><br><span class="line">        Class c = cat.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意获取private变量时，需要用getDeclaredField</span></span><br><span class="line">            Field fieldName = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">            Field fieldAge = c.getField(<span class="string">"age"</span>);</span><br><span class="line">            <span class="comment">//反射获取名字, 年龄</span></span><br><span class="line">            String name = (String) fieldName.get(cat);</span><br><span class="line">            <span class="keyword">int</span> age = fieldAge.getInt(cat);</span><br><span class="line">            Log.d(TAG, <span class="string">"before set, Cat name = "</span> + name + <span class="string">" age = "</span> + age);</span><br><span class="line">            <span class="comment">//反射重新set名字和年龄</span></span><br><span class="line">            fieldName.set(cat, <span class="string">"Timmy"</span>);</span><br><span class="line">            fieldAge.setInt(cat, <span class="number">3</span>);</span><br><span class="line">            Log.d(TAG, <span class="string">"after set, Cat "</span> + cat.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯？竟然报错？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.err: java.lang.IllegalAccessException: Class java.lang.Class&lt;com.example.ming.testnestscrollview.TestReflection&gt; cannot access private  field java.lang.String com.example.ming.testnestscrollview.Cat.name of class java.lang.Class&lt;com.example.ming.testnestscrollview.Cat&gt;</span><br><span class="line">System.err:     at java.lang.reflect.Field.get(Native Method)</span><br><span class="line">System.err:     at com.example.ming.testnestscrollview.TestReflection.testField(TestReflection.java:22)</span><br><span class="line">System.err:     at com.example.ming.testnestscrollview.MainActivity.onCreate(MainActivity.java:17)</span><br></pre></td></tr></table></figure>
<p>观察一下异常信息 java.lang.IllegalAccessException，说我们没有权限操作变量 name；回到 Cat 类中查看一下 name 变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
<p>原来 name 变量是 private，Java 运行时会进行访问权限检查，private 类型的变量无法进行直接访问，刚刚进行的反射操作并没有打破这种封装，所以我们依然没有权限对 private属性进行直接访问。</p>
<p>难道就没有办法打破这种限制吗？必须有！强大的反射早已暗中为我们准备好了一切。反射包里为我们提供了一个强大的类。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">java.lang.reflect.AccessibleObject</a></li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 为我们提供了一个方法 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html#setAccessible-boolean-" target="_blank" rel="noopener">setAccessible(boolean flag)</a>，该方法的作用就是可以取消 Java 语言访问权限检查。所以任何继承 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final 类型变量也可以通过这种办法访问）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">Field</a> 正是 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html" target="_blank" rel="noopener">AccessibleObject</a> 的子类，那么简单了，只要在访问私有变量前调用 filed.setAccessible(true) 就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fieldName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//反射获取名字, 年龄</span></span><br><span class="line">String name = (String) fieldName.get(cat);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestReflection: before set, Cat name = Tom age = 2</span><br><span class="line">TestReflection: after set, Cat name = Timmy age = 3</span><br></pre></td></tr></table></figure>
<p>Bingo!</p>
<p>注意 Method 和 Constructor 也都是继承 AccessibleObject，所以如果遇到私有方法和私有构造函数无法访问，记得处理方法一样。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><blockquote>
<p>The java.lang.reflect.Method class provides APIs to access information about a method’s modifiers, return type, parameters, annotations, and thrown exceptions. It also be used to invoke methods.</p>
</blockquote>
<p>这节主要介绍如何通过反射访问对象的方法。</p>
<ul>
<li><h3 id="获取-Method"><a href="#获取-Method" class="headerlink" title="获取 Method"></a>获取 Method</h3></li>
</ul>
<p>Class 依然提供了4种方法获取 Method:</p>
<ul>
<li><ul>
<li><p>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p>
<p>根据方法名获得指定的方法， 参数 name 为方法名，参数 parameterTypes 为方法的参数类型，如 getDeclaredMethod(“eat”, String.class)</p>
</li>
<li><p>getMethod(String name, Class&lt;?&gt;… parameterTypes)</p>
<p>根据方法名获取指定的 public 方法，其它同上</p>
</li>
<li><p>getDeclaredMethods()</p>
<p>获取所有声明的方法</p>
</li>
<li><p>getMethods()</p>
<p>获取所有的 public 方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：获取带参数方法时，如果参数类型错误会报 NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class）</p>
</blockquote>
<ul>
<li><h3 id="获取方法返回类型"><a href="#获取方法返回类型" class="headerlink" title="获取方法返回类型"></a>获取方法返回类型</h3></li>
<li><ul>
<li>getReturnType()   获取目标方法返回类型对应的 Class 对象</li>
<li>getGenericReturnType()  获取目标方法返回类型对应的 Type 对象</li>
</ul>
</li>
</ul>
<p>这两个方法有啥区别呢？</p>
<ul>
<li><p>getReturnType()返回类型为 Class，getGenericReturnType() 返回类型为 Type; Class 实现 Type。</p>
</li>
<li><p>返回值为普通简单类型如 Object, int, String 等，getGenericReturnType() 返回值和 getReturnType() 一样</p>
<p>例如 public String function1()，那么各自返回值为：</p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.String</li>
<li>getGenericReturnType() : class java.lang.String</li>
</ul>
</li>
<li><p>返回值为泛型</p>
<p>例如 public T function2()，那么各自返回值为：</p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.Object</li>
<li>getGenericReturnType() : T</li>
</ul>
</li>
<li><p>返回值为参数化类型</p>
<p>例如public Class<string> function3()，那么各自返回值为：</string></p>
</li>
<li><ul>
<li>getReturnType() : class java.lang.Class</li>
<li>getGenericReturnType() : java.lang.Class&lt;java.lang.String&gt;</li>
</ul>
</li>
</ul>
<p>其实反射中所有形如 getGenericXXX()的方法规则都与上面所述类似。</p>
<ul>
<li><h3 id="获取方法参数类型"><a href="#获取方法参数类型" class="headerlink" title="获取方法参数类型"></a>获取方法参数类型</h3><p>getParameterTypes() 获取目标方法各参数类型对应的 Class 对象<br>getGenericParameterTypes() 获取目标方法各参数类型对应的 Type 对象<br>返回值为数组，它俩区别同上 “方法返回类型的区别” 。</p>
</li>
<li><h3 id="获取方法声明抛出的异常的类型"><a href="#获取方法声明抛出的异常的类型" class="headerlink" title="获取方法声明抛出的异常的类型"></a>获取方法声明抛出的异常的类型</h3><p>getExceptionTypes() 获取目标方法抛出的异常类型对应的 Class 对象<br>getGenericExceptionTypes()  获取目标方法抛出的异常类型对应的 Type 对象<br>返回值为数组，区别同上</p>
</li>
<li><h3 id="获取方法参数名称"><a href="#获取方法参数名称" class="headerlink" title="获取方法参数名称"></a>获取方法参数名称</h3><p>.class 文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上 -parameters 参数。(构造方法的参数获取方法同样)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的m可以是普通方法Method，也可以是构造方法Constructor</span></span><br><span class="line"><span class="comment">//获取方法所有参数</span></span><br><span class="line">Parameter[] params = m.getParameters();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    Parameter p = params[i];</span><br><span class="line">    p.getType();   <span class="comment">//获取参数类型</span></span><br><span class="line">    p.getName();  <span class="comment">//获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`, X为参数在方法声明中的位置，从0开始</span></span><br><span class="line">    p.getModifiers(); <span class="comment">//获取参数修饰符</span></span><br><span class="line">    p.isNamePresent();  <span class="comment">//.class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取方法参数名称的详细信息请参考 oracle 的官方例子 MethodParameterSpy</p>
<ul>
<li><h3 id="获取方法修饰符"><a href="#获取方法修饰符" class="headerlink" title="获取方法修饰符"></a>获取方法修饰符</h3></li>
</ul>
<p>方法与 Filed 等类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.getModifiers();</span><br></pre></td></tr></table></figure>
<p>Ps：顺便多介绍几个Method方法</p>
<ol>
<li>method.isVarArgs() //判断方法参数是否是可变参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span>  <span class="comment">//返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt; [] parameterTypes)</span>  <span class="comment">//返回flase</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>method.isSynthetic() //判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法</li>
<li>method.isBridge() //判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。可以参考：<a href="https://www.jianshu.com/u/ceba5da6bd7a" target="_blank" rel="noopener">https://www.jianshu.com/u/ceba5da6bd7a</a></li>
</ol>
<ul>
<li><h3 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h3></li>
</ul>
<p>反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<p>还是以上面测试类 Cat 为例</p>
<blockquote>
<p>注意：如果方法是private的，可以使用 method.setAccessible(true) 方法绕过权限检查</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Cat.class;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//构造Cat实例</span></span><br><span class="line">     Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">     Object cat = constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">//调用无参方法</span></span><br><span class="line">     Method sleep = c.getDeclaredMethod(<span class="string">"sleep"</span>);</span><br><span class="line">     sleep.invoke(cat);</span><br><span class="line">     <span class="comment">//调用定项参数方法</span></span><br><span class="line">     Method eat = c.getDeclaredMethod(<span class="string">"eat"</span>, String.class);</span><br><span class="line">     eat.invoke(cat, <span class="string">"grass"</span>);</span><br><span class="line">     <span class="comment">//调用不定项参数方法</span></span><br><span class="line">     <span class="comment">//不定项参数可以当成数组来处理</span></span><br><span class="line">     Class[] argTypes = <span class="keyword">new</span> Class[] &#123; String[].class &#125;;</span><br><span class="line">     Method varargsEat = c.getDeclaredMethod(<span class="string">"eat"</span>, argTypes);</span><br><span class="line">     String[] foods = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">          <span class="string">"grass"</span>, <span class="string">"meat"</span></span><br><span class="line">     &#125;;</span><br><span class="line">     varargsEat.invoke(cat, (Object)foods);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被调用的方法本身所抛出的异常在反射中都会以 InvocationTargetException 抛出。换句话说，反射调用过程中如果异常 InvocationTargetException 抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。</p>
</blockquote>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>这节主要介绍如何通过反射访问构造方法并通过构造方法构建新的对象。</p>
<ul>
<li><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3></li>
</ul>
<p>和 Method 一样，Class 也为 Constructor 提供了4种方法获取</p>
<ul>
<li><ul>
<li><p>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>获取指定构造函数，参数 parameterTypes 为构造方法的参数类型</p>
</li>
<li><p>getConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>获取指定 public 构造函数，参数 parameterTypes 为构造方法的参数类型</p>
</li>
<li><p>getDeclaredConstructors()</p>
<p>获取所有声明的构造方法</p>
</li>
<li><p>getConstructors()</p>
<p>获取所有的 public 构造方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>构造方法的名称、限定符、参数、声明的异常等获取方法都与 Method 类似，请参照Method。</p>
</blockquote>
<ul>
<li><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3></li>
</ul>
<p>通过反射有两种方法可以创建对象：</p>
<ul>
<li>java.lang.reflect.Constructor.newInstance()</li>
<li>Class.newInstance()</li>
</ul>
<p>一般来讲，我们优先使用第一种方法；那么这两种方法有何异同呢？</p>
<ol>
<li>Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法。</li>
<li>Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出; Constructor.newInstance()会将构造方法中抛出的异常都包装成 InvocationTargetException 抛出。</li>
<li>Class.newInstance()需要拥有构造方法的访问权限; Constructor.newInstance()可以通过 setAccessible(true) 方法绕过访问权限访问 private 构造方法。</li>
</ol>
<p>例子在 Method 一节已经写过，这里直接截取过来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Cat.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = c.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Cat cat = (Cat) constructor.newInstance( <span class="string">"Jack"</span>, <span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间）</p>
</blockquote>
<h2 id="数组和枚举"><a href="#数组和枚举" class="headerlink" title="数组和枚举"></a>数组和枚举</h2><p>数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以 Java 反射为数组和枚举提供了一些特定的 API 接口。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4></li>
</ul>
<p>数组类型：数组本质是一个对象，所以它也有自己的类型。</p>
<p>例如对于int[] intArray，数组类型为class [I。数组类型中的[个数代表数组的维度，例如[代表一维数组，[[ 代表二维数组；[ 后面的字母代表数组元素类型，I 代表 int，一般为类型的首字母大写(long 类型例外，为 J)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class [B    //byte类型一维数组</span><br><span class="line">class [S    //short类型一维数组</span><br><span class="line">class [I    //int类型一维数组</span><br><span class="line">class [C    //char类型一维数组</span><br><span class="line">class [J    //long类型一维数组，J代表long类型，因为L被引用对象类型占用了</span><br><span class="line">class [F    //float类型一维数组</span><br><span class="line">class [D    //double类型一维数组</span><br><span class="line">class [Lcom.dada.Season    //引用类型一维数组</span><br><span class="line">class [[Ljava.lang.String  //引用类型二维数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个变量的类型</span></span><br><span class="line">Class&lt;?&gt; c = field.getType();</span><br><span class="line"><span class="comment">//判断该变量是否为数组</span></span><br><span class="line"><span class="keyword">if</span> (c.isArray()) &#123;</span><br><span class="line">   <span class="comment">//获取数组的元素类型</span></span><br><span class="line">   c.getComponentType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h4></li>
</ul>
<p>Java 反射为我们提供了 java.lang.reflect.Array 类用来创建和初始化数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组， 参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度</span></span><br><span class="line">Array.newInstance(Class&lt;?&gt; componentType, <span class="keyword">int</span>... dimensions)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值</span></span><br><span class="line">Array.set(Object array, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组的值，array为数组对象，index为数组的下标</span></span><br><span class="line">Array.get(Object array, <span class="keyword">int</span> index)</span><br></pre></td></tr></table></figure>
<p>例子,用反射创建 int[] array = new int[]{1, 2}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Array.setInt(array , <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(array , <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：反射支持对数据自动加宽，但不允许数据 narrowing(变窄?真难翻译)。意思是对于上述 set 方法，你可以在 int 类型数组中 set short 类型数据，但不可以 set long 类型数据，否则会报 IllegalArgumentException。</p>
</blockquote>
<ul>
<li><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4></li>
</ul>
<p>Java 反射没有提供能够直接访问多维数组元素的 API，但你可以把多维数组当成数组的数组处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.get(matrix, <span class="number">0</span>);</span><br><span class="line">Object row1 = Array.get(matrix, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object matrix = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row0 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line">Object row1 = Array.newInstance(<span class="keyword">int</span>.class, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Array.setInt(row0, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Array.setInt(row0, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Array.setInt(row1, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Array.set(matrix, <span class="number">0</span>, row0);</span><br><span class="line">Array.set(matrix, <span class="number">1</span>, row1);</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举隐式继承自 java.lang.Enum，Enum 继承自 Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外 java 反射额外提供了几个方法为枚举服务。</p>
<ul>
<li><p><code>Class.isEnum()</code></p>
<p>Indicates whether this class represents an enum type</p>
</li>
<li><p><code>Class.getEnumConstants()</code></p>
<p>Retrieves the list of enum constants defined by the enum in the order they’re declared</p>
</li>
<li><p><code>java.lang.reflect.Field.isEnumConstant()</code></p>
<p>Indicates whether this field represents an element of an enumerated type</p>
</li>
</ul>
<h1 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h1><p>没有任何一项技术是十全十美的，Java 反射拥有强大功能的同时也带来了一些副作用。</p>
<ul>
<li><p>性能开销</p>
<p>反射涉及类型动态解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p>安全限制</p>
<p>使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p>内部曝光</p>
<p>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
</ul>
<blockquote>
<p>使用反射的一个原则：如果使用常规方法能够实现，那么就不要用反射。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/《TCPIP详解卷1》010阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/《TCPIP详解卷1》010阅读笔记/" itemprop="url">《TCPIP详解卷1》010阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T20:05:37+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><table>
<thead>
<tr>
<th>缩写</th>
<th>英文全称</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>AS</td>
<td>Autonomous System</td>
<td>自治系统</td>
</tr>
<tr>
<td>IGP</td>
<td>Interior Gateway Protocol</td>
<td>内部网关协议/域内选路协议</td>
</tr>
<tr>
<td>EGP</td>
<td>Exterier Gateway Protocol</td>
<td>外部网关协议/域内选路协议的分隔选路协议</td>
</tr>
<tr>
<td>BGP</td>
<td>Border Gateway Protocol</td>
<td>边界网关协议</td>
</tr>
<tr>
<td>RIP</td>
<td>Routing Infomation Protocol</td>
<td>选路信息协议</td>
</tr>
<tr>
<td>OSPF</td>
<td>Open Shortest Path First</td>
<td>开放最短路径优先协议</td>
</tr>
<tr>
<td>CIDR</td>
<td>Classless Inter-Domain Routing</td>
<td>无类别域间路由</td>
</tr>
</tbody>
</table>
<ul>
<li>IGP用于自治系统内。</li>
<li>EGP用于自治系统之间。</li>
<li>BGP意在取代EGP。<br><br></li>
</ul>
<h4 id="动态选路"><a href="#动态选路" class="headerlink" title="动态选路"></a>动态选路</h4><ul>
<li>相邻路由器之间进行通信，告知对方每个路由器当前所连接的网络。</li>
<li>路由守护程序根据从相邻路由器收到的信息更新内核中的路由表。</li>
<li>随时间变化时，路由是由路由守护程序动态地增加或删除。</li>
<li>如果路由守护程序发现前往同一信宿存在多条路由，选择最佳路由加入内核路由表。</li>
<li>如果路由守护程序发现一条链路已经断开，删除受影响的路由或增加一条路由绕过。</li>
<li>每个自治系统由单个<strong>实体</strong>管理。==什么是实体？==<br><br></li>
</ul>
<h4 id="RIP：选路信息协议"><a href="#RIP：选路信息协议" class="headerlink" title="RIP：选路信息协议"></a>RIP：选路信息协议</h4><ul>
<li>正式描述文件RFC 1058 [Hedrick 1988a]。</li>
<li>RIP报文包含在UDP数据报中。</li>
<li>RIP的度量是以跳计数的。</li>
<li>最多携带25个路由。<br><br></li>
</ul>
<h6 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h6><ul>
<li>直接连接接口的跳数为1。</li>
<li>一个路由器到一个网络有多条路由，路由器选择跳数最小的路由。</li>
<li>度量为16表示无路由到达该IP地址。<br><br></li>
</ul>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul>
<li>RIP没有子网地址的概念。</li>
<li>路由器或链路发生故障后在稳定下来这段时间可能发生路由环路。</li>
<li>度量最大值限制了可以使用RIP的网络的大小。<br><br></li>
</ul>
<h4 id="RIP版本2"><a href="#RIP版本2" class="headerlink" title="RIP版本2"></a>RIP版本2</h4><ul>
<li>RFC 1388 [Malkin 1993a] 对RIP定义进行了扩充。</li>
<li>路由域字段：数据报的所有者。</li>
<li>选路标记字段：携带一个EGP和BGP的自治系统号。</li>
<li>子网掩码字段：应用于相应的IP地址。</li>
<li>下一站IP地址字段：指明发往目的IP地址的报文应该发往哪里。</li>
<li>除了支持广播，还支持多播。<br><br></li>
</ul>
<h4 id="OSPF：开放最短路径优先"><a href="#OSPF：开放最短路径优先" class="headerlink" title="OSPF：开放最短路径优先"></a>OSPF：开放最短路径优先</h4><ul>
<li>RFC 1247 [Moy 1991] 对第2版OSPF进行了描述。</li>
<li>OSPF克服了RIP所有限制。</li>
<li>路由器不与临站交换距离信息，主动测试与临站相连的链路状态。</li>
<li>信息发给其他临站，临站将这些信息在自治系统中传播出去。</li>
<li>路由器接收这些链路状态信息，建立完整的路由表。</li>
<li>链路状态协议总是比距离向量协议稳定更快。</li>
<li>OSPF直接使用IP，不使用UDP或TCP。</li>
<li>优于RIP的特点：</li>
<li><ol>
<li>可以对每个IP服务类型计算各自的路由集。</li>
</ol>
</li>
<li><ol start="2">
<li>给每个接口指派一个无维数的费用。</li>
</ol>
</li>
<li><ol start="3">
<li>同一个目的地址存在多个相同费用的路由时，平均分配流量。</li>
</ol>
</li>
<li><ol start="4">
<li>支持子网，子网掩码与每个通告相连。</li>
</ol>
</li>
<li><ol start="5">
<li>无编号网络。</li>
</ol>
</li>
<li><ol start="6">
<li>简单鉴别机制。</li>
</ol>
</li>
<li><ol start="7">
<li>采用多播而不是广播形式，减少系统负载。<br><br></li>
</ol>
</li>
</ul>
<h4 id="BGP：边界网关协议"><a href="#BGP：边界网关协议" class="headerlink" title="BGP：边界网关协议"></a>BGP：边界网关协议</h4><ul>
<li>RFC 1267 [Lougheed and Rekhter 1991] 对第3版BGP进行描述。</li>
<li>BGP系统之间交换网络可到达信息，包括所必须经过的自治系统的所有路径。</li>
<li>使用BGP的一个目的是减少通过流量。</li>
<li>允许使用基于策略的选路。</li>
<li>使用TCP作为其传输层协议。</li>
<li>BGP是一个距离测量协议，列举了到每个目的地址的路由，排除了一些距离向量协议的问题。</li>
<li>定期发送keepalive报文给临站来监测TCP连接对端的链路或主机失败。</li>
<li>应用层的keepalive报文与TCP的keepalive报文选项相互独立。<br><br></li>
</ul>
<h4 id="CIDR：无类型域间选路"><a href="#CIDR：无类型域间选路" class="headerlink" title="CIDR：无类型域间选路"></a>CIDR：无类型域间选路</h4><ul>
<li>RFC 1518 [Rekher and Li 1993], RFC 1519 [Fuller et al. 1993]对它描述。</li>
<li>[Ford, Rekhter, and Braun 1993] 综述。</li>
<li>一个防止路由表膨胀的方法，也成为超网。</li>
<li>采用分配多个IP地址的方式，使许多表项总和成更少的数目</li>
<li>必须满足3种特性：</li>
<li><ol>
<li>IP地址必须具有相同的高位地址比特。</li>
</ol>
</li>
<li><ol start="2">
<li>路由表和选路算法必须扩展成根据32 bit IP地址和32 bit 掩码做出选路决策。</li>
</ol>
</li>
<li><ol start="3">
<li>选路协议要有32 bit掩码。</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/12/《TCPIP详解卷1》007、008、009阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》007、008、009阅读笔记/" itemprop="url">《TCPIP详解卷1》007、008、009阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T20:32:56+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="007，Ping的工作原理"><a href="#007，Ping的工作原理" class="headerlink" title="007，Ping的工作原理"></a>007，Ping的工作原理</h4><h6 id="Unix系统的实现"><a href="#Unix系统的实现" class="headerlink" title="Unix系统的实现"></a>Unix系统的实现</h6><ul>
<li>把ICMP报文中标识符字段设置成发送进程的ID号（识别多个Ping程序实例）。</li>
<li>序列号从0开始，每发送一次新的回显请求就 + 1。</li>
<li>Ping程序允许我们查看是否有分组丢失、失序或重复。<br><br></li>
</ul>
<h6 id="旧版本Ping程序"><a href="#旧版本Ping程序" class="headerlink" title="旧版本Ping程序"></a>旧版本Ping程序</h6><ul>
<li>每秒发送一个回显请求。</li>
<li>打印返回的每个分组的每个回显应答。<br><br></li>
</ul>
<h6 id="新版本Ping程序"><a href="#新版本Ping程序" class="headerlink" title="新版本Ping程序"></a>新版本Ping程序</h6><ul>
<li>需要加上 - s 选项以旧版本模式运行。</li>
<li>Ping程序只发送一个回显请求。</li>
<li>收到回显应答输出“host is alive”，20秒内没收到输出“no answer”。<br><br></li>
</ul>
<h4 id="008，Traceroute的工作原理"><a href="#008，Traceroute的工作原理" class="headerlink" title="008，Traceroute的工作原理"></a>008，Traceroute的工作原理</h4><ul>
<li>每个处理数据报的路由器都要把TTL的值减1或停留的秒数。</li>
<li>大多数路由器转发数据报的时延都小于1秒，TTL最终成为一个跳站计数器。</li>
<li>如果TTL字段是1，路由器将该数据报丢弃，并向信源机放一份ICMP“超时”信息。</li>
<li>Traceroute程序发送一份TTL字段为1的IP数据报为目的主机，第一个路由器丢弃并发回超时ICMP报文，然后Traceroute程序发送一份TTL字段为2的数据报，得到第二个路由器的地址，以此类推。</li>
<li>目的主机收到TTL值为1的IP数据报，不会丢弃并产生ICMP超时报文。</li>
<li>Traceroute程序发送一份不可能值作为UDP端口号（大于30000）的UDP数据报给目的主机，目的主机产生一份“端口不可达”错误的ICMP报文。</li>
<li>Traceroute程序区分收到的ICMP报文是超时还是端口不可达判断是否结束。<br><br></li>
</ul>
<h4 id="009，IP包选路的工作原理"><a href="#009，IP包选路的工作原理" class="headerlink" title="009，IP包选路的工作原理"></a>009，IP包选路的工作原理</h4><h6 id="选路的原理"><a href="#选路的原理" class="headerlink" title="选路的原理"></a>选路的原理</h6><ul>
<li>IP搜索路由表的步骤：</li>
<li><ol>
<li>搜索匹配的主机地址。</li>
</ol>
</li>
<li><ol start="2">
<li>搜索比配的网络地址。</li>
</ol>
</li>
<li><ol start="3">
<li>搜索默认表项。</li>
</ol>
</li>
<li>IP层进行的选路是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。</li>
<li>选路策略决定把哪些路由放入路由表的规则，路由守护程序提供选路策略。<br><br></li>
</ul>
<h6 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h6><ul>
<li>在系统引导时显示地的在初始化文件中运行route命令。<br><br></li>
</ul>
<h6 id="没有到达目的地的路由"><a href="#没有到达目的地的路由" class="headerlink" title="没有到达目的地的路由"></a>没有到达目的地的路由</h6><p>路由表中没有默认项，又没有找到匹配项。</p>
<ul>
<li>数据报由本地主机产生：向应用程序返回一个“主机不可达差错”或“网络不可达差错”。</li>
<li>被转发的数据报：向原始发送端发送一份ICMP主机不可达差错报文。<br><br></li>
</ul>
<h6 id="ICMP重定向差错"><a href="#ICMP重定向差错" class="headerlink" title="ICMP重定向差错"></a>ICMP重定向差错</h6><ul>
<li>当数据报应该被发送到另一个路由器时，收到数据报的路由器要发送ICMP重定向差错报文给IP数据报的发送端。</li>
<li>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。<br><br></li>
</ul>
<h6 id="ICMP重定向报文"><a href="#ICMP重定向报文" class="headerlink" title="ICMP重定向报文"></a>ICMP重定向报文</h6><ul>
<li>重定向报文只能由路由器生成。</li>
<li>重定向报文是为主机使用的。<br><br></li>
</ul>
<h6 id="ICMP路由器发现报文"><a href="#ICMP路由器发现报文" class="headerlink" title="ICMP路由器发现报文"></a>ICMP路由器发现报文</h6><ul>
<li>一份报文可以通告多个地址。</li>
<li>路由器启动时定期在所有广播或多播传送接口上发送通告报文。</li>
<li>某个接口被关闭时，该接口上发送一份通告报文，生命周期值设为0。</li>
<li>监听来自主机的请求报文，并发送通告报文以响应。</li>
<li>主机在引导期间发送请求报文。</li>
<li>监听来自相邻路由器的请求报文。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/12/《TCPIP详解卷1》006阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》006阅读笔记/" itemprop="url">《TCPIP详解卷1》006阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T16:34:53+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ICMP的正式规范参见 RFC 792<br><br></p>
<p>ICMP是IP层的一个组成部分，传递差错报文和其他需要注意的信息。<br>通常被IP层或更高层协议使用。<br><br></p>
<p><img src="../images/《TCPIP详解卷1》006阅读笔记/ICMP报文.png" alt="image"></p>
<ul>
<li>校验和覆盖整个ICMP报文，算法与IP首部相同</li>
<li>不同类型和代码有不同的内容<br><br></li>
</ul>
<h4 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h4><ul>
<li>类型字段和代码字段共同决定。</li>
<li><p>ICMO差错报文始终包含IP首部和产生差错的IP数据报的前8个字节。<br>接收ICMP差错报文的模块可以与某个协议和用户进程联系起来。</p>
</li>
<li><p>下面情况不产生差错报文：</p>
</li>
<li><ol>
<li>ICMP差错报文</li>
</ol>
</li>
<li><ol start="2">
<li>目的地址是广播或多播地址</li>
</ol>
</li>
<li><ol start="3">
<li>作为链路层广播的数据报</li>
</ol>
</li>
<li><ol start="4">
<li>不是IP分片的第一片</li>
</ol>
</li>
<li><ol start="5">
<li>源地址不是单个主机的数据报<br><br></li>
</ol>
</li>
</ul>
<h4 id="ICMP地址掩码请求与应答"><a href="#ICMP地址掩码请求与应答" class="headerlink" title="ICMP地址掩码请求与应答"></a>ICMP地址掩码请求与应答</h4><p><img src="../images/《TCPIP详解卷1》006阅读笔记/掩码请求和应答.png" alt="iamge"></p>
<ul>
<li>用于无盘系统在引导过程中获取自己的子网掩码。</li>
<li>系统广播他的ICMP请求报文（类似RARP获取IP地址）。</li>
<li>标识符和序列号由发送端任意设定，在应答中返回进行匹配。<br><br></li>
</ul>
<h4 id="ICMP时间戳请求与应答"><a href="#ICMP时间戳请求与应答" class="headerlink" title="ICMP时间戳请求与应答"></a>ICMP时间戳请求与应答</h4><p><img src="../images/《TCPIP详解卷1》006阅读笔记/时间戳请求和应答.png" alt="image"></p>
<ul>
<li>请求允许系统向另一个系统查询当前时间。</li>
<li>返回的建议值是自午夜计算的毫秒数，协调的统一时间。</li>
<li>缺陷：必须通过其他方法获知当时的日期。</li>
<li>请求端填写发起时间戳，应答系统收到时填写接收时间戳，发送时填写传送时间戳。<br><img src="../images/《TCPIP详解卷1》006阅读笔记/时间戳请求.png" alt="image"><br><img src="../images/《TCPIP详解卷1》006阅读笔记/值关系.png" alt="image"></li>
<li>调整值是difference - RTT / 2。<br><br></li>
</ul>
<h4 id="ICMP端口不可达差错"><a href="#ICMP端口不可达差错" class="headerlink" title="ICMP端口不可达差错"></a>ICMP端口不可达差错</h4><p>以UDP端口不可达为例。<br><img src="../images/《TCPIP详解卷1》006阅读笔记/例子返回报文.png" alt="image"></p>
<ul>
<li>IP首部后面前8个字节是UDP首部（源端口号和目的端口号）。<br><img src="../images/《TCPIP详解卷1》006阅读笔记/不可达报文.png" alt="image"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/12/《TCPIP详解卷1》004阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ennis L.M. Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ennis -Little Monster">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/《TCPIP详解卷1》004阅读笔记/" itemprop="url">《TCPIP详解卷1》004阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T15:38:11+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RFC 826 [Plummer 1982] 是ARP规范描述文档。<br>ARP（地址解析协议）<br>RARP（逆地址解析协议）<br><br></p>
<p>ARP为IP地址到对应硬件地址之间提供动态映射，因为是自动完成的。<br>RARP被没有磁盘驱动器的系统使用，需要系统管理员手工设置。<br><br></p>
<p>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。称作广播。<br><br></p>
<p>点对点链路不使用ARP。设置这些链路时，必须告知内核链路每一端的IP地址，而不需要硬件地址。<br><br></p>
<p>ARP高效运行因为每个主机上都有一个ARP高速缓存<br><br></p>
<h4 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h4><table>
<thead>
<tr>
<th>以太网目的地址</th>
<th>以太网源地址</th>
<th>帧类型</th>
<th>硬件类型</th>
<th>协议类型</th>
<th>硬件地址长度</th>
<th>协议地址长度</th>
<th>op</th>
<th>发送端以太网地址</th>
<th>发送端IP地址</th>
<th>目的以太网地址</th>
<th>目的IP地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>6</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>全1</td>
<td></td>
<td>0x0806</td>
<td>1</td>
<td>0x0800</td>
<td>6 bytes</td>
<td>4 bytes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>广播地址</td>
<td></td>
<td>ARP请求或应答</td>
<td>表示以太网地址</td>
<td>表示IP地址</td>
<td>MAC地址长度</td>
<td>IP地址长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>目的地址：全1的特殊地址是广播地址，电缆上的所有以太网接口都要接收广播的数据帧。</li>
<li>操作字段（OP）：ARP请求（1）、ARP应答（2）、RARP请求（3）、RARP应答（4），必须字段，因为ARP请求和应答的帧类型字段相同。<br><br></li>
</ul>
<h4 id="ARP高速缓存超时设置"><a href="#ARP高速缓存超时设置" class="headerlink" title="ARP高速缓存超时设置"></a>ARP高速缓存超时设置</h4><ul>
<li>BSD演变来的系统一般设置完整表项超时20分钟，不完整表项超时3分钟。</li>
<li>表项再次使用时，超时值重设为20分钟。<br><br></li>
</ul>
<h4 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h4><ul>
<li>路由器相当于目的主机的代理，把分组从其他主机转发给它。<br><br></li>
</ul>
<h4 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h4><ul>
<li>是指发送ARP查找自己的IP地址。</li>
<li>两方面作用：</li>
<li><ol>
<li>验证IP是否冲突，一个主机能够通过它来确定是否还有一个主机设置了相同的IP地址。</li>
</ol>
</li>
<li><ol>
<li>更换物理网卡，假设发送ARP的主机正好改变了物理地址，能够使用此方法通知网络中其他主机及时更新ARP缓存。<br><br></li>
</ol>
</li>
</ul>
<h4 id="ARP命令"><a href="#ARP命令" class="headerlink" title="ARP命令"></a>ARP命令</h4><ul>
<li>arp -a 显示ARP高速缓存。</li>
<li>arp -d 删除ARP高速缓存中某一项。</li>
<li>arp -s 增加高速缓存中的内容，是永久性的，除非末尾加上关键字temp。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/portrait.png"
                alt="Ennis L.M. Wu" />
            
              <p class="site-author-name" itemprop="name">Ennis L.M. Wu</p>
              <p class="site-description motion-element" itemprop="description">We could belong togeter, ARTPOP .</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/EnnisWu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/EnnisLM" target="_blank" title="Gitee">
                      
                        <i class="fa fa-fw fa-globe"></i>Gitee</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/wkf1997" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/ennis_lm" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/u/3660210774" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wkf1997@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ennis L.M. Wu</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"scale":0.5,"hHeadPos":0.5,"vHeadPos":0.618,"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
