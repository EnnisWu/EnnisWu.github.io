<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ennis -Little Monster</title>
  
  <subtitle>ARTPOP = artistic revolution through the potential of pop.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-06T11:58:37.421Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ennis L.M. Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-1617即时编译</title>
    <link href="http://yoursite.com/2018/11/06/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1617%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2018/11/06/笔记-深入拆解Java虚拟机-1617即时编译/</id>
    <published>2018-11-06T02:03:09.000Z</published>
    <updated>2018-11-06T11:58:37.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分层编译模式"><a href="#分层编译模式" class="headerlink" title="分层编译模式"></a>分层编译模式</h1><h2 id="HotSpot-包含的即时编译器："><a href="#HotSpot-包含的即时编译器：" class="headerlink" title="HotSpot 包含的即时编译器："></a>HotSpot 包含的即时编译器：</h2><ol><li>C1</li><li>C2</li><li>Graal（<strong>实验性质</strong>的即时编译器）</li></ol><h2 id="Java-7-以前需要根据程序特性选择对应的即使编译器"><a href="#Java-7-以前需要根据程序特性选择对应的即使编译器" class="headerlink" title="Java 7 以前需要根据程序特性选择对应的即使编译器"></a>Java 7 以前需要根据程序特性选择对应的即使编译器</h2><h3 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h3><ul><li><strong>执行时间较短</strong>的程序。</li><li>对<strong>启动性能</strong>有要求的程序。</li><li>C1 <strong>编译效率较快</strong>。</li><li>对应参数 -client</li></ul><h3 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h3><ul><li><strong>执行时间较长</strong>的程序。</li><li>对<strong>峰值性能</strong>有要求的程序。</li><li>C2 生成<strong>代码的执行效率较快</strong>。</li><li>对应参数 -server</li></ul><h2 id="Java-7-引入分层编译"><a href="#Java-7-引入分层编译" class="headerlink" title="Java 7 引入分层编译"></a>Java 7 引入分层编译</h2><ul><li><strong>综合</strong> C1 的<strong>启动性能</strong>优势和 C2 的<strong>峰值性能</strong>优势。</li><li><p>分层编译将 Java 虚拟机的执行状态<strong>分为 5 个层次</strong>。</p><p>  0.解释执行</p><p>  1.执行不带 profiling 的 C1 代码</p><p>  2.执行仅带方法调用次数和循环回边执行次数 profiling 的C1 代码</p><p>  3.执行带所有 profiling 的 C1 代码</p><p>  4.执行 C2 代码</p></li><li><p>C2 代码的执行效率比 C1 代码高 30% 以上。</p></li><li>C1 执行效率 1 层 &gt; 2 层 &gt; 3 层。（1 层比 2 层稍高，2 层比 3 层高 30% 以上）。</li></ul><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><ul><li>profiling：在程序执行过程中，收集能够<strong>反映程序执行状态的数据</strong>。</li><li>这里所收集的数据我们称之为程序的 profile。</li><li>例如 JDK 附带的 hprof。</li><li>profiler 大多通过<strong>注入</strong>或 <strong>JVMTI 事件</strong>来实现。</li></ul><h2 id="编译路径"><a href="#编译路径" class="headerlink" title="编译路径"></a>编译路径</h2><ul><li><strong>1 层和 4 层为终止状态。</strong></li><li>一个方法被终止状态编译后，如果编译后的代码没有失效，JVM 不再发出该方法的编译请求。</li></ul><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/16/compile_path.png" alt="image"></p><h3 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h3><ul><li>热点方法会被第 3 层的 C1 编译，再被第 4 层的 C2 编译。</li></ul><h3 id="琐碎的方法"><a href="#琐碎的方法" class="headerlink" title="琐碎的方法"></a>琐碎的方法</h3><ul><li><strong>字节数少</strong>，且第 3 层的 profiling <strong>没有可收集的数据</strong>的方法。</li><li>JVM 断定该方法对于 <strong>C1 代码和 C2 代码执行效率相同</strong>。</li><li>在第 3 层编译后，直接用第 1 层的 C1 编译。</li></ul><h3 id="C1-忙碌的情况"><a href="#C1-忙碌的情况" class="headerlink" title="C1 忙碌的情况"></a>C1 忙碌的情况</h3><ul><li>解释执行过程中进行 profiling。</li><li>然后直接由第 4 层的 C2 编译。</li></ul><h3 id="C2-忙碌的情况"><a href="#C2-忙碌的情况" class="headerlink" title="C2 忙碌的情况"></a>C2 忙碌的情况</h3><ul><li>方法先被第 2 层的 C1 编译。</li><li>再被第 3 层的 C1 编译，减少在第 3 层的执行时间。</li></ul><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><ul><li>默认开启分层编译。</li><li>不管分层编译是否开启，原本的选择即时编译器的参数都无效（-client 和 -server）。</li><li>关闭分层编译情况下，JVM 采用 C2。</li><li>只使用 C1：使用参数 -XX:TieredStopAtLevel=1，解释执行后直接由 1 层的 C1 编译。</li></ul><h1 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h1><ul><li>根据方法的<strong>调用次数</strong>和<strong>循环回边的执行次数</strong>来触发。</li><li>profiling 中包含上述次数。</li><li><strong>解释执行和 C1 代码中增加循环回边计数器的位置不同</strong>，但不会对程序照成影响。</li><li>JVM <strong>不对计数器进行同步</strong>，收集的几次为非精确值。</li><li>即时编译的<strong>触发不需要非常精确的值</strong>。</li><li>不启用分层编译，超过由参数 -XX:CompileThreshold 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），会触发即时编译。</li><li>启用分层编译，JVM 不采用由参数 -XX:CompileThreshold 指定的阈值，使用另一套阈值系统。阈值大小<strong>动态调整</strong>。</li><li>动态调整：比较阈值时，将阈值与某个<strong>系数 s</strong> 相乘。</li><li>该系数与<strong>当前待编译的方法数目</strong>成<strong>正相关</strong>，与<strong>编译线程的数目</strong>成<strong>负相关</strong>。</li><li>64 位 JVM中，默认情况下<strong>编译线程的总数目</strong>根据<strong>处理器数量来调整</strong>，（对应参数 -XX:+CICompilerCountPerCPU，默认为 true；当通过参数 -XX:+CICompilerCount=N 强制设定总编译线程数目时，CICompilerCountPerCPU 将被设置为 false）。</li><li>JVM 将编译线程按照 1:2 的比例分配给 C1 和 C2（至少各为 1 个）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于核及以上的机器，总的编译线程的数目为：</span><br><span class="line">n = log2(N) * log2(log2(N)) * 3 / 2</span><br><span class="line">其中 N 为 CPU 核心数目。</span><br></pre></td></tr></table></figure><p>启用分层编译时的具体触发条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当方法调用次数大于由参数 -XX:TierXInvocationThreshold 指定的阈值乘以系数，或者当方法调用次数大于由参数 -XX:TierXMINInvocationThreshold 指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数 -XX:TierXCompileThreshold 指定的阈值乘以系数时，便会触发 X 层即时编译。</span><br><span class="line"></span><br><span class="line">触发条件为：</span><br><span class="line">i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s)</span><br></pre></td></tr></table></figure><h1 id="OSR-编译"><a href="#OSR-编译" class="headerlink" title="OSR 编译"></a>OSR 编译</h1><ul><li>JVM 还存在另一种以<strong>循环为单位</strong>的即时编译（On-Stack-Replacement（OSR）编译）。</li><li><strong>循环回边计数器用来触发</strong>这种类型的编译的。</li><li>不启用分层编译情况，触发 OSR 编译的阈值是由参数 -XX:CompileThreshold 指定的阈值的倍数。</li></ul><p>计算方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(OnStackReplacePercentage - InterpreterProfilePercentage)/100</span><br><span class="line"></span><br><span class="line">其中 -XX:InterpreterProfilePercentage 的默认值为 33，当使用 C1 时 -XX:OnStackReplacePercentage 为 933，当使用 C2 时为 140。</span><br><span class="line">也就是说，默认情况下，C1 的 OSR 编译的阈值为 13500，而 C2 的为 10700。</span><br></pre></td></tr></table></figure><ul><li>启用分层编译的情况下，触发 OSR 编译的阈值则由参数 -XX:TierXBackEdgeThreshold 指定的阈值乘以系数。</li><li>OSR 编译在<strong>正常的应用程序</strong>中<strong>不多见</strong>。它只在<strong>基准测试</strong>时比较<strong>常见</strong>。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：<strong>为什么不把所有代码都即时编译一下呢？这样程序的执行效率不是更快吗？</strong></p><p>A：即时编译是以方法为单位的。<strong>动态编译比较耗时</strong>，如果花了大量CPU资源编译出来的机器码运行不了几次，就很浪费了。</p><p>Q：为什么要用分层编译呢？<strong>使用最快的编译代码编译器编译的代码不是更好吗？</strong></p><p>A：<strong>机器码越快，需要的编译时间就越长。分层编译是一种折衷的方式</strong>，既能够满足部分不那么热的代码能够在短时间内编译完成，也能满足很热的代码能够拥有最好的优化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/14061" target="_blank" rel="noopener">https://time.geekbang.org/column/article/14061</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分层编译模式&quot;&gt;&lt;a href=&quot;#分层编译模式&quot; class=&quot;headerlink&quot; title=&quot;分层编译模式&quot;&gt;&lt;/a&gt;分层编译模式&lt;/h1&gt;&lt;h2 id=&quot;HotSpot-包含的即时编译器：&quot;&gt;&lt;a href=&quot;#HotSpot-包含的即时编译器：&quot; c
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的Git命令</title>
    <link href="http://yoursite.com/2018/10/21/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/21/一些简单的Git命令/</id>
    <published>2018-10-21T02:21:31.000Z</published>
    <updated>2018-10-21T12:00:09.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1><ul><li>Git 以校验和的方式检测数据完整性。</li><li>Git 中的 commit id 是校验和。</li></ul><h1 id="文件状态和工作区域"><a href="#文件状态和工作区域" class="headerlink" title="文件状态和工作区域"></a>文件状态和工作区域</h1><ul><li>工作区域：<ol><li>工作目录：写代码的区域。</li><li>暂存区：代码 add 后 commit 前所在的区域。</li><li>本地仓库：代码 commit 后所在的区域。</li></ol></li><li>文件状态：<ol><li>已修改：工作目录已修改，代码未 add。</li><li>已暂存：代码已 add，未 commit。</li><li>已提交：代码已 commit。</li></ol></li></ul><h1 id="用户身份"><a href="#用户身份" class="headerlink" title="用户身份"></a>用户身份</h1><ul><li><p>配置个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;example@email.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>查看个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></li></ul><h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><ul><li><p>初始化本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库克隆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone ssh/https地址</span><br></pre></td></tr></table></figure></li></ul><h1 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h1><ul><li><p>添加文件到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></li><li><p>添加所有文件到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure></li><li><p>提交暂存区文件到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;say something&quot;</span><br></pre></td></tr></table></figure></li></ul><p>加 -m 表示直接用后面的字符串作为说明，否则跳转编辑器</p><ul><li><p>查看本地仓库提交历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure></li><li><p>查看文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><ul><li>Changes to be committed：已暂存、可提交文件</li><li>Untracked files：未暂存文件</li></ul></li><li><p>查看未暂存文件变更细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure></li><li><p>查看已暂存文件变更细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br></pre></td></tr></table></figure></li></ul><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul><li><p>回到上一个版本（硬回退）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>回到上一个版本（软回退）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure></li></ul><ol><li>hard 移除仓库中的 commit，暂存区和工作区回到之前的状态。</li><li>soft 移除仓库中的 commit，暂存区和工作区不变。</li></ol><ul><li>查询版本提交记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></li></ul><p>①commit id ②执行的命令 ③描述</p><ul><li>回退到指定版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 提交Id</span><br></pre></td></tr></table></figure></li></ul><p>commit id 可以不填全部，git 自动查找。</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><ul><li><p>撤销未添加到暂存区的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --文件</span><br></pre></td></tr></table></figure></li><li><p>撤销已添加到暂存区的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD 文件</span><br></pre></td></tr></table></figure></li></ul><h1 id="删除相关操作"><a href="#删除相关操作" class="headerlink" title="删除相关操作"></a>删除相关操作</h1><ul><li><p>删除文件</p><ol><li><p>删除本地文件（文件管理器中删或用 <code>rm</code> 命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm 文件</span><br></pre></td></tr></table></figure></li><li><p>确认 git 删除工作区文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm 文件</span><br></pre></td></tr></table></figure></li><li><p>提交</p></li></ol></li><li><p>恢复文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --文件</span><br></pre></td></tr></table></figure><ul><li>可以恢复未添加到暂存区的修改了的文件</li><li>可以恢复自删除的文件</li></ul></li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li><p>关联远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add 自定义远程仓库名 ssh/https地址</span><br></pre></td></tr></table></figure></li><li><p>第一次推送本地仓库到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u 远程仓库名 远程仓库分支名</span><br></pre></td></tr></table></figure></li><li><p>非第一次推送本地仓库到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push 远程仓库名 远程仓库分支</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库拉取数据到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch 远程仓库名</span><br></pre></td></tr></table></figure></li><li><p>将从远程仓库拉取的数据和本地仓库合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge 本地分支名</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库拉取数据并合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull 远程仓库名 远程分支名</span><br></pre></td></tr></table></figure></li></ul><ol><li>fetch 只拉取远程仓库数据，不更新本地仓库状态。</li><li>pull 拉取远程仓库数据并更新本地仓库状态到远程仓库最新状态。</li><li>pull = fetch + merge</li></ol><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li><p>创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch 分支名</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><p>创建并切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 分支名</span><br></pre></td></tr></table></figure></li><li><p>查看分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch 分支名</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d 分支名</span><br></pre></td></tr></table></figure></li></ul><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><ul><li>解决冲突后不能提交某个文件，只能提交全部文件</li></ul><h1 id="变基（写的不完整，无参考价值）"><a href="#变基（写的不完整，无参考价值）" class="headerlink" title="变基（写的不完整，无参考价值）"></a>变基（写的不完整，无参考价值）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase 分支名</span><br></pre></td></tr></table></figure><ul><li>rebase 失败先解决冲突再执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure></li></ul><ol><li>变基抛弃原有提交，创建新的对应提交。</li><li>变基的提交历史是一条直线。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;完整性&quot;&gt;&lt;a href=&quot;#完整性&quot; class=&quot;headerlink&quot; title=&quot;完整性&quot;&gt;&lt;/a&gt;完整性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Git 以校验和的方式检测数据完整性。&lt;/li&gt;
&lt;li&gt;Git 中的 commit id 是校验和。&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-15Java语法糖与Java编译器</title>
    <link href="http://yoursite.com/2018/10/20/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8EJava%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>http://yoursite.com/2018/10/20/笔记-深入拆解Java虚拟机-15Java语法糖与Java编译器/</id>
    <published>2018-10-20T11:02:34.000Z</published>
    <updated>2018-10-20T13:02:37.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动装箱（auto-boxing）与自动拆箱（auto-unboxing）"><a href="#自动装箱（auto-boxing）与自动拆箱（auto-unboxing）" class="headerlink" title="自动装箱（auto-boxing）与自动拆箱（auto-unboxing）"></a>自动装箱（auto-boxing）与自动拆箱（auto-unboxing）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> result = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码对应的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int foo();</span><br><span class="line">  Code:</span><br><span class="line">     0: new java/util/ArrayList</span><br><span class="line">     3: dup</span><br><span class="line">     4: invokespecial java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     7: astore_1</span><br><span class="line">     8: aload_1</span><br><span class="line">     9: iconst_0</span><br><span class="line">    10: invokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">    13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line">    16: pop</span><br><span class="line">    17: aload_1</span><br><span class="line">    18: iconst_0</span><br><span class="line">    19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object;</span><br><span class="line">    22: checkcast java/lang/Integer</span><br><span class="line">    25: invokevirtual java/lang/Integer.intValue:()I</span><br><span class="line">    28: istore_2</span><br><span class="line">    29: iload_2</span><br><span class="line">    30: ireturn</span><br></pre></td></tr></table></figure><ul><li>向泛型参数为 Integer 的 ArrayList 添加 int 值，<strong>字节码中调用了 Integer.valueOf 方法</strong>。</li><li>从泛型参数为 Integer 的 ArrayList 取出元素，程序期待的是 int 值，<strong>字节码中调用了 Integer.intValue 方法</strong>。</li></ul><h1 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h1><ul><li>在字节码中，ArrayList 的 add 接受的参数类型是 Object，get 方法的返回类型是 Object。</li><li>get 方法<strong>强制向下转换类型</strong>。</li><li><strong>泛型信息</strong>在 JVM 中会<strong>全部擦除</strong>，为了兼容引入泛型之前的代码。</li><li>为限定继承类的泛型参数擦除为 Object，<strong>限定继承类</strong>的泛型参数<strong>擦除为所限定的类</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T foo(T);</span><br><span class="line">  descriptor: (Ljava/lang/Number;)Ljava/lang/Number;</span><br><span class="line">  flags: (0x0000)</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=2, args_size=2</span><br><span class="line">       0: aload_1</span><br><span class="line">       1: areturn</span><br><span class="line">  Signature: (TT;)TT;</span><br></pre></td></tr></table></figure><ul><li><strong>方法声明和方法签名（Signature）仍存在泛型参数信息</strong>，由 Java 编译器编译其他类时使用。</li></ul><h1 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h1><ul><li>桥接方法标识符包括 ACC_BRIDGE 和 ACC_SYNTHETIC（对于 Java 源代码不可见）。</li><li><strong>不能直接调用桥接方法，但可通过反射调用。</strong></li></ul><h2 id="泛型重写生成桥接方法"><a href="#泛型重写生成桥接方法" class="headerlink" title="泛型重写生成桥接方法"></a>泛型重写生成桥接方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merchant</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(T customer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span>&lt;<span class="title">VIP</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(VIP customer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>actionPrice 方法符合 Java 语言的方法重写。</li><li><p>不符合 JVM 方法重写的定义。<br>父类方法描述符(LCustomer)<br>子类方法描述符(LVIP)</p></li><li><p>为了<strong>保证编译的字节码能保留重写的语言</strong>，Java 编译器额外<strong>添加了桥接方法</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class VIPOnlyMerchant extends Merchant&lt;VIP&gt;</span><br><span class="line">...</span><br><span class="line">  public double actionPrice(VIP);</span><br><span class="line">    descriptor: (LVIP;)D</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">         0: dconst_0</span><br><span class="line">         1: dreturn</span><br><span class="line"></span><br><span class="line">  public double actionPrice(Customer);</span><br><span class="line">    descriptor: (LCustomer;)D</span><br><span class="line">    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: checkcast class VIP</span><br><span class="line">         5: invokevirtual actionPrice:(LVIP;)D</span><br><span class="line">         8: dreturn</span><br><span class="line"></span><br><span class="line">// 这个桥接方法等同于</span><br><span class="line">public double actionPrice(Customer customer) &#123;</span><br><span class="line">  return actionPrice((VIP) customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>桥接方法在字节码层面重写父类方法，并通过强制类型转换调用子类方法。</li></ul><h2 id="子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法"><a href="#子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法" class="headerlink" title="子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法"></a>子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class NaiveMerchant extends Merchant</span><br><span class="line">  public java.lang.Double actionPrice(Customer);</span><br><span class="line">    descriptor: (LCustomer;)Ljava/lang/Double;</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: dconst_0</span><br><span class="line">         1: invokestatic Double.valueOf:(D)Ljava/lang/Double;</span><br><span class="line">         4: areturn</span><br><span class="line"></span><br><span class="line">  public java.lang.Number actionPrice(Customer);</span><br><span class="line">    descriptor: (LCustomer;)Ljava/lang/Number;</span><br><span class="line">    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: invokevirtual actionPrice:(LCustomer;)Ljava/lang/Double;</span><br><span class="line">         5: areturn</span><br></pre></td></tr></table></figure><ul><li>JVM 允许两个同名、同参数类型、不同返回类型的方法。</li></ul><h1 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>循环从 0 到末尾逐一访问数组元素。</p><h2 id="Iterable-对象"><a href="#Iterable-对象" class="headerlink" title="Iterable 对象"></a>Iterable 对象</h2><p>循环调用 hasNext 和 next 方法 遍历元素。</p><h1 id="字符串-switch"><a href="#字符串-switch" class="headerlink" title="字符串 switch"></a>字符串 switch</h1><ul><li>case 比较字符串的哈希值。</li><li>哈希值相同的字符串用 equals 比较。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/13781" target="_blank" rel="noopener">https://time.geekbang.org/column/article/13781</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动装箱（auto-boxing）与自动拆箱（auto-unboxing）&quot;&gt;&lt;a href=&quot;#自动装箱（auto-boxing）与自动拆箱（auto-unboxing）&quot; class=&quot;headerlink&quot; title=&quot;自动装箱（auto-boxing）与
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-14Java虚拟机是怎么实现synchronized的？</title>
    <link href="http://yoursite.com/2018/10/17/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0synchronized%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/10/17/笔记-深入拆解Java虚拟机-14Java虚拟机是怎么实现synchronized的？/</id>
    <published>2018-10-17T06:08:55.000Z</published>
    <updated>2018-10-19T11:01:18.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li>声明 synchronized 的代码块，字节码包含 monitorenter 和 monitorexit 指令。</li><li>这两种指令会<strong>消耗</strong>操作数栈上的<strong>一个引用类型的元素</strong>。</li><li>这个元素是用来加解锁的锁对象。（synchronized 括号里的引用，实例方法是 this，静态方法是 class实例）。</li><li>用 synchronized 标记方法，字节码中方法的访问标记包括 ACC_SYNCHRONIZED。</li></ul><h1 id="monitorenter-和-monitorexit"><a href="#monitorenter-和-monitorexit" class="headerlink" title="monitorenter 和 monitorexit"></a>monitorenter 和 monitorexit</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以<strong>抽象</strong>地理解为<strong>每个锁对象</strong>有：</p><ol><li>一个锁<strong>计数器</strong></li><li>一个指向持有该锁的<strong>线程的指针</strong></li></ol><h2 id="执行-monitorenter"><a href="#执行-monitorenter" class="headerlink" title="执行 monitorenter"></a>执行 monitorenter</h2><ul><li><p>计数器为0</p><ul><li>说明没有被其他线程所持有。</li><li>锁对象的持有线程设置为当前线程。</li><li>计数器加 1。</li></ul></li><li><p>计数器不为0</p><ul><li>如果锁对象的持有当前线程，计数器加 1。</li><li>否则等待，直至锁释放。</li></ul></li></ul><h2 id="执行-monitorexit"><a href="#执行-monitorexit" class="headerlink" title="执行 monitorexit"></a>执行 monitorexit</h2><ul><li>锁对象的计数器减 1。</li><li>减为 0 时，锁被释放。</li></ul><h2 id="为什么采用计数器的方式？"><a href="#为什么采用计数器的方式？" class="headerlink" title="为什么采用计数器的方式？"></a>为什么采用计数器的方式？</h2><ul><li><strong>允许同一个线程重复获取同一把锁。</strong></li></ul><blockquote><p>HotSpot 虚拟机中具体的锁实现。</p></blockquote><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><ul><li>JVM中<strong>最基础</strong>的锁实现。</li><li>阻塞加锁失败的线程，锁被释放时唤醒。</li><li>阻塞及唤醒依靠操作系统完成，<strong>开销大</strong>。</li></ul><h2 id="自旋状态"><a href="#自旋状态" class="headerlink" title="自旋状态"></a>自旋状态</h2><ul><li>为了尽量<strong>避免昂贵的线程阻塞、唤醒操作</strong>。</li><li>在线程<strong>进入阻塞状态之前</strong>，或被<strong>唤醒后竞争不到锁</strong>的情况下<strong>进入自旋状态</strong>。</li><li><strong>在处理器上空跑</strong>并且轮询锁是否被释放。</li><li>与线程阻塞相比，<strong>自旋状态可能会浪费大量的处理器资源</strong>。</li><li>JVM 不能根据等待时间的长短来选择自旋还是阻塞。</li><li>JVM 采用<strong>自适应自旋</strong>，根据以往自旋等待时能否获得锁，<strong>动态调整自旋时间</strong>（循环数目）。</li></ul><h3 id="自旋状态的副作用：不公平的锁机制"><a href="#自旋状态的副作用：不公平的锁机制" class="headerlink" title="自旋状态的副作用：不公平的锁机制"></a>自旋状态的副作用：<strong>不公平的锁机制</strong></h3><ul><li>阻塞状态的线程，没有办法立刻竞争被释放的锁。</li><li>自旋状态的线程，很有可能优先获得锁。</li></ul><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><ul><li><strong>没有锁竞争的情况。</strong></li></ul><h2 id="怎样区分轻量级锁和重量级锁？"><a href="#怎样区分轻量级锁和重量级锁？" class="headerlink" title="怎样区分轻量级锁和重量级锁？"></a>怎样区分轻量级锁和重量级锁？</h2><p>对象头的标记字段（mark word）最后两位用来表示该对象的锁状态。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>00</td><td>轻量级锁</td></tr><tr><td>01</td><td>无锁或偏向锁</td></tr><tr><td>10</td><td>重量级锁</td></tr><tr><td>11</td><td>垃圾回收标记</td></tr></tbody></table><h2 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h2><p>判断是否是重量级锁</p><h3 id="判断为非重量级锁"><a href="#判断为非重量级锁" class="headerlink" title="判断为非重量级锁"></a>判断为非重量级锁</h3><ul><li>在当前线程的当前栈桢中划出一块空间作为该锁的锁记录。</li><li><strong>将锁对象的标记字段复制到锁记录中。</strong></li><li>JVM 尝试<strong>用 CAS 操作替换锁对象的标记字段</strong>。（不懂）<br>比较标记字段是否为X…X01<ul><li>是，替换为锁记录地址，成功获得锁，继续执行。</li><li>否<ul><li>线程重复获得同一把锁，JVM 将锁记录清理，代表锁被重复获取。</li><li><strong>其他线程持有锁，JVM 将该锁膨胀为重量级锁</strong>，阻塞该线程。</li></ul></li></ul></li></ul><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><h3 id="锁记录值为-0"><a href="#锁记录值为-0" class="headerlink" title="锁记录值为 0"></a>锁记录值为 0</h3><p>重复进入同一把锁，直接返回。（不懂）</p><h3 id="锁记录值不为-0"><a href="#锁记录值不为-0" class="headerlink" title="锁记录值不为 0"></a>锁记录值不为 0</h3><p>JVM 尝试用 CAS 操作比较标记字段是否为当前锁记录地址</p><ul><li>是，替换为锁记录的值，锁释放。</li><li>否，表示锁已膨胀为重量级锁，进入重量级锁释放过程。</li></ul><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><h2 id="加锁操作-1"><a href="#加锁操作-1" class="headerlink" title="加锁操作"></a>加锁操作</h2><ul><li>锁对象支持偏向锁。</li><li>JVM 通过 CAS 操作，将<strong>当前线程地址记录在锁对象的标记字段</strong>，将标记字段<strong>最后三位设为 101</strong>。</li></ul><h3 id="线程请求锁时"><a href="#线程请求锁时" class="headerlink" title="线程请求锁时"></a>线程请求锁时</h3><p>判断锁对象标记字段：</p><ol><li><strong>最后三位是否为 101</strong></li><li>是否<strong>包含当前线程的地址</strong></li><li>epoch 值是否<strong>和锁对象的类的 epoch 值相同</strong></li></ol><ul><li><p>都满足则当前线程持有该偏向锁，直接返回。</p></li><li><p>2 不满足，epoch 值相等时，JVM 需要撤销该偏向锁。</p></li><li><p>2 满足，epoch 值不等时，当前线程可以将该锁重偏向至自己。</p></li></ul><h2 id="epoch-值"><a href="#epoch-值" class="headerlink" title="epoch 值"></a>epoch 值</h2><ul><li>每个类维护一个 epoch 值。</li><li>设置偏向锁时，JVM 要将 epoch 值复制到锁对象标记字段中。</li><li><strong>撤销偏向锁</strong>要求持有偏向锁的<strong>线程到达安全点</strong>，再将偏向锁<strong>替换成轻量级锁</strong>。</li><li>某类锁对象<strong>撤销数超过一个阈值，JVM 宣布该类偏向锁失效</strong>。</li><li>宣布偏向锁失效时，JVM 将该类的 epoch 值加 1。</li><li>为了保证当前持有偏向锁并且已加锁的线程<strong>不丢锁</strong>，<ul><li>JVM <strong>遍历所有线程的 Java 栈</strong>，找出该类已加锁实例，</li><li>将标记字段的 epoch 值加 1（<strong>需要所有线程处于安全点状态</strong>）。</li></ul></li><li><strong>总撤销数超过另一个阈值</strong> JVM 认为<strong>这个类不再适合偏向锁</strong>。<ul><li>JVM 会<strong>撤销该类实例的偏向锁</strong>，</li><li>之后<strong>加锁直接设置轻量级锁</strong>。</li></ul></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/13530" target="_blank" rel="noopener">https://time.geekbang.org/column/article/13530</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;声明 synchronized 的代码块，字节码包含 monitorenter 和 monitorexit 指令。&lt;/li&gt;
&lt;li&gt;这两种指令会&lt;strong&gt;消耗&lt;/strong&gt;操作数栈上的&lt;strong&gt;一个引用类型的元素&lt;/strong&gt;。&lt;/li&gt;

      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-13Java内存模型</title>
    <link href="http://yoursite.com/2018/08/31/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/08/31/笔记-深入拆解Java虚拟机-13Java内存模型/</id>
    <published>2018-08-31T06:44:23.000Z</published>
    <updated>2018-08-31T07:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译器优化的重排序"><a href="#编译器优化的重排序" class="headerlink" title="编译器优化的重排序"></a>编译器优化的重排序</h1><ul><li>保证遵守 as-if-serial 属性。</li><li>操作之间存在数据依赖，不能调整顺序。</li></ul><h1 id="Java-内存模型与-happens-before-关系"><a href="#Java-内存模型与-happens-before-关系" class="headerlink" title="Java 内存模型与 happens-before 关系"></a>Java 内存模型与 happens-before 关系</h1><ul><li>用来描述两个操作的内存可见性。</li><li>操作 X happens-before 操作 Y，X 的结果对于 Y 可见。</li><li>happens-before 关系具有传递性。</li><li>解决这种数据竞争的关键：构造一个跨线程的 happens-before 关系。</li></ul><p>线程间的 happens-before 关系：</p><ol><li>解锁操作 happens-before 之后（时钟顺序）对同一把锁的加锁操作。</li><li>volatile 字段的写操作 happens-before 之后（时钟顺序）对同一字段的读操作。</li><li>线程的启动操作（Thread.starts()） happens-before 该线程的第一个操作。</li><li>线程的最后一个操作 happens-before 它的终止事件（Thread.isAlive() 或 Thread.join()）。</li><li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li><li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li></ol><h1 id="Java-内存模型的底层实现"><a href="#Java-内存模型的底层实现" class="headerlink" title="Java 内存模型的底层实现"></a>Java 内存模型的底层实现</h1><ul><li>通过内存屏障（memory barrier）禁止重排序。</li></ul><p>开不太懂，之后再看</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/13484" target="_blank" rel="noopener">https://time.geekbang.org/column/article/13484</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译器优化的重排序&quot;&gt;&lt;a href=&quot;#编译器优化的重排序&quot; class=&quot;headerlink&quot; title=&quot;编译器优化的重排序&quot;&gt;&lt;/a&gt;编译器优化的重排序&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;保证遵守 as-if-serial 属性。&lt;/li&gt;
&lt;li&gt;操作之间存
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-1112垃圾回收</title>
    <link href="http://yoursite.com/2018/08/29/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1112%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2018/08/29/笔记-深入拆解Java虚拟机-1112垃圾回收/</id>
    <published>2018-08-29T07:50:47.000Z</published>
    <updated>2018-08-31T06:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何辨别对象是否死亡"><a href="#如何辨别对象是否死亡" class="headerlink" title="如何辨别对象是否死亡"></a>如何辨别对象是否死亡</h1><h2 id="引用计数法（reference-counting）"><a href="#引用计数法（reference-counting）" class="headerlink" title="引用计数法（reference counting）"></a>引用计数法（reference counting）</h2><ul><li>为每个对象添加一个引用计数器。</li><li>为 0 时死亡。</li></ul><p>缺点：</p><ol><li>需要<strong>额外的空间</strong>。</li><li>更新操作<strong>繁琐</strong>。</li><li><strong>无法处理循环引用对象</strong>（a 与 b 相互引用）。</li></ol><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>GC Roots（由堆外指向堆内的引用）包括不限于：</p><ol><li>Java 方法栈桢中的局部变量。</li><li>已加载类的静态变量。</li><li>JNI handles。<strong>不懂</strong></li><li>已启动且未停止的 Java 线程。</li></ol><p>可达性分析算法：</p><ol><li>将一系列 GC Roots 作为初始的存活对象合集（live set）。</li><li>标记（mark）：从该合集出发，探索所有能够被该集合引用到的对象，将其加入到该集合中。</li><li>未被探索到的对象是死亡的，是可以回收的。</li></ol><p>需要解决的问题：</p><p>在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。</p><h1 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop-the-world"></a>Stop-the-world</h1><ul><li>停止其他非垃圾回收线程的工作，直到完成垃圾回收。</li><li>暂停时间（GC pause）。</li></ul><h1 id="安全点（safepoint）"><a href="#安全点（safepoint）" class="headerlink" title="安全点（safepoint）"></a>安全点（safepoint）</h1><blockquote><p>当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。</p></blockquote><h2 id="本地代码的安全点"><a href="#本地代码的安全点" class="headerlink" title="本地代码的安全点"></a>本地代码的安全点</h2><ul><li>Java 程序通过 JNI 执行<strong>本地代码</strong>时，这段代码<strong>不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法</strong>。</li><li><strong>API 入口处进行安全点检测</strong>（safepoint poll）。</li></ul><h2 id="解释执行字节码的安全点"><a href="#解释执行字节码的安全点" class="headerlink" title="解释执行字节码的安全点"></a>解释执行字节码的安全点</h2><ul><li><strong>字节码与字节码之间</strong>。</li><li>有安全点请求时，<strong>执行一条字节码进行一次安全点检测</strong>。</li></ul><h2 id="执行即时编译器生成的机器码"><a href="#执行即时编译器生成的机器码" class="headerlink" title="执行即时编译器生成的机器码"></a>执行即时编译器生成的机器码</h2><ul><li>生成机器码时，<strong>即时编译器插入安全点检测</strong>。</li><li>HotSpot 虚拟机：在生成代码的方法出口、非计数循环的循环回边（back-edge）处插入。</li></ul><h2 id="阻塞的线程属于安全点。"><a href="#阻塞的线程属于安全点。" class="headerlink" title="阻塞的线程属于安全点。"></a>阻塞的线程属于安全点。</h2><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h1><h2 id="清除（sweep）"><a href="#清除（sweep）" class="headerlink" title="清除（sweep）"></a>清除（sweep）</h2><blockquote><p>把死亡对象所占据的内存标记为空闲内存，记录在一个空闲列表（free list）中。</p></blockquote><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/11/sweep.png" alt="image"></p><p>缺点：</p><ol><li>造成<strong>内存碎片</strong>。</li><li>堆中对象必须是连续分布的，可能出现总空闲内存足够，无法分配的极端情况。</li><li>分配<strong>效率较低</strong>。</li></ol><h2 id="压缩（compact）"><a href="#压缩（compact）" class="headerlink" title="压缩（compact）"></a>压缩（compact）</h2><blockquote><p>把存活的对象聚集到内存区域的起始位置，留下一段连续的内存空间。</p></blockquote><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/11/compact.png" alt="image"></p><p>缺点：</p><ol><li>压缩算法有<strong>性能开销</strong>。</li></ol><h2 id="复制（copy）"><a href="#复制（copy）" class="headerlink" title="复制（copy）"></a>复制（copy）</h2><blockquote><p>把内存区域分为两等分，分别用两个指针 from 和 to 来维护，只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，把存活的对象复制到 to 指针指向的内存区域中，交换 from 指针和 to 指针的内容。</p></blockquote><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/11/copy.png" alt="image"></p><p>缺点：</p><p>1.堆空间的使用<strong>效率极其低下</strong>。</p><p>12未更新</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/13091" target="_blank" rel="noopener">https://time.geekbang.org/column/article/13091</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何辨别对象是否死亡&quot;&gt;&lt;a href=&quot;#如何辨别对象是否死亡&quot; class=&quot;headerlink&quot; title=&quot;如何辨别对象是否死亡&quot;&gt;&lt;/a&gt;如何辨别对象是否死亡&lt;/h1&gt;&lt;h2 id=&quot;引用计数法（reference-counting）&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-10Java对象的内存分布</title>
    <link href="http://yoursite.com/2018/08/29/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://yoursite.com/2018/08/29/笔记-深入拆解Java虚拟机-10Java对象的内存分布/</id>
    <published>2018-08-29T01:38:58.000Z</published>
    <updated>2018-08-29T02:36:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-新建对象的方式"><a href="#Java-新建对象的方式" class="headerlink" title="Java 新建对象的方式"></a>Java 新建对象的方式</h1><ul><li>new 语句</li><li>反射</li><li>Object.clone方法</li><li>反序列化</li><li>Unsafe.allocateInstance方法</li></ul><h1 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h1><h2 id="对象头（object-header）"><a href="#对象头（object-header）" class="headerlink" title="对象头（object header）"></a>对象头（object header）</h2><ul><li>每个 Java 对象都有。</li><li>由<strong>标记字段、类型指针</strong>构成。</li><li>标记字段：存储 Java 虚拟机有关该对象的运行数据（如哈希码、GC 信息、锁信息）。</li><li>类型指针：指向该对象的类。</li><li>64 位Java虚拟机中，对象头占 16 个字节。</li></ul><h2 id="压缩指针-1"><a href="#压缩指针-1" class="headerlink" title="压缩指针"></a>压缩指针</h2><ul><li>开启压缩指针：-XX:+UseCompressedOops（默认开启）。</li><li><strong>将堆中原本 64 位的 Java 对象指针压缩成 32 位。</strong></li><li>类型指针也被压缩成 32 位，<strong>对象头的大小从 16 字节降至 12 字节。</strong></li><li>还可以作用于<strong>引用类型的字段</strong>，<strong>引用类型数组</strong>。</li></ul><h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><ul><li>虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8。</li><li>默认情况，堆中对象（包括字段之间）起始地址要对齐至 8 的倍数。</li><li>浪费掉的空间称之为对象间的填充（padding）。</li><li>32 位压缩指针可以寻址到 2 的 35 次方个字节（32GB 地址空间，超过 32GB 会关闭压缩指针）。</li><li>压缩指针解引用：左移 3 位，再加上一个固定偏移量。</li><li>字段内存对齐的一个原因：<strong>让字段只出现在同一 CPU 的缓存行中</strong>。<strong>不懂</strong></li></ul><h1 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h1><ul><li>Java 虚拟机重新分配字段的顺序，达到内存对齐</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/13081" target="_blank" rel="noopener">https://time.geekbang.org/column/article/13081</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-新建对象的方式&quot;&gt;&lt;a href=&quot;#Java-新建对象的方式&quot; class=&quot;headerlink&quot; title=&quot;Java 新建对象的方式&quot;&gt;&lt;/a&gt;Java 新建对象的方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;new 语句&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;

      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>暑假、日剧、独身者、改变、目标</title>
    <link href="http://yoursite.com/2018/08/27/%E6%9A%91%E5%81%87%E3%80%81%E6%97%A5%E5%89%A7%E3%80%81%E7%8B%AC%E8%BA%AB%E8%80%85%E3%80%81%E6%94%B9%E5%8F%98%E3%80%81%E7%9B%AE%E6%A0%87/"/>
    <id>http://yoursite.com/2018/08/27/暑假、日剧、独身者、改变、目标/</id>
    <published>2018-08-27T04:47:04.000Z</published>
    <updated>2018-08-27T08:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018-8 大二暑假</p><p>暑假选择了留校，本来想等到 8 月 20 号再回去的，但是寝室里 N 多虫子，还在我腿上咬了 N 多坨，加上寝室经常停电停水， 8 月 7 号寝室对面突然搞装修，实在受不了，选择了回家。</p><p>一直以来，对自己以后的生活希望是可以成为一名独立开发者，一个人生活，一个人工作，没有任何人打扰。我以为自己一个人可以生活的很好。但是这个暑假，我的想法似乎动摇了。</p><p>我一直把自己归类为情感很淡的人，不喜欢说一些关心别人的话，我一直觉得很恶心，包括对自己的亲人。并且认为自己只是装作和身边的人关系很好的样子，分别后便没有任何关系，但是似乎好像并不是这样。</p><p>8 月 17 号，和最好的两个朋友出去聚了一次，感觉已经不是以前的那种感觉了，变的不是他们，是我。我变得越来越冷淡，和他们也越来越聊不起来，但是心里还是想着以后就一个人过最好。</p><p>在家是无法学习的，每天除了练车就没别的事，因为一些日剧演员再次将目光放在了《家族的形式》上，这部剧刚播出的时候就关注过，当时是因为里面有很多《朝 5 晚 9》的演员，看过几分钟觉得很无聊就没看了，这次是因为豆瓣的评分很高，所以决定再看一次。</p><p>首先这部剧的主角永里大介是一个人喜欢一人生活的人，他很享受自己一人的时间，并且认为人类之间的感情是麻烦的，这点和我非常像，我感觉他向往的生活和我向往的生活一样。后来因为一系列事情主角的爸爸常邀请他的朋友，大介的朋友同事，邻居一起聚会，我发现我很喜欢里面那种家人、朋友、同事、邻居一起吃饭很融洽的感觉。其实每次我都是这样，在校觉得别人好吵，放假太长又觉得孤单。以前觉得一个人在家看剧，一个人玩游戏，一个人出去吃东西看电影，一个人是很幸福的事情。但是现在真正只有一个人的时候有觉得很孤单，很后悔没有抓住以前的朋友。</p><p>原本打算考完科目三便来学校，和妈妈说后她很生气，说一暑假都没有陪她。当时正好看完《家族的形式》，想了很多，我给家人留的空间非常少，但以前又一直觉得自己不需要这些情感，觉得感情是一件很麻烦的事情，并且因为选择学习软件开发的原因，想要花大量时间学习，但想到 7 月刚放假留校那段时间，每天学习看剧无聊到爆，感觉一个人很孤单。突然很讨厌现在的自己，想要改变，和曾经的曾经一样珍惜每一段情感，不管是亲情还是友情。</p><p>又来也是在找日剧看的过程中，发现田中圭 2018 年有一部新剧《大叔之爱》，这部剧 2016 的时候出过一集 SP ，超级搞笑，因为人气比较高扩充了这个故事。当时只是当作一部搞笑的剧来看，看到后面发现自己很喜欢牧凌太这个角色，会做家务又会做饭，温柔又体贴，超级心动，感觉一下理解了那些女生看剧很心动的感觉。又想到 7 月在学校的时候，腿上被虫子咬，对寝室驱虫这件事很头疼。厕所很脏，洗澡也很不爽，但是又很怕脏，不想把它搞干净。在网上买了几大袋泡面，天天吃泡面吃到恶心（其实想过以后有自己的房子后学视频自己做菜吃，现在想想好像还比较遥远）。想到这些就希望自己有一个像牧凌太这样的居家型的男朋友，第一次有了想恋爱的感觉。作为同性恋以前一直对自己未来的对象很迷茫，不知道自己喜欢什么类型的，每次都是想以后就一个人过算了，但是因为这部剧，感觉知道了自己以后选择的标准，就是像牧凌太那样（可能和林遣都的长相有关系，但应该关系不大），刚看完感觉自己都像犯花痴了一样。</p><p>大二下过得很颓废，现在感觉又振作了起来，又有了精神，并且撇去之前抹掉情感的想法，不再是整天只知道敲代码的呆子程序员，生活也要变得有意思起来。</p><p>2018-08-27</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-8 大二暑假&lt;/p&gt;
&lt;p&gt;暑假选择了留校，本来想等到 8 月 20 号再回去的，但是寝室里 N 多虫子，还在我腿上咬了 N 多坨，加上寝室经常停电停水， 8 月 7 号寝室对面突然搞装修，实在受不了，选择了回家。&lt;/p&gt;
&lt;p&gt;一直以来，对自己以后的生活希望是可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-0809JVM是怎么实现invokedynamic的？</title>
    <link href="http://yoursite.com/2018/08/10/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0809JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/10/笔记-深入拆解Java虚拟机-0809JVM是怎么实现invokedynamic的？/</id>
    <published>2018-08-10T07:07:18.000Z</published>
    <updated>2018-08-29T01:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h1><ul><li>Java 7 引入的新指令</li><li>调用机制抽象出调用点的概念</li><li>允许将调用点链接至任意符合条件的方法上</li></ul><h1 id="MethodHandle（方法句柄）"><a href="#MethodHandle（方法句柄）" class="headerlink" title="MethodHandle（方法句柄）"></a>MethodHandle（方法句柄）</h1><ul><li>Java 7 引入</li><li>是一个强类型的，能被直接执行的引用</li><li>可以指向静态方法、实例方法、构造器、字段</li></ul><h2 id="方法句柄的类型（MethodType）"><a href="#方法句柄的类型（MethodType）" class="headerlink" title="方法句柄的类型（MethodType）"></a>方法句柄的类型（MethodType）</h2><ul><li>由参数类型、返回类型组成</li><li>确认方法句柄是否适配的唯一关键</li><li>不关心方法的类名或方法名</li></ul><h2 id="方法句柄的创建"><a href="#方法句柄的创建" class="headerlink" title="方法句柄的创建"></a>方法句柄的创建</h2><p>通过 MethodHandles.Lookup 类</p><ul><li>使用反射的 Method 类查找</li><li>Lookup.findStatic 查找调用 invokestatic 的方法</li><li>Lookup.findVirtual 查找调用 invokevirtual 和 invokeinterface 的方法</li><li>Lookup.findSpecial 查找调用 invokespecial 的方法</li></ul><h2 id="方法句柄的权限"><a href="#方法句柄的权限" class="headerlink" title="方法句柄的权限"></a>方法句柄的权限</h2><ul><li>权限检查在创建阶段完成</li><li>实际调用过程中不检查</li><li>取决于 Lookup 对象创建位置（不是方法句柄创建位置）</li></ul><h2 id="方法句柄的操作"><a href="#方法句柄的操作" class="headerlink" title="方法句柄的操作"></a>方法句柄的操作</h2><h3 id="invokeExact"><a href="#invokeExact" class="headerlink" title="invokeExact"></a>invokeExact</h3><ul><li>严格匹配参数类型（需要显示向上转型）</li><li>@PolymorphicSignature 根据传入参数的声明类型来生成方法描述符（而不是目标方法）</li></ul><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><ul><li>自动适配参数类型</li><li>会调用 MethodHandle.asType 方法生成一个适配器方法句柄</li></ul><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><p>通过生成另一个充当适配器的方法句柄来实现</p><p>捕获类型的 Lambda 表达式用增操作实现</p><p>增操作可以实现方法的柯里化</p><h2 id="方法句柄的实现"><a href="#方法句柄的实现" class="headerlink" title="方法句柄的实现"></a>方法句柄的实现</h2><p>HotSpot 虚拟机中方法句柄调用的具体实现，只讨论DirectMethodHandle</p><h3 id="invokeExact-1"><a href="#invokeExact-1" class="headerlink" title="invokeExact"></a>invokeExact</h3><ul><li>调用至一个共享的、与方法句柄类型相关的特殊适配器中</li><li>适配器是一个 LambdaForm</li></ul><h2 id="方法句柄的缺点"><a href="#方法句柄的缺点" class="headerlink" title="方法句柄的缺点"></a>方法句柄的缺点</h2><ul><li>与反射一样是简介调用</li><li>无法内联</li></ul><p><strong>未更新09</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;invokedynamic&quot;&gt;&lt;a href=&quot;#invokedynamic&quot; class=&quot;headerlink&quot; title=&quot;invokedynamic&quot;&gt;&lt;/a&gt;invokedynamic&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java 7 引入的新指令&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-07JVM是如何实现反射的？</title>
    <link href="http://yoursite.com/2018/08/06/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-07JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/06/笔记-深入拆解Java虚拟机-07JVM是如何实现反射的？/</id>
    <published>2018-08-06T06:33:36.000Z</published>
    <updated>2018-08-15T12:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射调用的实现"><a href="#反射调用的实现" class="headerlink" title="反射调用的实现"></a>反射调用的实现</h1><h2 id="Methond-invoke"><a href="#Methond-invoke" class="headerlink" title="Methond.invoke"></a>Methond.invoke</h2><p>委派给MethodAccessor接口处理。</p><p>MethodAccessor两个具体实现：</p><ol><li>本地方法实现反射调用</li><li>委派模式</li></ol><h2 id="委派实现"><a href="#委派实现" class="headerlink" title="委派实现"></a>委派实现</h2><ul><li>每个Method实例的<strong>第一次反射调用</strong>会生成一个委派实现。</li><li>委派的具体实现是一个<strong>本地实现</strong>。</li><li>Java的反射调用机制还设立了另一种动态生成字节码的<strong>动态实现</strong>。</li><li>采用委派实现，是为了能够在本地实现以及动态实现中切换。</li></ul><h3 id="动态实现"><a href="#动态实现" class="headerlink" title="动态实现"></a>动态实现</h3><ul><li><p><strong>运行效率比本地实现要快20倍。</strong><br>因为动态实现无需经过Java到C++再到Java的切换。</p></li><li><p>由于<strong>生成字节码十分耗时</strong>，仅<strong>调用一次</strong>的话，反而是<strong>本地实现要快上3到4倍</strong>。</p></li></ul><h3 id="Inflation"><a href="#Inflation" class="headerlink" title="Inflation"></a>Inflation</h3><p>Java虚拟机设置了一个阈值15（可以通过 -Dsun.reflect.inflationThreshold= 来调整）。<br>当某个反射调用的方法调用次数在 15 之下时，采用本地实现。<br>当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为Inflation。</p><p>反射调用的Inflation机制是可以通过参数（-Dsun.reflect.noInflation=true）关闭。<br>反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。</p><h1 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h1><h2 id="反射api性能开销"><a href="#反射api性能开销" class="headerlink" title="反射api性能开销"></a>反射api性能开销</h2><ul><li>Class.getMethod会遍历该类的公有方法。如果没有匹配到，遍历父类的公有方法。</li><li>以getMethod为代表的查找方法操作，会返回查找得到结果的一份拷贝。<br><strong>避免在热点代码中使用返回Method数组的方法，减少不必要的堆空间消耗。</strong></li></ul><h2 id="反射本身性能开销"><a href="#反射本身性能开销" class="headerlink" title="反射本身性能开销"></a>反射本身性能开销</h2><h3 id="Method-invoke是一个变长参数方法。"><a href="#Method-invoke是一个变长参数方法。" class="headerlink" title="Method.invoke是一个变长参数方法。"></a>Method.invoke是一个变长参数方法。</h3><p>Java编译器会在方法调用处生成一个长度为传入参数个数的Object数组，并将传入参数一一存储进该数组中。</p><h3 id="Java编译器会对传入的基本类型参数自动装箱。"><a href="#Java编译器会对传入的基本类型参数自动装箱。" class="headerlink" title="Java编译器会对传入的基本类型参数自动装箱。"></a>Java编译器会对传入的基本类型参数自动装箱。</h3><p>Java 缓存了 [-128, 127] 中所有整数所对应的 Integer 对象。<br>需要自动装箱的整数在这个范围之内时，返回缓存的 Integer，否则需要新建一个Integer对象。</p><p>解决方法：</p><ul><li><strong>扩大缓存范围</strong>（对应参数-Djava.lang.Integer.IntegerCache.high=128）。</li><li><strong>在外部缓存</strong>自动装箱得到的Integer对象。</li></ul><p><strong>上面两条除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。</strong></p><h3 id="权限检查带来的开销"><a href="#权限检查带来的开销" class="headerlink" title="权限检查带来的开销"></a>权限检查带来的开销</h3><ul><li>关闭权限检查。<br>setAccessible(true)</li></ul><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><ul><li>没有方法内联优化</li><li>逃逸分析不起效</li></ul><p>具体代码具体分析。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/12192" target="_blank" rel="noopener">https://time.geekbang.org/column/article/12192</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射调用的实现&quot;&gt;&lt;a href=&quot;#反射调用的实现&quot; class=&quot;headerlink&quot; title=&quot;反射调用的实现&quot;&gt;&lt;/a&gt;反射调用的实现&lt;/h1&gt;&lt;h2 id=&quot;Methond-invoke&quot;&gt;&lt;a href=&quot;#Methond-invoke&quot; cla
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-【工具篇】常用工具介绍</title>
    <link href="http://yoursite.com/2018/08/05/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E3%80%90%E5%B7%A5%E5%85%B7%E7%AF%87%E3%80%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/08/05/笔记-深入拆解Java虚拟机-【工具篇】常用工具介绍/</id>
    <published>2018-08-05T06:41:13.000Z</published>
    <updated>2018-08-15T12:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javap：查阅Java字节码"><a href="#javap：查阅Java字节码" class="headerlink" title="javap：查阅Java字节码"></a>javap：查阅Java字节码</h1><blockquote><p>javap是一个能够将class文件反汇编成人类可读格式的工具。</p></blockquote><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>追加打印私有字段和方法</td></tr><tr><td>-v</td><td>尽可能打印所有信息</td></tr><tr><td>-c</td><td>只打印方法</td></tr><tr><td>-g</td></tr></tbody></table><h2 id="v选项输出"><a href="#v选项输出" class="headerlink" title="-v选项输出"></a>-v选项输出</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>minor version: 0，major version: 54</td><td>class文件的版本号</td></tr><tr><td>flags: (0x0021) ACC_PUBLIC, ACC_SUPER</td><td>该类的访问权限</td></tr><tr><td>this_class: #7</td><td>该类名字</td></tr><tr><td>super_class: #8</td><td>父类名字</td></tr><tr><td>interfaces: 0</td><td>实现接口数目</td></tr><tr><td>fields: 4</td><td>字段数目</td></tr><tr><td>methods: 2</td><td>方法数目</td></tr><tr><td>attributes: 1</td><td>属性数目</td></tr></tbody></table><ul><li><p>属性：class文件所携带的辅助信息（class文件的源文件的名称）。<br>这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无须深入了解。</p></li><li><p>class文件的版本号：编译生成该class文件时所用的JRE版本。<br>由较新的JRE版本中的javac编译而成的class文件，不能在旧版本的JRE上跑，否则，会出现异常（java.lang.UnsupportedClassVersionError）。</p></li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li>每一项都有一个对应的索引（如 #1）。</li><li>可能引用其他的常量池项（#1 = Methodref #8.#23）。</li></ul><h3 id="字段区域"><a href="#字段区域" class="headerlink" title="字段区域"></a>字段区域</h3><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>descriptor: I</td><td>字段的类型</td></tr><tr><td>flags: (0x0002) ACC_PRIVATE</td><td>访问权限</td></tr></tbody></table><ul><li>声明为static final的基本类型或者字符串字段，字段区域包括它的常量值。</li></ul><h3 id="方法区域"><a href="#方法区域" class="headerlink" title="方法区域"></a>方法区域</h3><ul><li>方法描述符</li><li>访问权限</li><li>代码区域</li></ul><h4 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h4><h5 id="开头声明"><a href="#开头声明" class="headerlink" title="开头声明"></a>开头声明</h5><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>stack=2</td><td>操作数栈</td></tr><tr><td>locals=3</td><td>局部变量数目最大值</td></tr><tr><td>args_size=1</td><td>接收参数的个数</td></tr></tbody></table><ul><li>局部变量指的是字节码中的局部变量。</li><li>后面接着的是字节码，每条字节码均标注了对应的偏移量（bytecode index，BCI）。</li></ul><h5 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h5><ul><li>使用偏移量定位每个异常处理器所监控的范围（由 from 到 to 的代码区域）。</li><li>异常处理器的起始位置（target）。</li><li>声明所捕获的异常类型（type）。<br>any指代任意异常类型。</li></ul><h5 id="行数表"><a href="#行数表" class="headerlink" title="行数表"></a>行数表</h5><ul><li>Java源程序到字节码偏移量的映射。</li></ul><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><ul><li>Java程序中每个局部变量的名字、类型以及作用域。</li></ul><p>注：行数表和局部变量表均属于调试信息。Java虚拟机不要求class文件必备这些信息。</p><h5 id="字节码操作数栈映射表"><a href="#字节码操作数栈映射表" class="headerlink" title="字节码操作数栈映射表"></a>字节码操作数栈映射表</h5><ul><li>字节码跳转后操作数栈的分布情况。<br>一般被Java虚拟机用于验证所加载的类，和即时编译相关的一些操作，正常情况下，无须深入了解。</li></ul><h1 id="OpenJDK项目Code-Tools：实用小工具集"><a href="#OpenJDK项目Code-Tools：实用小工具集" class="headerlink" title="OpenJDK项目Code Tools：实用小工具集"></a>OpenJDK项目Code Tools：实用小工具集</h1><h2 id="ASMTools"><a href="#ASMTools" class="headerlink" title="ASMTools"></a>ASMTools</h2><h3 id="反汇编操作命令"><a href="#反汇编操作命令" class="headerlink" title="反汇编操作命令"></a>反汇编操作命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm</span><br></pre></td></tr></table></figure><h3 id="汇编操作命令"><a href="#汇编操作命令" class="headerlink" title="汇编操作命令"></a>汇编操作命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm</span><br></pre></td></tr></table></figure><h2 id="JOL"><a href="#JOL" class="headerlink" title="JOL"></a>JOL</h2><h3 id="查阅Java虚拟机中对象的内存分布"><a href="#查阅Java虚拟机中对象的内存分布" class="headerlink" title="查阅Java虚拟机中对象的内存分布"></a>查阅Java虚拟机中对象的内存分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap</span><br><span class="line">$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap</span><br></pre></td></tr></table></figure><h1 id="ASM：Java字节码框架"><a href="#ASM：Java字节码框架" class="headerlink" title="ASM：Java字节码框架"></a>ASM：Java字节码框架</h1><ul><li>ASM既可以生成新的class文件，也可以修改已有的class文件。</li><li>辅助类ASMifier，接收一个 class文件，输出一段生成该class文件原始字节数组的代码。</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tryBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> catchBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> finallyBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> methodExit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tryBlock = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            catchBlock = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finallyBlock = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        methodExit = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后用javap查阅字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">$ javac Foo.java</span><br><span class="line">$ javap -p -v Foo</span><br><span class="line">Classfile ../Foo.class</span><br><span class="line">  Last modified ..; size 541 bytes</span><br><span class="line">  MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d</span><br><span class="line">  Compiled from &quot;Foo.java&quot;</span><br><span class="line">public class Foo</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 54</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #7                          // Foo</span><br><span class="line">  super_class: #8                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 4, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #7.#24         // Foo.tryBlock:I</span><br><span class="line">   #3 = Fieldref           #7.#25         // Foo.finallyBlock:I</span><br><span class="line">   #4 = Class              #26            // java/lang/Exception</span><br><span class="line">   #5 = Fieldref           #7.#27         // Foo.catchBlock:I</span><br><span class="line">   #6 = Fieldref           #7.#28         // Foo.methodExit:I</span><br><span class="line">   #7 = Class              #29            // Foo</span><br><span class="line">   #8 = Class              #30            // java/lang/Object</span><br><span class="line">   #9 = Utf8               tryBlock</span><br><span class="line">  #10 = Utf8               I</span><br><span class="line">  #11 = Utf8               catchBlock</span><br><span class="line">  #12 = Utf8               finallyBlock</span><br><span class="line">  #13 = Utf8               methodExit</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               test</span><br><span class="line">  #19 = Utf8               StackMapTable</span><br><span class="line">  #20 = Class              #31            // java/lang/Throwable</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               Foo.java</span><br><span class="line">  #23 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = NameAndType        #9:#10         // tryBlock:I</span><br><span class="line">  #25 = NameAndType        #12:#10        // finallyBlock:I</span><br><span class="line">  #26 = Utf8               java/lang/Exception</span><br><span class="line">  #27 = NameAndType        #11:#10        // catchBlock:I</span><br><span class="line">  #28 = NameAndType        #13:#10        // methodExit:I</span><br><span class="line">  #29 = Utf8               Foo</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/Throwable</span><br><span class="line">&#123;</span><br><span class="line">  private int tryBlock;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  private int catchBlock;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  private int finallyBlock;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  private int methodExit;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  public Foo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iconst_0</span><br><span class="line">         2: putfield      #2                  // Field tryBlock:</span><br><span class="line">         5: aload_0</span><br><span class="line">         6: iconst_2</span><br><span class="line">         7: putfield      #3                  // Field finallyBlock:I</span><br><span class="line">        10: goto          35</span><br><span class="line">        13: astore_1</span><br><span class="line">        14: aload_0</span><br><span class="line">        15: iconst_1</span><br><span class="line">        16: putfield      #5                  // Field catchBlock:I</span><br><span class="line">        19: aload_0</span><br><span class="line">        20: iconst_2</span><br><span class="line">        21: putfield      #3                  // Field finallyBlock:I</span><br><span class="line">        24: goto          35</span><br><span class="line">        27: astore_2</span><br><span class="line">        28: aload_0</span><br><span class="line">        29: iconst_2</span><br><span class="line">        30: putfield      #3                  // Field finallyBlock:I</span><br><span class="line">        33: aload_2</span><br><span class="line">        34: athrow</span><br><span class="line">        35: aload_0</span><br><span class="line">        36: iconst_3</span><br><span class="line">        37: putfield      #6                  // Field methodExit:I</span><br><span class="line">        40: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0     5    13   Class java/lang/Exception</span><br><span class="line">             0     5    27   any</span><br><span class="line">            13    19    27   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">        line 14: 10</span><br><span class="line">        line 10: 13</span><br><span class="line">        line 11: 14</span><br><span class="line">        line 13: 19</span><br><span class="line">        line 14: 24</span><br><span class="line">        line 13: 27</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 35</span><br><span class="line">        line 16: 40</span><br><span class="line">      StackMapTable: number_of_entries = 3</span><br><span class="line">        frame_type = 77 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = 77 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 7 /* same */</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Foo.java&quot;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/12423" target="_blank" rel="noopener">https://time.geekbang.org/column/article/12423</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javap：查阅Java字节码&quot;&gt;&lt;a href=&quot;#javap：查阅Java字节码&quot; class=&quot;headerlink&quot; title=&quot;javap：查阅Java字节码&quot;&gt;&lt;/a&gt;javap：查阅Java字节码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;javap
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LayoutInflater中inflate方法各参数作用</title>
    <link href="http://yoursite.com/2018/08/03/LayoutInflater%E4%B8%ADinflate%E6%96%B9%E6%B3%95%E5%90%84%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/03/LayoutInflater中inflate方法各参数作用/</id>
    <published>2018-08-03T07:52:33.000Z</published>
    <updated>2018-08-15T12:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、三个参数的方法"><a href="#1、三个参数的方法" class="headerlink" title="1、三个参数的方法"></a>1、三个参数的方法</h1><p>inflate(@LayoutRes int, @Nullable ViewGroup, boolean):View</p><h2 id="1-1第二个参数不为null且第三个参数为true"><a href="#1-1第二个参数不为null且第三个参数为true" class="headerlink" title="1.1第二个参数不为null且第三个参数为true"></a>1.1第二个参数不为null且第三个参数为true</h2><ul><li>指定id布局根布局节点各个属性有效</li><li>添加到父布局</li></ul><h2 id="1-2第二个参数不为null且第三个参数为false"><a href="#1-2第二个参数不为null且第三个参数为false" class="headerlink" title="1.2第二个参数不为null且第三个参数为false"></a>1.2第二个参数不为null且第三个参数为false</h2><ul><li>指定id布局根布局节点各个属性有效</li><li>不添加到父布局</li></ul><h2 id="1-3第二各参数为null"><a href="#1-3第二各参数为null" class="headerlink" title="1.3第二各参数为null"></a>1.3第二各参数为null</h2><ul><li>指定id布局根布局节点宽高属性无效</li></ul><h1 id="2、两个参数的方法"><a href="#2、两个参数的方法" class="headerlink" title="2、两个参数的方法"></a>2、两个参数的方法</h1><p>inflate(@LayoutRes int, @Nullable ViewGroup):View</p><h2 id="2-1第二个参数不为null"><a href="#2-1第二个参数不为null" class="headerlink" title="2.1第二个参数不为null"></a>2.1第二个参数不为null</h2><p>等同于1.1</p><h2 id="2-2第二个参数为null"><a href="#2-2第二个参数为null" class="headerlink" title="2.2第二个参数为null"></a>2.2第二个参数为null</h2><p>等同于1.3</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.csdn.net/u012702547/article/details/52628453" target="_blank" rel="noopener">https://blog.csdn.net/u012702547/article/details/52628453</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、三个参数的方法&quot;&gt;&lt;a href=&quot;#1、三个参数的方法&quot; class=&quot;headerlink&quot; title=&quot;1、三个参数的方法&quot;&gt;&lt;/a&gt;1、三个参数的方法&lt;/h1&gt;&lt;p&gt;inflate(@LayoutRes int, @Nullable ViewGrou
      
    
    </summary>
    
      <category term="Android视图" scheme="http://yoursite.com/categories/Android%E8%A7%86%E5%9B%BE/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java中进制转换</title>
    <link href="http://yoursite.com/2018/08/03/Java%E4%B8%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/08/03/Java中进制转换/</id>
    <published>2018-08-03T02:19:26.000Z</published>
    <updated>2018-08-15T12:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十进制转二、八、十六进制"><a href="#十进制转二、八、十六进制" class="headerlink" title="十进制转二、八、十六进制"></a>十进制转二、八、十六进制</h1><p>Integer.toBinaryString():String<br>Integer.toOctalString():String<br>Integer.toHexString():String</p><p>返回值为字符串。</p><h1 id="任意进制转十进制"><a href="#任意进制转十进制" class="headerlink" title="任意进制转十进制"></a>任意进制转十进制</h1><p>Integer.valueOf(String,int):Integer<br>Integer.parseInt(String,int):int</p><p>第二个参数指定基数，将字符串参数解析为有符号的整数。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;十进制转二、八、十六进制&quot;&gt;&lt;a href=&quot;#十进制转二、八、十六进制&quot; class=&quot;headerlink&quot; title=&quot;十进制转二、八、十六进制&quot;&gt;&lt;/a&gt;十进制转二、八、十六进制&lt;/h1&gt;&lt;p&gt;Integer.toBinaryString():Strin
      
    
    </summary>
    
      <category term="进制转换" scheme="http://yoursite.com/categories/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="进制转换" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android透明状态栏与沉浸模式总结</title>
    <link href="http://yoursite.com/2018/08/02/Android%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E6%B2%89%E6%B5%B8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/02/Android透明状态栏与沉浸模式总结/</id>
    <published>2018-08-02T12:02:51.000Z</published>
    <updated>2018-08-15T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h1><p>通过Java代码实现的思路是通过当前界面DecorView设置UI可见性实现。</p><table><thead><tr><th>flag</th><th>作用</th></tr></thead><tbody><tr><td>SYSTEM_UI_FLAG_FULLSCREEN</td><td>请求进入普通全屏模式</td></tr><tr><td>SYSTEM_UI_FLAG_HIDE_NAVIGATION</td><td>请求暂时隐藏系统导航栏</td></tr><tr><td>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</td><td></td></tr><tr><td>SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</td><td></td></tr><tr><td>SYSTEM_UI_FLAG_LAYOUT_STABLE</td><td>当使用其他布局标志时，提供内容插入的稳定视图</td></tr><tr><td>SYSTEM_UI_FLAG_IMMERSIVE_STICKY</td></tr></tbody></table><p>通过组合上面的6中flag实现各种效果</p><h2 id="隐藏状态栏"><a href="#隐藏状态栏" class="headerlink" title="隐藏状态栏"></a>隐藏状态栏</h2><p>支持Android4.1及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = View.SYSTEM_UI_FLAG_FULLSCREEN;</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(option);</span><br></pre></td></tr></table></figure><p>注：下滑顶部会重新显示</p><h2 id="透明状态栏"><a href="#透明状态栏" class="headerlink" title="透明状态栏"></a>透明状态栏</h2><p>支持Android5.0及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(option);</span><br><span class="line">getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br></pre></td></tr></table></figure><h2 id="隐藏状态栏及导航栏"><a href="#隐藏状态栏及导航栏" class="headerlink" title="隐藏状态栏及导航栏"></a>隐藏状态栏及导航栏</h2><p>支持Android4.1及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(option);</span><br></pre></td></tr></table></figure><p>注：点击屏幕会退出全屏</p><h2 id="透明状态栏及透明导航栏"><a href="#透明状态栏及透明导航栏" class="headerlink" title="透明状态栏及透明导航栏"></a>透明状态栏及透明导航栏</h2><p>支持Android5.0及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = <span class="keyword">int</span> option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(option);</span><br><span class="line">getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">getWindow().setNavigationBarColor(Color.TRANSPARENT);</span><br></pre></td></tr></table></figure><h2 id="沉浸模式"><a href="#沉浸模式" class="headerlink" title="沉浸模式"></a>沉浸模式</h2><p>支持Android4.4及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(option);</span><br></pre></td></tr></table></figure><p>注：滑动状态栏或导航栏的位置显示状态栏和导航栏，一段时间未操作再次隐藏</p><h1 id="XML实现"><a href="#XML实现" class="headerlink" title="XML实现"></a>XML实现</h1><p>通过设置activity的style实现</p><h2 id="隐藏状态栏-1"><a href="#隐藏状态栏-1" class="headerlink" title="隐藏状态栏"></a>隐藏状态栏</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowFullscreen"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="透明状态栏-1"><a href="#透明状态栏-1" class="headerlink" title="透明状态栏"></a>透明状态栏</h2><p>Android4.4</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"fullScreenTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentNavigation"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果添加了DrawerLayout需要设置，否则DrawerLayout部分状态栏是灰色的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mDrawerLayout.setFitsSystemWindows(<span class="keyword">true</span>);</span><br><span class="line">mDrawerLayout.setClipToPadding(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>Android5.0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"fullScreenTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentNavigation"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://blog.csdn.net/guolin_blog/article/details/51763825" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/51763825</a></li><li><a href="https://blog.csdn.net/do168/article/details/51587935" target="_blank" rel="noopener">https://blog.csdn.net/do168/article/details/51587935</a></li><li><a href="https://blog.csdn.net/tc_xingdechen/article/details/68958337" target="_blank" rel="noopener">https://blog.csdn.net/tc_xingdechen/article/details/68958337</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java实现&quot;&gt;&lt;a href=&quot;#Java实现&quot; class=&quot;headerlink&quot; title=&quot;Java实现&quot;&gt;&lt;/a&gt;Java实现&lt;/h1&gt;&lt;p&gt;通过Java代码实现的思路是通过当前界面DecorView设置UI可见性实现。&lt;/p&gt;
&lt;table&gt;
&lt;t
      
    
    </summary>
    
      <category term="Android视图" scheme="http://yoursite.com/categories/Android%E8%A7%86%E5%9B%BE/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="状态栏" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    
      <category term="沉静模式" scheme="http://yoursite.com/tags/%E6%B2%89%E9%9D%99%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="透明" scheme="http://yoursite.com/tags/%E9%80%8F%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>获取Activity根布局</title>
    <link href="http://yoursite.com/2018/08/01/%E8%8E%B7%E5%8F%96Activity%E6%A0%B9%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/08/01/获取Activity根布局/</id>
    <published>2018-08-01T12:47:40.000Z</published>
    <updated>2018-08-15T12:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findViewById(android.R.id.content).getChildAt(<span class="number">0</span>)；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Android布局" scheme="http://yoursite.com/categories/Android%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何修改ActionBar的字体颜色？</title>
    <link href="http://yoursite.com/2018/08/01/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9ActionBar%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/01/如何修改ActionBar的字体颜色？/</id>
    <published>2018-08-01T10:22:46.000Z</published>
    <updated>2018-08-15T12:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"actionBarStyle"</span>&gt;</span>@style/ActionBarStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ActionBarStyle"</span> <span class="attr">parent</span>=<span class="string">"@style/Widget.AppCompat.ActionBar.Solid"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"titleTextStyle"</span>&gt;</span>@style/TitleTextStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"TitleTextStyle"</span> <span class="attr">parent</span>=<span class="string">"@style/TextAppearance.AppCompat.Widget.ActionBar.Title"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>#000000<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 这里设置ActionBar字体颜色 --&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="Android视图" scheme="http://yoursite.com/categories/Android%E8%A7%86%E5%9B%BE/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ActionBar" scheme="http://yoursite.com/tags/ActionBar/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-06JVM是如何处理异常的？</title>
    <link href="http://yoursite.com/2018/08/01/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-06JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/01/笔记-深入拆解Java虚拟机-06JVM是如何处理异常的？/</id>
    <published>2018-08-01T06:41:48.000Z</published>
    <updated>2018-08-29T07:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h1><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/06/throwable.png" alt="image"></p><ul><li><p>Error：涵盖程序不应捕获的异常（JVM抛出）。<br>程序出发Error时，执行状态已经无法恢复，需要终止线程甚至终止虚拟机。</p></li><li><p>Exception：涵盖程序可能需要捕获且处理的异常。</p></li><li>RuntimeException：表示“程序虽然无法继续执行，但是还能抢救一下”的情况。</li><li><strong>RuntimeException和Error非检查异常（unchecked exception）。其他异常属于检查异常（checked exception）。</strong></li><li>检查异常需要程序显式地捕获，或者在方法声明中用throws关键字再次抛出。</li></ul><h2 id="常实例的构造十分昂贵。"><a href="#常实例的构造十分昂贵。" class="headerlink" title="常实例的构造十分昂贵。"></a>常实例的构造十分昂贵。</h2><p>在构造异常实例时，Java虚拟机需要<strong>生成该异常的栈轨迹</strong>（stack trace）。</p><ul><li>逐一访问当前线程的Java栈帧。</li><li>记录下各种调试信息（方法名，方法所在类名，文件名，代码中第几行）。</li><li>Java虚拟机会<strong>忽略异常构造器和填充栈帧的Java方法</strong>（Throwable.fillInStackTrace），直接从新建异常位置开始算起。</li><li>Java虚拟机会<strong>忽略标记为不可见的Java方法栈帧</strong>。</li></ul><h3 id="是否可以缓存异常实例，在需要用到的时候直接抛出？"><a href="#是否可以缓存异常实例，在需要用到的时候直接抛出？" class="headerlink" title="是否可以缓存异常实例，在需要用到的时候直接抛出？"></a>是否可以缓存异常实例，在需要用到的时候直接抛出？</h3><ul><li>从语法角度上，是允许的。</li><li><strong>对应的栈轨迹并非throw语句的位置，而是新建异常的位置。</strong></li></ul><h1 id="Java虚拟机是如何捕获异常的？"><a href="#Java虚拟机是如何捕获异常的？" class="headerlink" title="Java虚拟机是如何捕获异常的？"></a>Java虚拟机是如何捕获异常的？</h1><p>编译生成的字节码中，<strong>每个方法都附带一个异常表</strong>。</p><p>异常表中每一个条目代表一个异常处理器。</p><p>异常处理器的组成：</p><ul><li>from指针</li><li>to指针</li><li>target指针</li><li>所捕获的异常类型</li></ul><p>注：指针的值是字节码索引（bytecode index，bci），用来定位字节码。</p><p><strong>from指针和to指针：标示异常处理器所监控的范围（如try代码块范围）。</strong></p><p><strong>target指针：指向异常处理器的起始位置（如catch代码块起始位置）。</strong></p><h2 id="触发异常的处理流程"><a href="#触发异常的处理流程" class="headerlink" title="触发异常的处理流程"></a>触发异常的处理流程</h2><ol><li>Java虚拟机<strong>从上至下遍历异常表</strong>中的所有条目。</li><li><strong>触发异常</strong>的字节码的索引值<strong>在某个异常表条目的监控范围内</strong>，Java虚拟机判断所抛出的异常和该条目想要捕获的异常<strong>是否匹配</strong>。</li><li>如果<strong>匹配</strong>，Java 虚拟机将控制流<strong>转移至该条目target指针指向</strong>的字节码。</li><li>如果<strong>遍历完所有</strong>异常表条目，仍<strong>未匹配</strong>到异常处理器，<strong>弹出当前方法对应的Java栈帧，在调用者（caller）中重复上述操作</strong>。</li><li>finally代码块的编译，当前版本Java编译器，是<strong>复制finally代码块的内容，分别放在try-catch代码块所有正常执行路径和异常执行路径的出口中</strong>。</li></ol><p><img src="http://pcrioz2ch.bkt.clouddn.com/JVM/06/trigger_exception.png" alt="iamge"></p><p>针对异常执行路径，Java编译器会生成一个或多个异常表条目，监控整个try-catch代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。</p><p>这些异常表条目的 target 指针将指向另一份复制的finally代码块。</p><p>在这个finally代码块的最后，Java编译器会重新抛出所捕获的异常。</p><p><strong>如果catch代码块捕获了异常，并且触发了另一个异常，那么finally捕获并且重抛后者，忽略前者。</strong></p><h1 id="Java7的Suppressed异常以及语法糖"><a href="#Java7的Suppressed异常以及语法糖" class="headerlink" title="Java7的Suppressed异常以及语法糖"></a>Java7的Suppressed异常以及语法糖</h1><h2 id="Suppressed异常"><a href="#Suppressed异常" class="headerlink" title="Suppressed异常"></a>Suppressed异常</h2><p>允许将一个异常附于另一个异常之上。</p><p><strong>抛出的异常可以附带多个异常信息。</strong></p><p>finally代码块缺少指向所捕获异常的引用，这个新特性使用起来非常繁琐。</p><h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (  ); <span class="comment">// try-with-resources</span></span><br></pre></td></tr></table></figure><p>在字节码层面自动使用Suppressed异常。</p><p><strong>自动关闭资源</strong>（实现AutoCloseable接口）。</p><h2 id="同一catch代码块捕获多种异常"><a href="#同一catch代码块捕获多种异常" class="headerlink" title="同一catch代码块捕获多种异常"></a>同一catch代码块捕获多种异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">catch</span> (SomeException | OtherException e) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/12134" target="_blank" rel="noopener">https://time.geekbang.org/column/article/12134</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常的基本概念&quot;&gt;&lt;a href=&quot;#异常的基本概念&quot; class=&quot;headerlink&quot; title=&quot;异常的基本概念&quot;&gt;&lt;/a&gt;异常的基本概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://pcrioz2ch.bkt.clouddn.com/JVM/06/
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[转]传输层和应用层的协议和作用</title>
    <link href="http://yoursite.com/2018/08/01/%E8%BD%AC-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/01/转-传输层和应用层的协议和作用/</id>
    <published>2018-07-31T16:03:07.000Z</published>
    <updated>2018-08-29T07:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载请注明出处：<a href="https://blog.csdn.net/DarkAngel1228/article/details/78581019" target="_blank" rel="noopener">https://blog.csdn.net/DarkAngel1228/article/details/78581019</a></p></blockquote><h1 id="TCP-IP传输层概述"><a href="#TCP-IP传输层概述" class="headerlink" title="TCP/IP传输层概述"></a>TCP/IP传输层概述</h1><p>TCP/IP是指一整套数据通信协议，传输层完成端到端的连接和传输。</p><h2 id="TCP-IP传输层包含的两个协议"><a href="#TCP-IP传输层包含的两个协议" class="headerlink" title="TCP/IP传输层包含的两个协议"></a>TCP/IP传输层包含的两个协议</h2><ul><li><p>传输控制协议<br>Transmission Control Protocol —— TCP</p></li><li><p>用户数据报协议<br>User Dategram Protocol —— UDP</p></li></ul><h2 id="常用的TCP端口及应用"><a href="#常用的TCP端口及应用" class="headerlink" title="常用的TCP端口及应用"></a>常用的TCP端口及应用</h2><p>TCP在网络中使用的范围很广，下面将列出一些常用的端口号及其功能.以便进一步对TCP进行检测和管理。</p><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td>80</td><td>http</td><td>web服务器所开放的进程端口,用于客户端http访问</td></tr><tr><td>21</td><td>FTP</td><td>FTP服务器所开放的控制端口,用于上传下载</td></tr><tr><td>23</td><td>Telnet</td><td>用于远程登录,通过连接目的计算机的这一端口,得到验证后可以远程控制管理目标计算机</td></tr><tr><td>25</td><td>SMTP</td><td>SMTP服务器开放的端口,用于发送邮件</td></tr><tr><td>53</td><td>DNS</td><td>DNS服务器开放的端口,当用户输入网站的名称后,由DNS负责将它解析成IP地址,这个过程中用到的端口号就是53</td></tr></tbody></table><h2 id="常用的UDP端口及应用"><a href="#常用的UDP端口及应用" class="headerlink" title="常用的UDP端口及应用"></a>常用的UDP端口及应用</h2><table><thead><tr><th>端口</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td>7</td><td>Echo</td><td>将收到的数据包回送到发送器</td></tr><tr><td>53</td><td>Nameserver</td><td>域名服务</td></tr><tr><td>69</td><td>TFTP</td><td>简单文件传输协议</td></tr><tr><td>111</td><td>RPC</td><td>远程过程调用</td></tr><tr><td>123</td><td>NTP</td><td>网络时间协议</td></tr></tbody></table><h1 id="常用的应用层协议"><a href="#常用的应用层协议" class="headerlink" title="常用的应用层协议"></a>常用的应用层协议</h1><table><thead><tr><th>缩写</th><th>全文</th></tr></thead><tbody><tr><td>http</td><td>超文本传送协议</td></tr><tr><td>https</td><td>基于安全套接字层的http协议</td></tr><tr><td>ftp</td><td>文件传输协议</td></tr><tr><td>dns</td><td>域名系统</td></tr><tr><td>smtp</td><td>邮件传输协议</td></tr><tr><td>pop3</td><td>邮局协议</td></tr><tr><td>ssh</td><td>安全外壳协议</td></tr></tbody></table><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>用于传输Internet浏览器使用的普通文本,超文本,音频和视频等数据<br>端口号：TCP的80</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>基于HTTP开发,提供加密,可以确保消息的私有性和完整性<br>端口号：443</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>用于传输文件<br>端口号：TCP的21和20</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>用来完成域名和IP地址之间的映射<br>端口号：TCP或UDP的53</p><p><img src="http://pcrioz2ch.bkt.clouddn.com/network/DNS.png" alt="image"></p><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>用于发送和接收邮件<br>端口号：25</p><h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><p>用于客户端接收邮件<br>端口号：110</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>建立在应用层和传输层基础上的安全协议，ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用ssh协议可以有效防止远程管理过程中的信息泄漏问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://blog.csdn.net/DarkAngel1228/article/details/78581019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.c
      
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-0405JVM是如何执行方法调用的？</title>
    <link href="http://yoursite.com/2018/07/30/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0405JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/30/笔记-深入拆解Java虚拟机-0405JVM是如何执行方法调用的？/</id>
    <published>2018-07-30T07:41:36.000Z</published>
    <updated>2018-08-15T12:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><p>在Java程序里，同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。这个限制可以通过字节码工具绕开。在编译完成之后，可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。</p><h2 id="重载的方法在编译过程中即可完成识别"><a href="#重载的方法在编译过程中即可完成识别" class="headerlink" title="重载的方法在编译过程中即可完成识别"></a>重载的方法在编译过程中即可完成识别</h2><p>Java编译器<strong>根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法</strong>：</p><ol><li>在<strong>不考虑对基本类型自动装拆箱</strong>（auto-boxing，auto-unboxing）和<strong>可变长参数</strong>的情况下选取重载方法。</li><li>在<strong>允许自动装拆箱</strong>，但<strong>不允许可变长参数</strong>的情况下选取重载方法。</li><li>在<strong>允许自动装拆箱和可变长参数</strong>的情况下选取重载方法。</li></ol><p>如果Java编译器在同一阶段<strong>多种适配方法</strong>，会在其中<strong>选择一个最贴切的</strong>方法。</p><p><strong>决定贴切程度</strong>的关键之一是形式参数类型的<strong>继承关系</strong>。</p><h2 id="重载可以作用于这个类所继承而来的方法"><a href="#重载可以作用于这个类所继承而来的方法" class="headerlink" title="重载可以作用于这个类所继承而来的方法"></a>重载可以作用于这个类所继承而来的方法</h2><p>如果<strong>子类定义了与父类中非私有方法同名的方法</strong>，而且这两个方法的<strong>参数类型不同</strong>，那么在子类中，这两个方法同样<strong>构成了重载</strong>。</p><p>如果<strong>子类定义了与父类中非私有方法同名的方法</strong>，而且这两个<strong>方法的参数类型相同</strong>：</p><ul><li>如果这两个方法<strong>都是静态的</strong>，那么子类中的方法<strong>隐藏</strong>了父类中的方法。</li><li>如果这两个方法<strong>都不是静态的，且都不是私有的</strong>，那么子类的方法<strong>重写</strong>了父类中的方法（重写可以扩大访问权限，但不能缩小）。</li></ul><p>注：如果子类定义了与父类中私有方法同名的方法，这两个方法之间没有任何关系。</p><h1 id="JVM的静态绑定和动态绑定"><a href="#JVM的静态绑定和动态绑定" class="headerlink" title="JVM的静态绑定和动态绑定"></a>JVM的静态绑定和动态绑定</h1><p><strong>Java虚拟机识别方法的关键：类名、方法名和方法描述符（method descriptor）。</strong></p><p>方法描述符 = 方法的参数类型+返回类型所构成</p><p>在同一个类中，</p><ul><li><p>出现多个名字相同且描述符也相同的方法<br>Java虚拟机在类的验证阶段报错。</p></li><li><p><strong>不限制名字与参数类型相同但返回类型不同的方法出现。</strong></p></li></ul><p>Java虚拟机判定方法重写：</p><ul><li>子类定义了与父类中<strong>非私有、非静态方法</strong>同名的方法。</li><li><strong>方法名和方法描述符都相同</strong>。</li></ul><p>Java语言中重写而Java虚拟机中非重写的情况：</p><ul><li>编译器通过生成<strong>桥接方法</strong>来实现Java中的重写语义。</li></ul><p>重载方法的区分在编译阶段已经完成，可以认为Java虚拟机不存在重载概念。</p><p>Java编译器会将<strong>所有对非私有实例方法的调用</strong>编译为需要<strong>动态绑定</strong>的类型。</p><p>Java虚拟机中的静态绑定：在解析时便能够直接识别目标方法。</p><p>Java虚拟机中的动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法。</p><p>Java字节码中与调用相关的指令共有五种：</p><ul><li>invokestatic：用于调用静态方法。</li><li>invokespecial：用于调用私有实例方法、构造器，使用super调用父类的实例方法或构造器，和所实现接口的默认方法。</li><li>invokevirtual：用于调用非私有实例方法。</li><li>invokeinterface：用于调用接口方法。</li><li>invokedynamic：用于调用动态方法。</li></ul><p>invokestatic和invokespecial：Java虚拟机能够<strong>直接识别</strong>具体的目标方法（静态绑定）。</p><p>invokevirtual和invokeinterface：在绝大部分情况下，虚拟机需要<strong>在执行过程中根据调用者的动态类型，来确定</strong>具体的目标方法（动态绑定）。</p><p>例外：如果虚拟机能够确定目标方法有且仅有一个（如目标方法被标记为final），可以不通过动态类型，直接确定目标方法（虚拟机可以静态绑定该方法）。</p><h1 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h1><p>符号引用存储在 class 文件的常量池之中。</p><p>符号引用分为：接口符号引用和非接口符号引用。</p><h2 id="非接口符号引用"><a href="#非接口符号引用" class="headerlink" title="非接口符号引用"></a>非接口符号引用</h2><p>该符号引用所指向的类为C，Java虚拟机查找步骤：</p><ol><li>在C中查找符合名字及描述符的方法。</li><li>在C的父类中继续搜索，直至 Object 类。</li><li>在C所直接实现或间接实现的接口中搜索。<br>这一步搜索得到的目标方法必须是非私有、非静态的。<br>如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。（假如C实现了I，I继承I1，I1继承I2，那么C和I2之间就隔着I和I1）</li></ol><p>经过上述的解析步骤之后，符号引用会被解析成实际引用。</p><p><strong>静态绑定的方法调用：实际引用是一个指向方法的指针。</strong></p><p><strong>动态绑定的方法调用，实际引用是一个方法表的索引。</strong></p><h2 id="接口符号引用"><a href="#接口符号引用" class="headerlink" title="接口符号引用"></a>接口符号引用</h2><p>该符号引用所指向的接口为I，Java虚拟机查找步骤：</p><ol><li>在I中查找符合名字及描述符的方法。</li><li>在Object类中的公有实例方法中搜索。</li><li>在I的父接口中搜索。<br>这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。</li></ol><h1 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h1><p>Java里：</p><ul><li>所有非私有实例方法调用被编译成invokevirtual指令</li><li>所有接口方法调用都被编译成invokeinterface指令。</li></ul><h2 id="Java虚拟机实现动态绑定的策略"><a href="#Java虚拟机实现动态绑定的策略" class="headerlink" title="Java虚拟机实现动态绑定的策略"></a>Java虚拟机实现动态绑定的策略</h2><p>为每个类生成一张方法表，用以快速定位目标方法（空间换取时间）。</p><h1 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h1><blockquote><p>类加载的准备阶段除了为静态字段分配内存之外，还会构造与该类相关联的方法表。</p></blockquote><p>下面以虚方法表为例（virtual method table，vtable），接口方法（interface method table，itable）表原理类似，但稍复杂。</p><p>方法表<strong>本质：数组</strong>（元素指向一个当前类及其祖先类中非私有的实例方法）。</p><p>方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。</p><p>方法表<strong>满足两个特质</strong>：</p><ul><li>子类方法表中<strong>包含父类方法表中的所有方法</strong>。</li><li>子类方法在方法表中的索引值，<strong>与它所重写的父类方法的索引值相同</strong>。</li></ul><p>动态绑定：</p><ul><li>Java 虚拟机将获取调用者的实际类型。</li><li>在该实际类型的虚方法表中根据索引值获得目标方法。</li></ul><h2 id="是否可以认为虚方法调用对性能没有太大影响？"><a href="#是否可以认为虚方法调用对性能没有太大影响？" class="headerlink" title="是否可以认为虚方法调用对性能没有太大影响？"></a>是否可以认为虚方法调用对性能没有太大影响？</h2><p><strong>不能，上述优化实际上仅存在最坏情况中。</strong></p><p><strong>即时编译有两种性能更好的优化手段：</strong></p><ul><li>内联缓存（inlining cache）</li><li>方法内联（method inlining）</li></ul><h1 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h1><blockquote><p>缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。</p></blockquote><p>单态（monomorphic）指的是仅有一种状态的情况。<br>多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。<br>超多态（megamorphic）指的是更多种状态的情况。通常用一个具体数值来区分多态和超多态。</p><p>对于内联缓存:</p><ul><li>单态内联缓存</li><li>多态内联缓存</li><li>超多态内联缓存</li></ul><p>在实践中，大部分的虚方法调用均是单态的。</p><p><strong>为了节省内存空间，Java 虚拟机只采用单态内联缓存。</strong></p><p><strong>内联缓存没有命中</strong>的情况下，Java 虚拟机需要<strong>重新使用方法表进行动态绑定</strong>，有两种选择：</p><ul><li><strong>替换</strong>单态内联缓存中的纪录。</li><li><strong>劣化为超多态状态</strong>（Java 虚拟机的具体实现方式）。<br>直接访问方法表，<strong>牺牲了优化的机会，节省了写缓存的额外开销</strong>。</li></ul><h2 id="内联缓存并没有内联目标方法。"><a href="#内联缓存并没有内联目标方法。" class="headerlink" title="内联缓存并没有内联目标方法。"></a>内联缓存并没有内联目标方法。</h2><ul><li>任何方法调用除非被内联，否则都会有固定开销。</li><li>开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：public final 或 public static final 的方法，是不是在虚拟机中解析为静态绑定的。</p><p>A：静态方法都是静态绑定。调用的目标方法是public final的话，HotSpot虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/11539" target="_blank" rel="noopener">https://time.geekbang.org/column/article/11539</a><br><a href="https://time.geekbang.org/column/article/12098" target="_blank" rel="noopener">https://time.geekbang.org/column/article/12098</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重载和重写&quot;&gt;&lt;a href=&quot;#重载和重写&quot; class=&quot;headerlink&quot; title=&quot;重载和重写&quot;&gt;&lt;/a&gt;重载和重写&lt;/h1&gt;&lt;p&gt;在Java程序里，同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。这个限制可以通过字节码工具绕开。
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笔记-深入拆解Java虚拟机-03Java虚拟机是如何加载Java类的？</title>
    <link href="http://yoursite.com/2018/07/29/%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-03Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/29/笔记-深入拆解Java虚拟机-03Java虚拟机是如何加载Java类的？/</id>
    <published>2018-07-29T07:02:28.000Z</published>
    <updated>2018-08-15T12:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的类型：基本类型（primitive types）和引用类型（reference types<br>）。</p><ul><li>基本类型由Java虚拟机预先定义好。</li><li>引用类型：类、接口、数组类和泛型参数。</li><li>泛型参数会在编译过程中被擦除，Java虚拟机上实际只有三种。</li><li>数组类是由Java虚拟机直接生成，其他两种有对应的字节流。</li></ul><p>字节流形式：</p><ul><li>class文件。</li><li>程序内部直接生成。</li><li>从网络中获取。</li></ul><p>字节流加载到Java虚拟机中，成为类或接口。</p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><blockquote><p>查找字节流，并且据此创建类的过程。</p></blockquote><ul><li>对于数组类，它没有对应的字节流，由Java虚拟机直接生成。</li><li>对于其他类，Java虚拟机需要借助类加载器完成查找字节流的过程。</li></ul><h2 id="java9之前"><a href="#java9之前" class="headerlink" title="java9之前"></a>java9之前</h2><h3 id="启动类加载器（boot-class-loader）"><a href="#启动类加载器（boot-class-loader）" class="headerlink" title="启动类加载器（boot class loader）"></a>启动类加载器（boot class loader）</h3><p><strong>启动类加载器由C++实现</strong>，没有对应的Java对象，Java中只能用null来指代。</p><p><strong>启动类加载器加载最为基础、最为重要的类。</strong>如：存放在jre的lib目录加jar包中的类（以及由虚拟机参数-Xbootclasspath指定的类）</p><p><strong>其他类加载器都是java.lang.ClassLoader的子类。</strong>类加载器需要先由另一个类加载器加载至Java虚拟机中，才能执行类加载。</p><h3 id="扩展类加载器（extension-class-loader）"><a href="#扩展类加载器（extension-class-loader）" class="headerlink" title="扩展类加载器（extension class loader）"></a>扩展类加载器（extension class loader）</h3><p>父类加载器：启动类加载器。</p><p><strong>加载相对次要、但又通用的类。</strong>如：存放在jre的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。</p><h3 id="应用类加载器（application-class-loader）"><a href="#应用类加载器（application-class-loader）" class="headerlink" title="应用类加载器（application class loader）"></a>应用类加载器（application class loader）</h3><p>父类加载器：扩展类加载器。</p><p><strong>加载应用程序路径下的类。</strong>（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。</p><h2 id="java9之后"><a href="#java9之后" class="headerlink" title="java9之后"></a>java9之后</h2><p>Java9引入了模块系统，并且略微更改了上述的类加载器。</p><p>扩展类加载器被改名为平台类加载器（platform class loader）。</p><p>Java SE中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><strong>没当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类情况下，该类加载器才会尝试去加载。</strong></p><p><strong>注：父类加载器不是继承关系！！！</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong>可以加入自定义的类加载器</strong>，来实现特殊的加载方式。<br>如：可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。</p></li><li><p>类加载器还提供了命名空间的作用。</p></li><li>在 Java 虚拟机中，<strong>类的唯一性是由类加载器实例以及类的全名一同确定的</strong>。<br>即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。</li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><blockquote><p>将创建成的类合并至Java虚拟机中，使之能够只够执行的过程。它可分为验证、准备以及解析三个阶段。</p></blockquote><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><blockquote><p>确保被加载类能够满足Java虚拟机的约束条件。</p></blockquote><p>通常而言，Java编译器生成的类文件必然满足Java虚拟机的约束条件。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote><p>为被加载类的静态字段分配内存。</p></blockquote><p>部分Java虚拟机会在此阶段构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表。</p><h2 id="解析（非必需）"><a href="#解析（非必需）" class="headerlink" title="解析（非必需）"></a>解析（非必需）</h2><p>在class文件被加载至Java虚拟机之前，这个类无法知道其他类（甚至自己）的方法、字段所对应的具体地址。引用时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。</p><p><strong>将这些符号引用解析成为实际引用。</strong></p><p>如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）</p><p><strong>Java 虚拟机规范并没有要求在链接过程中完成解析。</strong>它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>如果直接赋值的静态字段：</p><ul><li>被 final 所修饰</li><li>类型是基本类型或字符串时</li></ul><p>该字段便会被 Java 编译器标记成<strong>常量值（ConstantValue），初始化直接由 Java 虚拟机完成</strong>。</p><p><strong>除此之外的直接赋值操作，所有静态代码块中的代码，会被 Java 编译器置于同一方法中，并把它命名为&lt;clinit>。</strong></p><p>&lt;clinit>方法仅被执行一次。</p><p><strong>JVM 规范枚举了下述多种触发类初始化的情况：</strong></p><ol><li>当虚拟机启动时，初始化用户指定的主类。</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类。</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类。</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类。</li><li>子类的初始化会触发父类的初始化。</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化。</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类。</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：<strong>加载阶段都加载哪些类呢，那么多类，全部加载吗？</strong></p><p>A：<strong>加载阶段是针对单个类的</strong>，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。</p><hr><p>Q：有一个零值(0/null)初始化，针对于类的静态成员变量，如果是final修饰的静态成员变量，也就是常量，是初始化为代码中指定的值比如10。非final修饰的静态成员变量，在clinit执行过程中赋值为代码中指定的值，是这样的吗？</p><p>A：<strong>被final修饰的静态成员变量，如果不是基本类型或者字符串，也会放在clinit 来做。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://time.geekbang.org/column/article/11523" target="_blank" rel="noopener">https://time.geekbang.org/column/article/11523</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java语言的类型：基本类型（primitive types）和引用类型（reference types&lt;br&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型由Java虚拟机预先定义好。&lt;/li&gt;
&lt;li&gt;引用类型：类、接口、数组类和泛型参数。&lt;/li&gt;
&lt;li&gt;泛型参数会在编译
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
