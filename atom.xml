<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ennis Wu</title>
  
  <subtitle>ARTPOP = artistic revolution through the potential of pop.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ennis.info/"/>
  <updated>2020-05-18T17:52:11.521Z</updated>
  <id>http://blog.ennis.info/</id>
  
  <author>
    <name>Ennis L.M. Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「转载」HTTP 中 GET 与 POST 的区别</title>
    <link href="http://blog.ennis.info/2020/05/16/HTTP%E4%B8%ADGET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ennis.info/2020/05/16/HTTP中GET与POST的区别/</id>
    <published>2020-05-16T07:39:44.000Z</published>
    <updated>2020-05-18T17:52:11.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="w3schools-答案"><a href="#w3schools-答案" class="headerlink" title="w3schools 答案"></a>w3schools 答案</h1><ol><li><p>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</p></li><li><p>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</p></li><li><p>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</p></li><li><p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</p></li><li><p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</p></li><li><p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</p></li><li><p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</p></li><li><p>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</p></li><li><p>GET 参数通过 URL 传递，POST 放在 Request body 中。</p></li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li><p>GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。</p><ul><li><p>对于 GET 方式的请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200（返回数据）。</p></li><li><p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p></li><li><p>只有部分浏览器会发两个数据包，且 header 要加相应参数，且服务端要支持。</p></li></ul></li><li><p>增删查改中，GET 语义对应查，POST 语义对应增。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;w3schools-答案&quot;&gt;&lt;a href=&quot;#w3schools-答案&quot; class=&quot;headerlink&quot; title=&quot;w3schools 答案&quot;&gt;&lt;/a&gt;w3schools 答案&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GET 在浏览器回退时是无害的，而 POS
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://blog.ennis.info/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://blog.ennis.info/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://blog.ennis.info/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」JVM 内存区域与垃圾回收</title>
    <link href="http://blog.ennis.info/2020/04/26/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://blog.ennis.info/2020/04/26/JVM内存区域与垃圾回收/</id>
    <published>2020-04-26T06:56:32.000Z</published>
    <updated>2020-05-18T17:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener">JVM垃圾回收</a></p></li><li><p><a href="https://juejin.im/post/5df2ec71f265da33d7442433" target="_blank" rel="noopener">聊聊Java的GC机制</a></p></li><li><p><a href="https://juejin.im/post/5ccfa05af265da039f0f243b" target="_blank" rel="noopener">深入Java虚拟机之 – 总结面试篇</a></p></li></ul><h1 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h1><p><img src="/images/posts/JVM/jvm_memory.jpg" alt=""></p><ul><li><p>方法区</p><ul><li>存储已被虚拟机加载的类信息、常量、静态变量等</li></ul></li><li><p>堆</p><ul><li><p>JVM 管理的内存中最大的一块</p></li><li><p>存放对象实例</p></li><li><p>GC 主要作用的区域</p></li></ul></li><li><p>虚拟机栈：</p><ul><li><p>局部变量表、操作数栈</p></li><li><p>描述 Java 方法执行的内存模型</p></li></ul></li><li><p>本地方法栈</p><ul><li>与虚拟机栈类似，为 native 方法提供服务</li></ul></li><li><p>程序计数器</p><ul><li><p>记录当前线程执行的方法执行到了第几行</p></li><li><p>线程正在执行的是 Java 方法，计数器记录正在执行的虚拟机字节码指令的地址</p></li><li><p>线程正在执行的是 native 方法，这个计数器值则为空（Undefined）</p></li></ul></li><li><p>JDK 1.7 之前常量池在方法区，JDK 1.7 之后常量池在堆</p></li></ul><h2 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h2><p><img src="/images/posts/JVM/jvm_memory_heap.png" alt=""></p><ul><li>JDK 1.8 之前</li></ul><p>堆 = 新生代 + 老年代 + 永久代</p><p>新生代 = Eden 区 + Survivor from 区 + Survivor to 区</p><ul><li>JDK 1.8 之后</li></ul><p>堆 = 新生代 + 老年代 + 元空间（使用物理内存）</p><h1 id="GC-的分类"><a href="#GC-的分类" class="headerlink" title="GC 的分类"></a>GC 的分类</h1><ul><li><p>新生代 GC（Minor GC）</p><ul><li><p>发生新生代的的 GC</p></li><li><p>Minor GC 非常频繁</p></li><li><p>回收速度一般比较快</p></li></ul></li><li><p>老年代 GC（Major GC/Full GC）</p><ul><li><p>发生在老年代的 GC</p></li><li><p>出现 Major GC 通常会伴随至少一次的 Minor G</p></li><li><p>Major GC 速度一般比 Minor GC 慢 10 倍以上</p></li></ul></li></ul><h1 id="内存分配规则"><a href="#内存分配规则" class="headerlink" title="内存分配规则"></a>内存分配规则</h1><ul><li><p>对象优先在 Eden 区分配</p></li><li><p>Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</p></li><li><p>大对象直接进入老年代</p></li></ul><p>大对象指需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><ul><li><p>长期存活的对象将进入老年代</p></li><li><p>动态对象年龄判定</p></li></ul><p>如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h1 id="GC-Roots-是什么"><a href="#GC-Roots-是什么" class="headerlink" title="GC Roots 是什么"></a>GC Roots 是什么</h1><blockquote><p><a href="https://help.eclipse.org/2019-09/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;resultof=%22%67%61%72%62%61%67%65%22%20%22%67%61%72%62%61%67%22%20" target="_blank" rel="noopener">Garbage Collection Roots</a><br>A garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:<br><strong>System Class</strong><br>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .<br><strong>JNI Local</strong><br>Local variable in native code, such as user defined JNI code or JVM internal code.<br><strong>JNI Global</strong><br>Global variable in native code, such as user defined JNI code or JVM internal code.<br><strong>Thread Block</strong><br>Object referred to from a currently active thread block.<br><strong>Thread</strong><br>A started, but not stopped, thread.<br><strong>Busy Monitor</strong><br>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.<br><strong>Java Local</strong><br>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.<br><strong>Native Stack</strong><br>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.<br><strong>Finalizable</strong><br>An object which is in a queue awaiting its finalizer to be run.<br><strong>Unfinalized</strong><br>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.<br><strong>Unreachable</strong><br>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.<br><strong>Java Stack Frame</strong><br>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.<br><strong>Unknown</strong><br>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</p></blockquote><ul><li><p>由系统类加载器（system class loader）加载的对象</p></li><li><p>活着的线程，包含处于等待或阻塞的线程</p></li><li><p>当前被调用的方法（Java 方法，native 方法）的一些参数和局部变量</p></li><li><p>方法区中静态变量，常量引用的对象</p></li><li><p>Held by JVM</p></li></ul><p>JVM 由于特殊目的为 GC 保留的对象，实际与 JVM 的实现有关。</p><p>可能已知的一些类型是：系统类加载器、一些 JVM 知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。</p><h1 id="常量池的-gc"><a href="#常量池的-gc" class="headerlink" title="常量池的 gc"></a>常量池的 gc</h1><ul><li>该常量没有任何引用</li></ul><h1 id="方法区的-gc"><a href="#方法区的-gc" class="headerlink" title="方法区的 gc"></a>方法区的 gc</h1><ul><li><p>该类不存在任何对象</p></li><li><p>该类 <code>GlassLoader</code> 已被回收</p></li><li><p><code>java.lang.Class</code> 对象不存在任何引用，任何地方无反射该类</p></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><ul><li><p>Mark-Sweep（标记-清除）算法</p></li><li><p>Copying（复制）算法</p><ul><li><p>1:1 复制</p></li><li><p>8:1 复制</p></li></ul></li><li><p>Mark-Compact（标记-整理）算法</p></li><li><p>Generational Collection（分代收集）算法</p></li></ul><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><img src="/images/posts/JVM/gc_mark_sweep.jpg" alt=""></p><ol><li><p>标记所有需要回收的对象</p></li><li><p>统一回收所有被标记的对象</p></li></ol><ul><li>会产生大量不连续的碎片</li></ul><h2 id="复制算法（1-1）"><a href="#复制算法（1-1）" class="headerlink" title="复制算法（1:1）"></a>复制算法（1:1）</h2><p><img src="/images/posts/JVM/gc_copying.jpg" alt=""></p><ol><li><p>将内存分为两块</p></li><li><p>一块使用完后存活的对象复制到另一块</p></li><li><p>把已使用的空间清空</p></li></ol><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="/images/posts/JVM/gc_mark_compact.jpg" alt=""></p><ul><li>针对老年代</li></ul><ol><li><p>标记所有需要回收的对象</p></li><li><p>将存活的对象移到一端</p></li><li><p>清理端边界以外的内存</p></li></ol><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li><p>新生代使用复制算法</p></li><li><p>老年代使用标记-清除算法或标记-整理算法</p></li></ul><h3 id="复制算法（8-1）"><a href="#复制算法（8-1）" class="headerlink" title="复制算法（8:1）"></a>复制算法（8:1）</h3><ul><li>新生代内存分配比例： Eden 区 : Survivor from 区 : Survivor to 区 = 8 : 1 : 1</li></ul><ol><li><p>先使用 Eden 区和 from 区</p></li><li><p>GC 时将存活的对象复制到 to 区</p></li><li><p>清理 Eden 区和 to 区</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide/blob/master/
      
    
    </summary>
    
      <category term="JVM" scheme="http://blog.ennis.info/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://blog.ennis.info/tags/JVM/"/>
    
      <category term="垃圾回收" scheme="http://blog.ennis.info/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>「转载」Activity 的相关问题</title>
    <link href="http://blog.ennis.info/2020/04/17/%E8%BD%AC-Activity%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ennis.info/2020/04/17/转-Activity相关问题/</id>
    <published>2020-04-17T04:35:27.000Z</published>
    <updated>2020-05-18T17:50:03.644Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.jianshu.com/p/86c0a4afd28e" target="_blank" rel="noopener">Activity 的 36 大难点，你会几个？「建议收藏」</a></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="Dialog-弹出"><a href="#Dialog-弹出" class="headerlink" title="Dialog 弹出"></a>Dialog 弹出</h2><ul><li>如果是单纯是创建的 Dialog，Activity 并不会执行生命周期的方法</li></ul><h2 id="什么是-onNewIntent"><a href="#什么是-onNewIntent" class="headerlink" title="什么是 onNewIntent"></a>什么是 onNewIntent</h2><ul><li><p>如果 IntentActivity 处于任务栈的顶端，也就是说之前打开过的 Activity，现在处于 onPause、onStop 状态的话，其他应用再发送 Intent 的话</p></li><li><p>执行顺序为：onNewIntent，onRestart，onStart，onResume</p></li></ul><h1 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h1><p>Activity 一共有四种 launchMode：Standard、SingleTop、SingleTask、SingleInstance。</p><h2 id="Standard-模式（默认模式）"><a href="#Standard-模式（默认模式）" class="headerlink" title="Standard 模式（默认模式）"></a>Standard 模式（默认模式）</h2><ol><li><p>说明：每次启动一个 Activity 都会又一次创建一个新的实例入栈，无论这个实例是否存在。</p></li><li><p>生命周期：每次被创建的实例 Activity 的生命周期符合典型情况，它的 onCreate、onStart、onResume 都会被调用。</p></li><li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 Standard 模式。若在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是还有一个 C Activity 进入栈中，成为栈顶。</p></li></ol><h2 id="SingleTop-模式（栈顶复用模式）"><a href="#SingleTop-模式（栈顶复用模式）" class="headerlink" title="SingleTop 模式（栈顶复用模式）"></a>SingleTop 模式（栈顶复用模式）</h2><ol><li><p>说明：分两种处理情况：须要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity。不会再创建新的 Activity；若须要创建的 Activity 不处于栈顶，此时会又一次创建一个新的 Activity 入栈，同 Standard 模式一样。</p></li><li><p>生命周期：若情况一中栈顶的 Activity 被直接复用时，它的 onCreate、onStart 不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent 会被回调（Activity 被正常创建时不会回调此方法）。</p></li><li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 SingleTop 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity。结果是直接复用栈顶的 C Activity。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity。结果是创建一个新的 Activity 入栈。成为栈顶。</p></li></ol><h2 id="SingleTask-模式（栈内复用模式）"><a href="#SingleTask-模式（栈内复用模式）" class="headerlink" title="SingleTask 模式（栈内复用模式）"></a>SingleTask 模式（栈内复用模式）</h2><ol><li><p>说明：若须要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶。</p></li><li><p>如果是在别的应用程序中启动它，则会新建一个 task ，并在该 task 中启动这个 Activity ，SingleTask 允许别的 Activity 与其在一个 task 中共存，也就是说，如果我在这个 SingleTask 的实例中再打开新的 Activity ，这个新的 Activity 还是会在 SingleTask 的实例的 task 中。</p></li><li><p>生命周期：同 SingleTop 模式中的情况一同样。仅仅会又一次回调 Activity 中的 onNewIntent 方法</p></li><li><p>举例：此时 Activity 栈中以此有 A、B、C 三个 Activity 。此时 C 处于栈顶，启动模式为 SingleTask 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是直接用栈顶的 C Activity 。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity 。结果是将 A Activity 上面的 B、C 所有销毁，使 A Activity 成为栈顶。</p></li></ol><h2 id="SingleInstance-模式（单实例模式）"><a href="#SingleInstance-模式（单实例模式）" class="headerlink" title="SingleInstance 模式（单实例模式）"></a>SingleInstance 模式（单实例模式）</h2><ol><li><p>说明：SingleInstance 比较特殊，是全局单例模式，是一种加强的 SingleTask 模式。它除了具有它所有特性外，还加强了一点：只有一个实例，并且这个实例独立运行在一个 task 中，这个 task 只有这个实例，不允许有别的 Activity 存在。</p></li><li><p>这个经常使用于系统中的应用，比如 Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。</p></li><li><p>举例：比方 A Activity 是该模式，启动 A 后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的 Activity ，除非这个独特的任务栈被系统销毁。</p></li></ol><h2 id="SingleTask-模式的运用场景"><a href="#SingleTask-模式的运用场景" class="headerlink" title="SingleTask 模式的运用场景"></a>SingleTask 模式的运用场景</h2><ol><li><p>最常见的应用场景就是保持我们应用开启后仅仅有一个 Activity 的实例。</p></li><li><p>最典型的样例就是应用中展示的主页（Home 页）。</p></li><li><p>假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用 SingleTask 模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。</p></li></ol><h2 id="SingleTop-模式的运用场景"><a href="#SingleTop-模式的运用场景" class="headerlink" title="SingleTop 模式的运用场景"></a>SingleTop 模式的运用场景</h2><ol><li><p>假设你在当前的 Activity 中又要启动同类型的 Activity</p></li><li><p>此时建议将此类型 Activity 的启动模式指定为 SingleTop ，能够降低Activity的创建，节省内存！</p></li></ol><h2 id="注意：复用-Activity-时的生命周期回调"><a href="#注意：复用-Activity-时的生命周期回调" class="headerlink" title="注意：复用 Activity 时的生命周期回调"></a>注意：复用 Activity 时的生命周期回调</h2><ol><li><p>这里还须要考虑一个 Activity 跳转时携带页面參数的问题。</p></li><li><p>由于当一个 Activity 设置了 SingleTop 或者 SingleTask 模式后，跳转此 Activity 出现复用原有 Activity 的情况时，此 Activity 的 onCreate 方法将不会再次运行。onCreate 方法仅仅会在第一次创建 Activity 时被运行。</p></li><li><p>而一般 onCreate 方法中会进行该页面的数据初始化、UI 初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题</p></li><li><p>若页面展示的数据就是通过 getIntent() 方法来获取，那么问题就会出现：getIntent() 获取的一直都是老数据，根本无法接收跳转时传送的新数据！</p></li><li><p>这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的 intent ，这样我们就能够解决上述问题。这里建议的方法是又一次去 setIntent。然后又一次去初始化数据和 UI。</p></li></ol><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="Activity-间通过-Intent-传递数据大小限制"><a href="#Activity-间通过-Intent-传递数据大小限制" class="headerlink" title="Activity 间通过 Intent 传递数据大小限制"></a>Activity 间通过 Intent 传递数据大小限制</h2><ul><li><p>Intent 在传递数据时是有大小限制的，这里官方并未详细说明，不过通过实验的方法可以测出数据应该被限制在 1MB 之内（1024KB）</p></li><li><p>我们采用传递 Bitmap 的方法，发现当图片大小超过 1024（准确地说是 1020 左右）的时候，程序就会出现闪退、停止运行等异常(不同的手机反应不同)</p></li><li><p>因此可以判断 Intent 的传输容量在 1MB 之内。</p></li></ul><h2 id="内存不足时系统会杀掉后台的-Activity，若需要进行一些临时状态的保存，在哪个方法进行"><a href="#内存不足时系统会杀掉后台的-Activity，若需要进行一些临时状态的保存，在哪个方法进行" class="headerlink" title="内存不足时系统会杀掉后台的 Activity，若需要进行一些临时状态的保存，在哪个方法进行"></a>内存不足时系统会杀掉后台的 Activity，若需要进行一些临时状态的保存，在哪个方法进行</h2><ul><li><p>Activity 的 onSaveInstanceState() 和 onRestoreInstanceState() 并不是生命周期方法，它们不同于 onCreate()、onPause() 等生命周期方法，它们并不一定会被触发。</p></li><li><p>onSaveInstanceState() 方法，当应用遇到意外情况（如：内存不足、用户直接按 Home 键）由系统销毁一个 Activity， onSaveInstanceState() 会被调用。</p></li><li><p>但是当用户主动去销毁一个 Activity 时，例如在应用中按返回键，onSaveInstanceState() 就不会被调用。</p></li><li><p>除非该 Activity 不是被用户主动销毁的，通常 onSaveInstanceState() 只适合用于保存一些临时性的状态，而 onPause() 适合用于数据的持久化保存。</p></li></ul><h2 id="onSaveInstanceState-被执行的场景"><a href="#onSaveInstanceState-被执行的场景" class="headerlink" title="onSaveInstanceState() 被执行的场景"></a>onSaveInstanceState() 被执行的场景</h2><p>系统不知道你按下 HOME 后要运行多少其他的程序，自然也不知道 Activity A 是否会被销毁</p><p>因此系统都会调用 onSaveInstanceState() ，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则：</p><ol><li><p>当用户按下 HOME 键时</p></li><li><p>长按 HOME 键，选择运行其他的程序时</p></li><li><p>锁屏时</p></li><li><p>从 Activity A 中启动一个新的 Activity 时</p></li><li><p>屏幕方向切换时</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://www.jianshu.com/p/86c0a4afd28e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Activity 的 36 大难点，你会几个？「建议收藏」&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;生命周期&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
      <category term="Activity" scheme="http://blog.ennis.info/tags/Activity/"/>
    
      <category term="四大组件" scheme="http://blog.ennis.info/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
      <category term="启动模式" scheme="http://blog.ennis.info/tags/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」HashMap 之扰动函数</title>
    <link href="http://blog.ennis.info/2020/04/17/HashMap%E4%B9%8B%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.ennis.info/2020/04/17/HashMap之扰动函数/</id>
    <published>2020-04-17T03:48:58.000Z</published>
    <updated>2020-05-18T17:50:32.826Z</updated>
    
    <content type="html"><![CDATA[<p>以下源码基于 JDK11</p><p><code>HashMap</code> 添加数据时 <code>Key</code> 的 <code>hashCode</code> 值通过扰动函数重新计算 <code>hash</code> 值，<strong>新 <code>hash</code> 值与数组的长度取模得到数组目标下标</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长度等于 2 的 n 次幂时，这两种写法效果相同</span></span><br><span class="line"><span class="comment">//i = hash % (tab.length - 1)</span></span><br><span class="line">i = (tab.length - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p><strong>这也是为什么数组的长度始终保持 2 的 n 次幂大小的原因。</strong> 详细推理可以看<a href="https://www.cnblogs.com/ysocean/p/9054804.html" target="_blank" rel="noopener">由HashMap哈希算法引出的求余%和与运算&amp;转换问题</a></p><p>当哈希函数映射得比较松散时，碰撞就很难发生，<strong>但是 <code>HashMap</code> 的数组长度是有限的，要进行取模操作</strong>。这时就算散列值分布松散，<strong>只取最后几位碰撞也很严重</strong>。</p><p>JDK8 之后的扰动函数是这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将 <code>hashCode</code> 值无符号右移 16 位再与自身异或</strong>，这样混合了 <code>hashCode</code> 的高位和低位，增加低位的随机性，混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留。</p><p><img src="/images/posts/Java/Collection/perturbation_function.png" alt="" title="扰动函数"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下源码基于 JDK11&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 添加数据时 &lt;code&gt;Key&lt;/code&gt; 的 &lt;code&gt;hashCode&lt;/code&gt; 值通过扰动函数重新计算 &lt;code&gt;hash&lt;/code&gt; 值，&lt;strong&gt;新 &lt;code&gt;h
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.ennis.info/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.ennis.info/tags/Java/"/>
    
      <category term="Java集合" scheme="http://blog.ennis.info/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>「转载」Glide 面试问答</title>
    <link href="http://blog.ennis.info/2020/04/13/%E8%BD%AC-Glide%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/"/>
    <id>http://blog.ennis.info/2020/04/13/转-Glide面试问答/</id>
    <published>2020-04-13T13:38:20.000Z</published>
    <updated>2020-05-18T17:48:20.636Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5dd766e1e51d45233c7e857f" target="_blank" rel="noopener">聊一聊关于Glide在面试中的那些事</a></p><h1 id="来简单介绍下-Glide-的缓存"><a href="#来简单介绍下-Glide-的缓存" class="headerlink" title="来简单介绍下 Glide 的缓存"></a>来简单介绍下 Glide 的缓存</h1><p><strong>分析</strong></p><p>（这货滔滔不绝的说了一大通，从 LruCache 说到了 LinkedHashMap，巴拉巴拉。。。个人建议这块一定要简述，面试时原理说的太多，第一很多细节会被打断问到，第二点，说这么多，给人的感觉就是在背诵东西，原理概括能力很弱或者感觉根本就没有自己的体会。）</p><p><strong>答案</strong></p><p>Glide 的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。正式因为有着这两种缓存的结合，才构成了 Glide 极佳的缓存效果。</p><p>（先告诉人家有哪几种缓存，主要是为了什么目的才用的缓存，然后可以看着面试官，要么等着他继续问，如果他不问，等着你，这个时候你就可以继续的往细节处介绍）</p><h1 id="嗯，具体说一说-Glide-的三级缓存原理"><a href="#嗯，具体说一说-Glide-的三级缓存原理" class="headerlink" title="嗯，具体说一说 Glide 的三级缓存原理"></a>嗯，具体说一说 Glide 的三级缓存原理</h1><p><strong>分析</strong></p><p>（记得，如果需要具体谈原理时，要先宏观，后细节）</p><p><strong>答案</strong></p><p>读取一张图片的时候，获取顺序：Lru 算法缓存-》弱引用缓存-》磁盘缓存（如果设置了的话）。</p><p>当我们的 APP 中想要加载某张图片时，先去 LruCache 中寻找图片，如果 LruCache 中有，则直接取出来使用，并将该图片放入 WeakReference 中，如果 LruCache 中没有，则去 WeakReference 中寻找，如果 WeakReference 中有，则从 WeakReference 中取出图片使用，如果 WeakReference 中也没有图片，则从磁盘缓存/网络中加载图片。 </p><p>注：图片正在使用时存在于 activeResources 弱引用 map 中。流程如下图：</p><p><img src="/images/posts/android/glide/glide_cache.jpg" alt=""></p><p>将图片缓存的时候，写入顺序：弱引用缓存-》Lru算法缓存-》磁盘缓存中。</p><p>当图片不存在的时候，先从网络下载图片，然后将图片存入弱引用中，glide 会采用一个 acquired（int）变量用来记录图片被引用的次数， 当 acquired 变量大于 0 的时候，说明图片正在使用中，也就是将图片放到弱引用缓存当中；如果 acquired 变量等于 0 了，说明图片已经不再被使用了，那么此时会调用方法来释放资源，首先会将缓存图片从弱引用中移除，然后再将它 put 到 LruResourceCache 当中。这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。</p><h2 id="引深"><a href="#引深" class="headerlink" title="引深"></a>引深</h2><h3 id="关于-LruCache"><a href="#关于-LruCache" class="headerlink" title="关于 LruCache"></a>关于 LruCache</h3><p>最近最少使用算法，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致 OOM。LruCache 内部用 LinkHashMap 存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面 put 数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。</p><h3 id="关于-LinkedHashMap"><a href="#关于-LinkedHashMap" class="headerlink" title="关于 LinkedHashMap"></a>关于 LinkedHashMap</h3><p>LinkHashMap 继承 HashMap，在 HashMap 的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头 header 之前，这样就保证了链表头 header 节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在 map 中的位置是不变的）。</p><h1 id="Glide加载一个一兆的图片（100-x-100），是否会压缩后再加载，放到一个-300-x-300-的-View-上会怎样，800-x-800-呢，图片会很模糊，怎么处理？"><a href="#Glide加载一个一兆的图片（100-x-100），是否会压缩后再加载，放到一个-300-x-300-的-View-上会怎样，800-x-800-呢，图片会很模糊，怎么处理？" class="headerlink" title="Glide加载一个一兆的图片（100 x 100），是否会压缩后再加载，放到一个 300 x 300 的 View 上会怎样，800 x 800 呢，图片会很模糊，怎么处理？"></a>Glide加载一个一兆的图片（100 x 100），是否会压缩后再加载，放到一个 300 x 300 的 View 上会怎样，800 x 800 呢，图片会很模糊，怎么处理？</h1><p><strong>分析</strong></p><p>（因为你缓存机制无论是看博客还是看一些面试宝典，如果只是考原理或者定义，光把上面的文字背诵下来就可以了，但是背诵和真正的理解是两回事，自己没有形成感悟，不理解这个框架，只是一味的迎合面试，这个问题就可以卡住你，另外千万别和面试官嘚瑟，果然，这个面试的哥们，这块就卡住了，支支吾吾的半天没答上来，果然是只看了博客，没真正的阅读过源码）</p><p><strong>答案</strong></p><p>当我们调整 ImageView 的大小时，Picasso 会不管 ImageView 大小是什么，总是直接缓存整张图片，而 Glide 就不一样了，它会为每个不同尺寸的 ImageView 缓存一张图片，也就是说不管你的这张图片有没有加载过，只要 ImageView 的尺寸不一样，那么 Glide 就会重新加载一次，这时候，它会在加载的 ImageView 之前从网络上重新下载，然后再缓存。</p><p>举个例子，如果一个页面的 ImageView 是 300 x 300 像素，而另一个页面中的 ImageView 是 100 x 100 像素，这时候想要让两个 ImageView 像是同一张图片，那么 Glide 需要下载两次图片，并且缓存两张图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求参数得到缓存的键</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧，缓存 Key 的生成条件之一就是控件的长宽。</p><h1 id="简单说一下内存泄漏的场景，如果在一个页面中使用-Glide-加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"><a href="#简单说一下内存泄漏的场景，如果在一个页面中使用-Glide-加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？" class="headerlink" title="简单说一下内存泄漏的场景，如果在一个页面中使用 Glide 加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"></a>简单说一下内存泄漏的场景，如果在一个页面中使用 Glide 加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？</h1><p><strong>分析</strong></p><p>（注意一定要审题，因为之前问了这个小伙，内存泄漏的原因，无非是长生命周期引用了短生命周期的对象等等，然后突然画风一变，直接问了 Glide 加载图片会不会引起图片泄漏，这个小伙想也没想，直接回答道会引起内存泄漏，可以用 LeakCanary 检测，巴拉巴拉。。。）</p><p><strong>答案</strong></p><p>因为 Glide 在加载资源的时候，如果是在 Activity、Fragment 这一类有生命周期的组件上进行的话，会创建一个透明的 RequestManagerFragment 加入到FragmentManager 之中，感知生命周期，当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源。但是如果，是在非生命周期的组件上进行时，会采用 Application 的生命周期贯穿整个应用，所以 ApplicationManager 只有在应用程序关闭的时候终止加载。</p><h1 id="如何设计一个大图加载框架"><a href="#如何设计一个大图加载框架" class="headerlink" title="如何设计一个大图加载框架"></a>如何设计一个大图加载框架</h1><p><strong>分析</strong></p><p>(这个孩子，总算是羞愧的低下了头，一脸懵逼的和我说，这个我忘记了) </p><p><strong>答案</strong></p><p>概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作。</p><p><img src="/images/posts/android/glide/picture_framwork.png" alt=""></p><ol><li><p>封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程；</p></li><li><p>解析路径：图片的来源有多种，格式也不尽相同，需要规范化；</p></li><li><p>读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（Bitmap）即可；</p></li><li><p>查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载；</p></li><li><p>解码：这一步是整个过程中最复杂的步骤之一，有不少细节，下个博客会说；</p></li><li><p>变换：解码出 Bitmap 之后，可能还需要做一些变换处理（圆角，滤镜等）；</p></li><li><p>缓存：得到最终 bitmap 之后，可以缓存起来，以便下次请求时直接取结果；</p></li><li><p>显示：显示结果，可能需要做些动画（淡入动画，CrossFade 等）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5dd766e1e51d45233c7e857f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;聊一聊关于Glide在面试中的那些事&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;来简单介绍下-Gli
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
      <category term="Glide" scheme="http://blog.ennis.info/tags/Glide/"/>
    
      <category term="图片框架" scheme="http://blog.ennis.info/tags/%E5%9B%BE%E7%89%87%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」为什么 View.post() 能获取到 View 的宽高</title>
    <link href="http://blog.ennis.info/2020/04/13/%E4%B8%BA%E4%BB%80%E4%B9%88View-post-%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0View%E7%9A%84%E5%AE%BD%E9%AB%98/"/>
    <id>http://blog.ennis.info/2020/04/13/为什么View-post-能获取到View的宽高/</id>
    <published>2020-04-13T11:29:30.000Z</published>
    <updated>2020-05-18T17:47:39.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么在-onCreate-和第一次-onResume-中无法获取到宽高"><a href="#为什么在-onCreate-和第一次-onResume-中无法获取到宽高" class="headerlink" title="为什么在 onCreate() 和第一次 onResume() 中无法获取到宽高"></a>为什么在 onCreate() 和第一次 onResume() 中无法获取到宽高</h1><p>我们知道 <code>View</code> 的绘制是从 <code>ViewRootImpl.performTraversals()</code> 方法开始的，而 <code>performTraversals()</code> 是在 <code>onResume()</code> 之后才被调用，所以在 <code>onCreate()</code> 和第一次 <code>onResume()</code> 中无法获取到 <code>View</code> 的宽高。</p><h1 id="为什么-View-post-能获取到宽高"><a href="#为什么-View-post-能获取到宽高" class="headerlink" title="为什么 View.post() 能获取到宽高"></a>为什么 View.post() 能获取到宽高</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class View</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>attachInfo</code> 不为空时直接发送事件</p></li><li><p><code>attachInfo</code> 为空时会暂时缓存任务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class HandlerActionQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    postDelayed(action, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction(action, delayMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActions = <span class="keyword">new</span> HandlerAction[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存的任务何时发送"><a href="#缓存的任务何时发送" class="headerlink" title="缓存的任务何时发送"></a>缓存的任务何时发送</h2><p>在 <code>View.dispatchAttachedToWindow()</code> 方法中发送事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class View</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue.executeActions(info.mHandler);</span><br><span class="line">        mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class HandlerActionQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> HandlerAction[] actions = mActions;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> HandlerAction handlerAction = actions[i];</span><br><span class="line">            handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mActions = <span class="keyword">null</span>;</span><br><span class="line">        mCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dispatchAttachedToWindow-何时被调用"><a href="#dispatchAttachedToWindow-何时被调用" class="headerlink" title="dispatchAttachedToWindow() 何时被调用"></a>dispatchAttachedToWindow() 何时被调用</h2><p>在 <code>ViewRootImpl.performTraversals()</code> 方法中会调用 <code>dispatchAttachedToWindow()</code> 方法，该方法在 <code>View</code> 的测量、布局、绘制之前被调用。</p><p><code>dispatchAttachedToWindow()</code> 方法和测量、布局、绘制一样会递归调用子 <code>View</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ...</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mFirst || ...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (...) &#123;</span><br><span class="line">                ...</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为何-dispatchAttachedToWindow-先于测量调用却能获取到宽高"><a href="#为何-dispatchAttachedToWindow-先于测量调用却能获取到宽高" class="headerlink" title="为何 dispatchAttachedToWindow() 先于测量调用却能获取到宽高"></a>为何 dispatchAttachedToWindow() 先于测量调用却能获取到宽高</h2><p>实际上 <code>ViewRootImpl.performTraversals()</code> 也是在事件循环中被执行的，所以缓存的任务会在 <code>ViewRootImpl.performTraversals()</code> 之后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class ViewRootImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performTraversals();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>View.post()</code> 中的任务在 <code>ViewRootImpl.performTraversals()</code>，执行完之前会被缓存，待 <code>ViewRootImpl.performTraversals()</code> 执行完后执行，所以可以获取到宽高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么在-onCreate-和第一次-onResume-中无法获取到宽高&quot;&gt;&lt;a href=&quot;#为什么在-onCreate-和第一次-onResume-中无法获取到宽高&quot; class=&quot;headerlink&quot; title=&quot;为什么在 onCreate() 和第一次
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
      <category term="View" scheme="http://blog.ennis.info/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>「转载」RenderObject 和 RenderBox</title>
    <link href="http://blog.ennis.info/2020/04/10/%E8%BD%AC-RenderObject%E5%92%8CRenderBox/"/>
    <id>http://blog.ennis.info/2020/04/10/转-RenderObject和RenderBox/</id>
    <published>2020-04-10T11:28:51.000Z</published>
    <updated>2020-05-18T17:46:12.957Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://book.flutterchina.club/chapter14/render_object.html" target="_blank" rel="noopener">14.3 RenderObject和RenderBox</a></p><p><code>RenderObject</code>就是渲染树中的一个对象，它拥有一个<code>parent</code>和一个<code>parentData</code> 插槽（slot），所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而<code>parentData</code>正是一个预留变量，它正是由<code>parent</code> 来赋值的，<code>parent</code>通常会通过子<code>RenderObject</code>的<code>parentData</code>存储一些和子元素相关的数据，如在Stack布局中，<code>RenderStack</code>就会将子元素的偏移数据存储在子元素的<code>parentData</code>中（具体可以查看<code>Positioned</code>实现）。</p><p><code>RenderObject</code>类本身实现了一套基础的layout和绘制协议，但是并没有定义子节点模型（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。 它也没有定义坐标系统（如子节点定位是在笛卡尔坐标中还是极坐标？）和具体的布局协议（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，Flutter提供了一个<code>RenderBox</code>类，它继承自<code>RenderObject</code>，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴，大多数情况下，我们直接使用<code>RenderBox</code>就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下<code>RenderBox</code>。</p><h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>在<code>RenderBox</code> 中，有个<code>size</code>属性用来保存控件的宽和高。<code>RenderBox</code>的layout是通过在组件树中从上往下传递<code>BoxConstraints</code>对象的实现的。<code>BoxConstraints</code>对象可以限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件。</p><p>在布局阶段，父节点会调用子节点的<code>layout()</code>方法，下面我们看看<code>RenderObject</code>中<code>layout()</code>方法的大致实现（删掉了一些无关代码和异常捕获）:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">   ...</span><br><span class="line">   RenderObject relayoutBoundary; </span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight </span><br><span class="line">        || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">      relayoutBoundary = parent._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">        performResize();</span><br><span class="line">    &#125;</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>layout</code>方法需要传入两个参数，第一个为<code>constraints</code>，即 父节点对子节点大小的限制，该值根据父节点的布局逻辑确定。另外一个参数是 <code>parentUsesSize</code>，该值用于确定 <code>relayoutBoundary</code>，该参数表示子节点布局变化是否影响父节点，如果为<code>true</code>，当子节点布局发生变化时父节点都会标记为需要重新布局，如果为<code>false</code>，则子节点布局发生变化后不会影响父节点。</p><h3 id="relayoutBoundary"><a href="#relayoutBoundary" class="headerlink" title="relayoutBoundary"></a>relayoutBoundary</h3><p>上面<code>layout()</code>源码中定义了一个<code>relayoutBoundary</code>变量，什么是 <code>relayoutBoundary</code>？在前面介绍<code>Element</code>时，我们讲过当一个<code>Element</code>标记为 dirty 时便会重新build，这时<code>RenderObject</code>便会重新布局，我们是通过调用 <code>markNeedsBuild()</code> 来标记<code>Element</code>为dirty的。在<code>RenderObject</code>中有一个类似的<code>markNeedsLayout()</code>方法，它会将<code>RenderObject</code>的布局状态标记为 dirty，这样在下一个frame中便会重新layout，我们看看<code>RenderObject</code>的<code>markNeedsLayout()</code>的部分源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">assert</span>(_relayoutBoundary != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码大致逻辑是先判断自身是不是<code>relayoutBoundary</code>，如果不是就继续向parent 查找，一直向上查找到是 <code>relayoutBoundary</code> 的 <code>RenderObject</code>为止，然后再将其标记为 dirty 的。这样来看它的作用就比较明显了，意思就是当一个控件的大小被改变时可能会影响到它的 parent，因此 parent 也需要被重新布局，那么到什么时候是个头呢？答案就是 <code>relayoutBoundary</code>，如果一个 <code>RenderObject</code> 是 <code>relayoutBoundary</code>，就表示它的大小变化不会再影响到 parent 的大小了，于是 parent 也就不用重新布局了。</p><h3 id="performResize-和-performLayout"><a href="#performResize-和-performLayout" class="headerlink" title="performResize 和 performLayout"></a>performResize 和 performLayout</h3><p><code>RenderBox</code>实际的测量和布局逻辑是在<code>performResize()</code> 和 <code>performLayout()</code>两个方法中，RenderBox子类需要实现这两个方法来定制自身的布局逻辑。根据<code>layout()</code> 源码可以看出只有 <code>sizedByParent</code> 为 <code>true</code> 时，<code>performResize()</code> 才会被调用，而 <code>performLayout()</code> 是每次布局都会被调用的。<code>sizedByParent</code> 意为该节点的大小是否仅通过 parent 传给它的 constraints 就可以确定了，即该节点的大小与它自身的属性和其子节点无关，比如如果一个控件永远充满 parent 的大小，那么 <code>sizedByParent</code>就应该返回<code>true</code>，此时其大小在 <code>performResize()</code> 中就确定了，在后面的 <code>performLayout()</code> 方法中将不会再被修改了，这种情况下 <code>performLayout()</code> 只负责布局子节点。</p><p>在 <code>performLayout()</code> 方法中除了完成自身布局，也必须完成子节点的布局，这是因为只有父子节点全部完成后布局流程才算真正完成。所以最终的调用栈将会变成：<em>layout() &gt; performResize()/performLayout() &gt; child.layout() &gt; …</em> ，如此递归完成整个UI的布局。</p><p><code>RenderBox</code>子类要定制布局算法不应该重写<code>layout()</code>方法，因为对于任何RenderBox的子类来说，它的layout流程基本是相同的，不同之处只在具体的布局算法，而具体的布局算法子类应该通过重写<code>performResize()</code> 和 <code>performLayout()</code>两个方法来实现，他们会在<code>layout()</code>中被调用。</p><h3 id="ParentData"><a href="#ParentData" class="headerlink" title="ParentData"></a>ParentData</h3><p>当layout结束后，每个节点的位置（相对于父节点的偏移）就已经确定了，<code>RenderObject</code>就可以根据位置信息来进行最终的绘制。但是在layout过程中，节点的位置信息怎么保存？对于大多数<code>RenderBox</code>子类来说如果子类只有一个子节点，那么子节点偏移一般都是<code>Offset.zero</code> ，如果有多个子节点，则每个子节点的偏移就可能不同。而子节点在父节点的偏移数据正是通过<code>RenderObject</code>的<code>parentData</code>属性来保存的。在<code>RenderBox</code>中，其<code>parentData</code>属性默认是一个<code>BoxParentData</code>对象，该属性只能通过父节点的<code>setupParentData()</code>方法来设置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderBox</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setupParentData(covariant RenderObject child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.parentData <span class="keyword">is</span>! BoxParentData)</span><br><span class="line">      child.parentData = BoxParentData();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BoxParentData</code>定义如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parentdata 会被RenderBox和它的子类使用.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxParentData</span> <span class="keyword">extends</span> <span class="title">ParentData</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// offset表示在子节点在父节点坐标系中的绘制偏移  </span></span><br><span class="line">  Offset offset = Offset.zero;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">'offset=<span class="subst">$offset<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>一定要注意，<code>RenderObject</code>的<code>parentData</code> 只能通过父元素设置.</p></blockquote><p>当然，<code>ParentData</code>并不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的<code>ParentData</code>中，如<code>ContainerBox</code>的<code>ParentData</code>就保存了指向兄弟节点的<code>previousSibling</code>和<code>nextSibling</code>，<code>Element.visitChildren()</code>方法也正是通过它们来实现对子节点的遍历。再比如<code>KeepAlive</code> 组件，它使用<code>KeepAliveParentDataMixin</code>（继承自<code>ParentData</code>） 来保存子节的<code>keepAlive</code>状态。</p><h1 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h1><p><code>RenderObject</code>可以通过<code>paint()</code>方法来完成具体绘制逻辑，流程和布局流程相似，子类可以实现<code>paint()</code>方法来完成自身的绘制逻辑，<code>paint()</code>签名如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>通过<code>context.canvas</code>可以取到<code>Canvas</code>对象，接下来就可以调用<code>Canvas</code> API来实现具体的绘制逻辑。</p><p>如果节点有子节点，它除了完成自身绘制逻辑之外，还要调用子节点的绘制方法。我们以<code>RenderFlex</code>对象为例说明：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果子元素未超出当前边界，则绘制子元素  </span></span><br><span class="line">  <span class="keyword">if</span> (_overflow &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">    defaultPaint(context, offset);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果size为空，则无需绘制</span></span><br><span class="line">  <span class="keyword">if</span> (size.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 剪裁掉溢出边界的部分</span></span><br><span class="line">  context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, defaultPaint);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> debugOverflowHints = <span class="string">'...'</span>; <span class="comment">//溢出提示内容，省略</span></span><br><span class="line">    <span class="comment">// 绘制溢出部分的错误提示样式</span></span><br><span class="line">    Rect overflowChildRect;</span><br><span class="line">    <span class="keyword">switch</span> (_direction) &#123;</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        overflowChildRect = Rect.fromLTWH(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width + _overflow, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        overflowChildRect = Rect.fromLTWH(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, size.height + _overflow);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    paintOverflowIndicator(context, offset, Offset.zero &amp; size,</span><br><span class="line">                           overflowChildRect, overflowHints: debugOverflowHints);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，首先判断有无溢出，如果没有则调用<code>defaultPaint(context, offset)</code>来完成绘制，该方法源码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  ChildType child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData;</span><br><span class="line">    <span class="comment">//绘制子节点， </span></span><br><span class="line">    context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，由于Flex本身没有需要绘制的东西，所以直接遍历其子节点，然后调用<code>paintChild()</code>来绘制子节点，同时将子节点<code>ParentData</code>中在layout阶段保存的offset加上自身偏移作为第二个参数传递给<code>paintChild()</code>。而如果子节点还有子节点时，<code>paintChild()</code>方法还会调用子节点的<code>paint()</code>方法，如此递归完成整个节点树的绘制，最终调用栈为： <em>paint() &gt; paintChild() &gt; paint() …</em> 。</p><p>当需要绘制的内容大小溢出当前空间时，将会执行<code>paintOverflowIndicator()</code> 来绘制溢出部分提示，这个就是我们经常看到的溢出提示，如图所示：</p><p><img src="/images/posts/Flutter/overflow.png" alt="overflow"></p><h2 id="RepaintBoundary"><a href="#RepaintBoundary" class="headerlink" title="RepaintBoundary"></a>RepaintBoundary</h2><p>我们已经在<code>CustomPaint</code>一节中介绍过<code>RepaintBoundary</code>，现在我们深入的了解一些。与 <code>RelayoutBoundary</code> 相似，<code>RepaintBoundary</code>是用于在确定重绘边界的，与<code>RelayoutBoundary</code>不同的是，这个绘制边界需要由开发者通过<code>RepaintBoundary</code> 组件自己指定，如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CustomPaint(</span><br><span class="line">  size: Size(<span class="number">300</span>, <span class="number">300</span>), <span class="comment">//指定画布大小</span></span><br><span class="line">  painter: MyPainter(),</span><br><span class="line">  child: RepaintBoundary(</span><br><span class="line">    child: Container(...),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>下面我们看看<code>RepaintBoundary</code>的原理，<code>RenderObject</code>有一个<code>isRepaintBoundary</code>属性，该属性决定这个<code>RenderObject</code>重绘时是否独立于其父元素，如果该属性值为<code>true</code> ，则独立绘制，反之则一起绘制。那独立绘制是怎么实现的呢？ 答案就在<code>paintChild()</code>源码中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    _compositeChild(child, offset);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，在绘制子节点时，如果<code>child.isRepaintBoundary</code> 为 <code>true</code>则会调用<code>_compositeChild()</code>方法，<code>_compositeChild()</code>源码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="comment">// 给子节点创建一个layer ，然后再上面绘制子节点 </span></span><br><span class="line">  <span class="keyword">if</span> (child._needsPaint) &#123;</span><br><span class="line">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(child._layer != <span class="keyword">null</span>);</span><br><span class="line">  child._layer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显了，独立绘制是通过在不同的layer（层）上绘制的。所以，很明显，正确使用<code>isRepaintBoundary</code>属性可以提高绘制效率，避免不必要的重绘。具体原理是：和触发重新build和layout类似，<code>RenderObject</code>也提供了一个<code>markNeedsPaint()</code>方法，其源码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="comment">//如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制  </span></span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//找到最近的layer，绘制  </span></span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="comment">// 没有自己的layer, 会和一个祖先节点共用一个layer  </span></span><br><span class="line">    <span class="keyword">assert</span>(_layer == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="comment">// 向父级递归查找  </span></span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">this</span>.parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。  </span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当调用 <code>markNeedsPaint()</code> 方法时，会从当前 <code>RenderObject</code> 开始一直向父节点查找，直到找到 一个<code>isRepaintBoundary</code> 为 <code>true</code>的<code>RenderObject</code> 时，才会触发重绘，这样便可以实现局部重绘。当 有<code>RenderObject</code> 绘制的很频繁或很复杂时，可以通过RepaintBoundary Widget来指定<code>isRepaintBoundary</code> 为 <code>true</code>，这样在绘制时仅会重绘自身而无需重绘它的 parent，如此便可提高性能。</p><p>还有一个问题，通过<code>RepaintBoundary</code> 如何设置<code>isRepaintBoundary</code>属性呢？其实，如果使用了<code>RepaintBoundary</code>，其对应的<code>RenderRepaintBoundary</code>会自动将<code>isRepaintBoundary</code>设为<code>true</code>的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderRepaintBoundary</span> <span class="keyword">extends</span> <span class="title">RenderProxyBox</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates a repaint boundary around [child].</span></span><br><span class="line">  RenderRepaintBoundary(&#123; RenderBox child &#125;) : <span class="keyword">super</span>(child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h1><p>一个对象是否可以响应事件，取决于其对命中测试的返回，当发生用户事件时，会从根节点（<code>RenderView</code>）开始进行命中测试，下面是<code>RenderView</code>的<code>hitTest()</code>源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child.hitTest(result, position: position); <span class="comment">//递归子RenderBox进行命中测试</span></span><br><span class="line">  result.add(HitTestEntry(<span class="keyword">this</span>)); <span class="comment">//将测试结果添加到result中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看看<code>RenderBox</code>默认的<code>hitTest()</code>实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; <span class="meta">@required</span> Offset position &#125;) &#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">if</span> (_size.contains(position)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;</span><br><span class="line">      result.add(BoxHitTestEntry(<span class="keyword">this</span>, position));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到默认的实现里调用了<code>hitTestSelf()</code>和<code>hitTestChildren()</code>两个方法，这两个方法默认实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">bool</span> hitTestSelf(Offset position) =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">bool</span> hitTestChildren(HitTestResult result, &#123; Offset position &#125;) =&gt; <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p><code>hitTest</code> 方法用来判断该<code>RenderObject</code> 是否在被点击的范围内，同时负责将被点击的 <code>RenderBox</code> 添加到 <code>HitTestResult</code> 列表中，参数 <code>position</code> 为事件触发的坐标（如果有的话），返回 true 则表示有<code>RenderBox</code> 通过了命中测试，需要响应事件，反之则认为当前<code>RenderBox</code>没有命中。在继承<code>RenderBox</code>时，可以直接重写<code>hitTest()</code>方法，也可以重写 <code>hitTestSelf()</code> 或 <code>hitTestChildren()</code>, 唯一不同的是 <code>hitTest()</code>中需要将通过命中测试的节点信息添加到命中测试结果列表中，而 <code>hitTestSelf()</code> 和 <code>hitTestChildren()</code>则只需要简单的返回<code>true</code>或<code>false</code>。</p><h1 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h1><p>语义化即Semantics，主要是提供给读屏软件的接口，也是实现辅助功能的基础，通过语义化接口可以让机器理解页面上的内容，对于有视力障碍用户可以使用读屏软件来理解UI内容。如果一个<code>RenderObject</code>要支持语义化接口，可以实现 <code>describeApproximatePaintClip</code>和 <code>visitChildrenForSemantics</code>方法和<code>semanticsAnnotator</code> getter。更多关于语义化的信息可以查看API文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了<code>RenderObject</code>主要的功能和方法，理解这些内容可以帮助我们更好的理解Flutter UI底层原理。我们也可以看到，如果要从头到尾实现一个<code>RenderObject</code>是比较麻烦的，我们必须去实现layout、绘制和命中测试逻辑，但是值得庆幸的是，大多数时候我们可以直接在Widget层通过组合或者<code>CustomPaint</code>完成自定义UI。如果遇到只能定义一个新<code>RenderObject</code>的场景时（如要实现一个新的layout算法的布局容器），可以直接继承自<code>RenderBox</code>，这样可以帮我们减少一部分工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://book.flutterchina.club/chapter14/render_object.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;14.3 RenderObject和RenderBox&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「原创」Flutter 输入框获得焦点失效问题</title>
    <link href="http://blog.ennis.info/2020/04/10/Flutter%E8%BE%93%E5%85%A5%E6%A1%86%E8%8E%B7%E5%BE%97%E7%84%A6%E7%82%B9%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ennis.info/2020/04/10/Flutter输入框获得焦点失效问题/</id>
    <published>2020-04-10T05:46:57.000Z</published>
    <updated>2020-05-18T17:46:52.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Flutter 中 <code>TextField</code> 由 <code>disable</code> 状态变为 <code>enable</code> 状态时获取焦点会失效，比如下面这段代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> focusNode = FocusNode();</span><br><span class="line">  <span class="keyword">var</span> editable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      editable = !editable;</span><br><span class="line">      <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">        FocusScope.of(context).requestFocus(focusNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'输入框获得焦点'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: TextField(</span><br><span class="line">          focusNode: focusNode,</span><br><span class="line">          enabled: editable,</span><br><span class="line">          decoration: InputDecoration(hintText: <span class="string">'输入'</span>),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: _changeFocus,</span><br><span class="line">          child: Icon(Icons.edit),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是这样</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    editable = !editable;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">      FocusScope.of(context).requestFocus(focusNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望将 <code>TextField</code> 的状态改为 <code>enable</code> 并获得焦点，但这两种写法都是无法获取到焦点的。</p><p><img src="/images/posts/Flutter/focus_failure.gif" alt=""></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>我们知道 Flutter 是通过事件驱动更新 UI 的，通过 <code>setState()</code> 方法添加一个更新 UI 事件，当这个事件到达时就会更新 UI。</p><p>上述写法失效的原因就在于我们获取焦点时 UI 还未更新，<code>TextField</code> 还处于 <code>disable</code> 状态，是无法获取到焦点的。</p><p>我们应该在 <code>build()</code> 方法完成后获取焦点，这时 <code>TextField</code> 已处于 <code>enable</code> 状态。</p><h1 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback()"></a>addPostFrameCallback()</h1><p>通过 <code>SchedulerBinding.instance.addPostFrameCallback()</code> 方法可以<strong>注册下一帧绘制完成回调</strong>方法。</p><p>该回调只会在下一帧绘制结束时<strong>被调用一次</strong>，调用后会被系统移除。</p><p>可以通过该方法监听下一次 <code>build</code> 完成，然后获取焦点。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>下面的写法就可以成功获取到焦点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _changeFocus() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    editable = !editable;</span><br><span class="line">    <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">      SchedulerBinding.instance.addPostFrameCallback(</span><br><span class="line">          (_) =&gt; FocusScope.of(context).requestFocus(focusNode));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/posts/Flutter/focus_success.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;Flutter 中 &lt;code&gt;TextField&lt;/code&gt; 由 &lt;code&gt;disable&lt;/code&gt; 状态变为 &lt;
      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」为什么双重检查单例需要使用 volatile 关键字</title>
    <link href="http://blog.ennis.info/2020/04/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8D%95%E4%BE%8B%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://blog.ennis.info/2020/04/10/为什么双重检查单例需要使用volatile关键字/</id>
    <published>2020-04-10T04:17:24.000Z</published>
    <updated>2020-05-18T17:45:44.269Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><ul><li><p>CPU 从高速缓存存取数据</p></li><li><p>多核 CPU 每个线程有自己的高速缓存</p></li></ul><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>通过 <code>synchronized</code> 和 <code>Lock</code> 保证原子性</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul><li>通过 <code>synchronized</code> 和 <code>Lock</code> 保证可见性</li></ul><p>在锁释放之前将修改的变量刷新到主存</p><ul><li>变量通过 <code>volatile</code> 关键字修饰保证可见性</li></ul><p>修改变量立即刷新到主存</p><p>读取变量强制到主存读取</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ul><li>通过 <code>synchronized</code> 和 <code>Lock</code> 保证有序性</li></ul><h2 id="Java-内存模型-happens-before-原则"><a href="#Java-内存模型-happens-before-原则" class="headerlink" title="Java 内存模型 happens-before 原则"></a>Java 内存模型 happens-before 原则</h2><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p></li><li><p>锁定规则：一个 <code>unLock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作</p></li><li><p><code>volatile</code> 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p></li><li><p>传递规则：如果操作 A 先行发生于操作 B ，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则：<code>Thread</code> 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作</p></li><li><p>线程中断规则：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的 <code>finalize()</code> 方法的开始</p></li></ul><h1 id="volatile-关键字的两层语义"><a href="#volatile-关键字的两层语义" class="headerlink" title="volatile 关键字的两层语义"></a>volatile 关键字的两层语义</h1><ol><li><p>保证变量的可见性</p></li><li><p>禁止指令重排序</p></li></ol><h1 id="为什么双重检查单例需要使用-volatile-关键字"><a href="#为什么双重检查单例需要使用-volatile-关键字" class="headerlink" title="为什么双重检查单例需要使用 volatile 关键字"></a>为什么双重检查单例需要使用 volatile 关键字</h1><p><code>instance = new Singleton();</code> 不是一个原子操作，可以分为 3 步：</p><ol><li><p>分配内存空间</p></li><li><p>初始化对象</p></li><li><p>将 <code>instance</code> 指向内存地址</p></li></ol><p>由于存在指令重排，执行顺序可能变为 <em>1 -&gt; 3 -&gt; 2</em>。</p><p>当 3 执行完，2 未执行时，新线程进入检查 <code>instance != null</code>，直接返回，会抛出对象未初始化错误。</p><p><strong>使用 volatile 可以禁止指令重排</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920373.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：volatile关键字解析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;内存模
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.ennis.info/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.ennis.info/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.ennis.info/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」事件分发流程简述</title>
    <link href="http://blog.ennis.info/2020/04/09/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%AE%80%E8%BF%B0/"/>
    <id>http://blog.ennis.info/2020/04/09/事件分发简述/</id>
    <published>2020-04-09T05:19:13.000Z</published>
    <updated>2020-05-18T17:44:49.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650244875&amp;idx=1&amp;sn=a5a93c1521c82462fd8fba9a5cc43c8e" target="_blank" rel="noopener">通过流程图来分析Android事件分发</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650248970&amp;idx=1&amp;sn=478b60c19371371e3d430ce2a6bc1403" target="_blank" rel="noopener">事件分发机制，我们从细节中学习！</a></p></li></ul><h1 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h1><blockquote><p>Android 用来描述手对屏幕做的事情得最小单元<br>关键字：手势，最小单元</p></blockquote><p>点击事件、长按事件、滑动事件由不可拆分得事件组合。</p><h1 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h1><ul><li>事件类型</li></ul><p><code>getAction()</code></p><p>如 <code>ACTION_DOWN</code>（按下）、<code>ACTION_ MOVE</code>（移动）、<code>ACTION_ UP</code>（抬起）等</p><ul><li>屏幕参考线坐标</li></ul><p><code>getRawX()</code></p><p><code>getRawY()</code></p><ul><li>View 参考系坐标</li></ul><p><code>getX()</code></p><p><code>getY()</code></p><h1 id="事件序列"><a href="#事件序列" class="headerlink" title="事件序列"></a>事件序列</h1><ol><li><p><code>ACTION_DOWN</code>（1个）</p></li><li><p><code>ACTION_MOVE</code>（N个）</p></li><li><p><code>ACTION_UP</code>（1个）</p></li></ol><h1 id="TouchTarget"><a href="#TouchTarget" class="headerlink" title="TouchTarget"></a>TouchTarget</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="child"><a href="#child" class="headerlink" title="child"></a>child</h2><ul><li>消耗事件的目标 <code>View</code></li></ul><h2 id="pointerIdBits"><a href="#pointerIdBits" class="headerlink" title="pointerIdBits"></a>pointerIdBits</h2><ul><li>目标捕获的所有指针 id 的组合位掩码</li></ul><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ul><li>组成链表</li></ul><h1 id="dispatchTouchEvent-MotionEvent"><a href="#dispatchTouchEvent-MotionEvent" class="headerlink" title="dispatchTouchEvent(MotionEvent)"></a>dispatchTouchEvent(MotionEvent)</h1><ul><li><p>分发触摸事件给 <code>Target</code>（包括自己）</p></li><li><p>返回是否已处理触摸事件</p></li><li><p><code>View</code> 不存在子 <code>View</code> 所以不存在分发，只处理自己</p></li></ul><h1 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h1><p>dispatchTouchEvent(MotionEvent)</p><p><img src="/images/posts/android/event/view_dispatch_event.svg" alt="" title="View 事件分发"></p><h1 id="ViewGroup-的事件分发"><a href="#ViewGroup-的事件分发" class="headerlink" title="ViewGroup 的事件分发"></a>ViewGroup 的事件分发</h1><p>dispatchTouchEvent(MotionEvent)</p><p><img src="/images/posts/android/event/view_group_dispatch_event.svg" alt="" title="ViewGroup 事件分发"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>责任链模式，但不是纯责任链模式</p></li><li><p><code>target</code>、<code>disallowIntercept</code> 影响 1 个事件序列的不同触摸事件</p></li><li><p><code>ACTION_DOWN</code> 事件寻找 <code>target</code></p></li><li><p>非 <code>ACTION_DOWN</code> 使用 <code>target</code>，根据 <code>target</code> 和 <code>disallowIntercept</code> 控制事件传递流程</p></li><li><p>事件传递可能被抛回来</p></li></ul><h2 id="ACTION-DOWN-事件"><a href="#ACTION-DOWN-事件" class="headerlink" title="ACTION_DOWN 事件"></a>ACTION_DOWN 事件</h2><ol><li>清空 <code>target</code></li></ol><p>无需考虑 <code>disallowIntercept</code></p><ol start="2"><li><p><code>onInterceptTouchEvent()</code> 不拦截，沿着责任链向后传</p></li><li><p>子 <code>View</code> 处理，找到 <code>target</code>，返回 <code>true</code></p></li><li><p>子 <code>View</code> 不处理，<code>ViewGroup</code> 事件分发退化为 <code>View</code> 事件分发</p></li></ol><p>返回 <code>super.dispatchTouchEvent()</code></p><ol start="5"><li><code>onInterceptTouchEvent()</code> 拦截</li></ol><p>返回 <code>super.dispatchTouchEvent()</code></p><h2 id="非-ACTION-DOWN-事件"><a href="#非-ACTION-DOWN-事件" class="headerlink" title="非 ACTION_DOWN 事件"></a>非 ACTION_DOWN 事件</h2><ol><li>检查是否有 <code>target</code></li></ol><h3 id="无-target"><a href="#无-target" class="headerlink" title="无 target"></a>无 target</h3><p>返回 <code>super.dispatchTouchEvent()</code></p><h3 id="有-target"><a href="#有-target" class="headerlink" title="有 target"></a>有 target</h3><ul><li><p>子 <code>View</code> 禁止拦截，直接传递给 <code>target</code></p></li><li><p>子 <code>View</code> 不禁止拦截，<code>onInterceptEvent()</code> 不拦截，传递给 <code>target</code></p></li><li><p>子 <code>View</code> 不禁止拦截，<code>onInterceptEvent()</code> 拦截</p></li></ul><p>返回 <code>super.dispatchTouchEvent()</code></p><h3 id="disallowIntercept-变量"><a href="#disallowIntercept-变量" class="headerlink" title="disallowIntercept 变量"></a>disallowIntercept 变量</h3><ul><li><p>通过 <code>public requestDisallowInterceptTouchEvent(boolean)</code> 设置</p></li><li><p><code>true</code> 标识禁止拦截，即子 <code>View</code> 一定要这个事件</p></li><li><p><code>false</code> 表示不禁止拦截，即子 <code>View</code> 不知道要不要</p></li></ul><h1 id="两级-View-事件分发规律"><a href="#两级-View-事件分发规律" class="headerlink" title="两级 View 事件分发规律"></a>两级 View 事件分发规律</h1><h2 id="ViewGroup-需要所有事件"><a href="#ViewGroup-需要所有事件" class="headerlink" title="ViewGroup 需要所有事件"></a>ViewGroup 需要所有事件</h2><ul><li><p><code>ACTION_DOWN</code> 事件里拦截事件，不传递给子 <code>View</code></p></li><li><p><code>ACTION_DOWN</code> 事件 -&gt; <code>onInterceptTouchEvent()</code> 拦截 -&gt; <code>super.dispatchTouchEvent()</code></p></li></ul><h2 id="子-View-需要所有事件"><a href="#子-View-需要所有事件" class="headerlink" title="子 View 需要所有事件"></a>子 View 需要所有事件</h2><ul><li><p>设置 <code>disallowIntercept</code> 禁止拦截</p></li><li><p><code>ACTION_DOWN</code> 事件 -&gt; <code>onInterceptTouchEvent()</code> 不拦截 -&gt; 子 <code>View</code> 的 <code>dispatchTouchEvent()</code>，设置 <code>disallowIntercept</code> 禁止拦截</p></li></ul><h2 id="ViewGroup-和子-View-需要特定事件"><a href="#ViewGroup-和子-View-需要特定事件" class="headerlink" title="ViewGroup 和子 View 需要特定事件"></a>ViewGroup 和子 View 需要特定事件</h2><ul><li><p><code>ACTION_DOWN</code> 事件，<code>ViewGroup</code> 不拦截，子 <code>View</code> 必须处理</p></li><li><p>不确定是否处理，<code>target</code> -&gt; <code>disallowIntercept</code> 不禁止拦截 -&gt; <code>onInterceptTouchEvent()</code> 不拦截 -&gt; 子 <code>View</code> 的 <code>dispatchTouchEvent()</code></p></li><li><p><code>ViewGroup</code> 决定要的事件，<code>onInterceptTouchEvent()</code> 拦截</p></li><li><p><code>View</code> 决定要的事件，设置 <code>disallowIntercept</code> 禁止拦截</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;am
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
      <category term="事件分发" scheme="http://blog.ennis.info/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」TCP 为什么需要 3 次握手和 4 次挥手</title>
    <link href="http://blog.ennis.info/2020/03/26/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%813%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://blog.ennis.info/2020/03/26/TCP为什么需要3次握手和4次挥手/</id>
    <published>2020-03-26T07:36:35.000Z</published>
    <updated>2020-05-18T18:08:45.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><p><a href="https://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="noopener">TCP为什么需要3次握手与4次挥手</a></p></li><li><p><a href="https://juejin.im/post/5d5414cb6fb9a06b20055e27" target="_blank" rel="noopener">iOS：为什么TCP连接要三次握手，四次挥手</a></p></li></ul><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>为什么便于阅读，我们将三次握手称为 hello1，hello2，hello3。</p><h2 id="防止服务端一直等待"><a href="#防止服务端一直等待" class="headerlink" title="防止服务端一直等待"></a>防止服务端一直等待</h2><p><strong>假设只需要两次握手</strong>，如果服务端收到一条已失效的 hello1 请求，服务端会认为是客户端的新请求并回复 hello2 ，客户端收到后不会 hello3 和发送数据，这时候<strong>服务端会一直保持等待状态，浪费资源</strong>。</p><h2 id="从另一个角度思考"><a href="#从另一个角度思考" class="headerlink" title="从另一个角度思考"></a>从另一个角度思考</h2><ol><li><p>A 向 B 发送 hello1：B 确认 A 发送正常，B 接收正常</p></li><li><p>B 向 A 发送 hello2：A 确认 A 发送接收正常，B 发送接收正常</p></li><li><p>A 向 B 发送 hello3：B 确认 A 接收正常，B 发送正常</p></li></ol><p><strong>三次握手可以保证客户端和服务端双方确认双方的发送和接收都是正常的。</strong></p><h2 id="三次握手状态"><a href="#三次握手状态" class="headerlink" title="三次握手状态"></a>三次握手状态</h2><p><img src="/images/posts/TCPIP/tcp_syn.jpg" alt=""></p><ol><li>客户端发送：SYN = 1, seq = x</li></ol><p>客户端 SYN-SENT 状态</p><ol start="2"><li>服务端发送：SYN = 1, seq = y, ACK = 1, ack = x + 1</li></ol><p>服务端 SYN-RCVD 状态</p><ol start="3"><li>客户端发送：ACK = 1, ack = y + 1</li></ol><p>客户端，服务端 ESTABLISHED 状态</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="四次挥手状态"><a href="#四次挥手状态" class="headerlink" title="四次挥手状态"></a>四次挥手状态</h2><p><img src="/images/posts/TCPIP/tcp_fin.jpg" alt=""></p><ol><li>客户端发送：FIN = 1, seq = x</li></ol><p><strong>客户端停止发送数据，但接收数据</strong></p><p>客户端 FIN-WAIT-1 状态</p><ol start="2"><li>服务端发送：seq = y, ACK = 1, ack = x + 1</li></ol><p><strong>服务端确认，发送最后的数据</strong></p><p>服务端 CLOSE-WAIT 状态</p><p>客户端 FIN-WAIT-2 状态</p><ol start="3"><li>服务端发送：FIN = 1, seq = z, ACK = 1, ack = x + 1</li></ol><p><strong>服务端停止发送数据</strong></p><p>服务端 LAST-ACK 状态</p><ol start="4"><li>客户端发送：seq = x + 1, ACK = 1, ack = z + 1</li></ol><p>服务端 CLOSE 状态</p><p>客户端 TIME-WAIT 状态，2MSL 后 CLOSE 状态</p><h2 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h2><p>因为 TCP 是全双工模式，双方都都需要确认关闭，为了保证服务端的数据发送完全，服务端的 ACK 和 FIN 分为两个报文发送（对比三次握手）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xifeijian/article/details/1277
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://blog.ennis.info/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://blog.ennis.info/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://blog.ennis.info/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>「转载」Flutter 动画曲线 Curves 效果一览</title>
    <link href="http://blog.ennis.info/2020/03/23/%E8%BD%AC-Flutter%E5%8A%A8%E7%94%BB%E6%9B%B2%E7%BA%BFCurves%E6%95%88%E6%9E%9C%E4%B8%80%E8%A7%88/"/>
    <id>http://blog.ennis.info/2020/03/23/转-Flutter动画曲线Curves效果一览/</id>
    <published>2020-03-23T14:10:23.000Z</published>
    <updated>2020-05-18T17:43:14.788Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_17766199/article/details/95632571" target="_blank" rel="noopener">Flutter 动画曲线 Curves 效果一览</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_17766199/article/details/95632571&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter 动画曲线 Curves 效果一览&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」HTTPS 是如何保证安全的</title>
    <link href="http://blog.ennis.info/2020/03/20/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84/"/>
    <id>http://blog.ennis.info/2020/03/20/HTTPS是如何保证安全的/</id>
    <published>2020-03-20T12:46:31.000Z</published>
    <updated>2020-05-18T17:42:47.688Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.csdn.net/guolin_blog/article/details/104546558" target="_blank" rel="noopener">写一篇最好懂的HTTPS讲解</a></p><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><ul><li><p>客户端和服务端使用同一个密钥</p></li><li><p>加解密效率高</p></li></ul><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><ul><li><p>密钥分为公钥和私钥</p></li><li><p>公钥加密只有私钥才能解密</p></li><li><p>私钥加密只有公钥才能解密</p></li><li><p>公钥一般存放在客户端，私钥一般存放在服务端</p></li><li><p>安全性更高</p></li></ul><h1 id="HTTPS-原理简述"><a href="#HTTPS-原理简述" class="headerlink" title="HTTPS 原理简述"></a>HTTPS 原理简述</h1><ol><li><p>网站管理员向 CA 机构申请证书</p><ul><li><p>证书包含该网站的公钥，域名等其他信息</p></li><li><p>证书使用 CA 自己的私钥加密</p></li></ul></li><li><p>服务端配置证书</p></li><li><p>客户端发起请求，服务端返回证书</p></li><li><p>客户端使用 CA 的公钥解密证书</p><ul><li><p>解密成功且域名和其他信息与该网站相符则安全</p></li><li><p>得到网站公钥</p></li></ul></li><li><p>客户端与服务端商定对称加密密钥</p><ul><li><p>过程中客户端使用网站公钥，服务端使用私钥</p></li><li><p>对称加密密钥由客户端随机生成</p></li></ul></li><li><p>双方使用对称加密通信</p></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么-HTTP-不安全"><a href="#为什么-HTTP-不安全" class="headerlink" title="为什么 HTTP 不安全"></a>为什么 HTTP 不安全</h2><ul><li><p>明文传输</p></li><li><p>可能被监听</p></li><li><p>可能被篡改</p></li></ul><h2 id="如何既保证效率又保证安全"><a href="#如何既保证效率又保证安全" class="headerlink" title="如何既保证效率又保证安全"></a>如何既保证效率又保证安全</h2><ul><li><p>保证效率</p><ul><li>采用对称加密</li></ul></li><li><p>保证安全</p><ul><li><p>对称加密密钥由客户端随机生成</p></li><li><p>首次商定密钥使用非对称加密，客户端公钥加密，服务端私钥解密</p></li></ul></li></ul><h2 id="如何保证获的服务端公钥不被篡改"><a href="#如何保证获的服务端公钥不被篡改" class="headerlink" title="如何保证获的服务端公钥不被篡改"></a>如何保证获的服务端公钥不被篡改</h2><ul><li><p>由 CA 机构签发证书，证书包含网站公钥和域名等其他信息</p></li><li><p>证书使用 CA 机构私钥加密</p></li><li><p>CA 机构数量有限，操作系统可以内置所有 CA 机构公钥</p></li></ul><h2 id="HTTPS-使用对称加密还是非对称加密？"><a href="#HTTPS-使用对称加密还是非对称加密？" class="headerlink" title="HTTPS 使用对称加密还是非对称加密？"></a>HTTPS 使用对称加密还是非对称加密？</h2><p>HTTP 使用两种加密结合的方式</p><ul><li><p>CA 证书使用非对称加密</p></li><li><p>网站商定密钥使用非对称加密</p></li><li><p>传输内容使用对称加密</p></li></ul><h2 id="为什么不直接使用非对称加密通信？"><a href="#为什么不直接使用非对称加密通信？" class="headerlink" title="为什么不直接使用非对称加密通信？"></a>为什么不直接使用非对称加密通信？</h2><p>对称加密更高效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/104546558&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;写一篇最好懂的HTTPS讲解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;对称
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://blog.ennis.info/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://blog.ennis.info/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://blog.ennis.info/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」BuildContext是什么？</title>
    <link href="http://blog.ennis.info/2020/03/19/BuildContext%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://blog.ennis.info/2020/03/19/BuildContext是什么？/</id>
    <published>2020-03-19T08:23:08.000Z</published>
    <updated>2020-05-18T17:42:10.894Z</updated>
    
    <content type="html"><![CDATA[<p><strong>小部件树中小部件位置的句柄。</strong></p><p>此类提供了一组可以从 <code>StatelessWidget.build</code> 方法和 <code>State</code> 对象上的方法使用的方法。</p><p><code>BuildContext</code> 对象将传递到 <code>WidgetBuilder</code> 函数（例如 <code>StatelessWidget.build</code>），并且可以从 <code>State.context</code> 成员获得。一些静态函数（例如 <code>showDialog</code>，<code>Theme.of</code> 等）也采用构建上下文，以便它们可以代表调用窗口小部件执行操作，或获取特定于给定上下文的数据。</p><p><strong>每个窗口小部件都有其自己的BuildContext</strong>，它将成为 <code>StatelessWidget.build</code> 或 <code>State.build</code> 函数返回的窗口小部件的父级。 （同样，<code>RenderObjectWidgets</code> 的任何子项的父项。）</p><p>随着小部件在树上移动，特定小部件的 <code>BuildContext</code> 可以随时间改变位置。因此，从类的方法返回的值不应在执行单个同步函数之后进行缓存。</p><p><strong>BuildContext对象实际上是Element对象。 BuildContext接口用于阻止对Element对象的直接操作。</strong></p><p>原文：<a href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" target="_blank" rel="noopener">BuildContext class</a></p><blockquote><p>A handle to the location of a widget in the widget tree.</p><p>This class presents a set of methods that can be used from <code>StatelessWidget.build</code> methods and from methods on <code>State</code> objects.</p><p><code>BuildContext</code> objects are passed to <code>WidgetBuilder</code> functions (such as <code>StatelessWidget.build</code>), and are available from the <code>State.context</code> member. Some static functions (e.g. <code>showDialog</code>, <code>Theme.of</code>, and so forth) also take build contexts so that they can act on behalf of the calling widget, or obtain data specifically for the given context.</p><p>Each widget has its own <code>BuildContext</code>, which becomes the parent of the widget returned by the <code>StatelessWidget.build</code> or <code>State.build</code> function. (And similarly, the parent of any children for <code>RenderObjectWidget</code>s.)</p><p>The <code>BuildContext</code> for a particular widget can change location over time as the widget is moved around the tree. Because of this, values returned from the methods on this class should not be cached beyond the execution of a single synchronous function.</p><p><code>BuildContext</code> objects are actually <code>Element</code> objects. The <code>BuildContext</code> interface is used to discourage direct manipulation of <code>Element</code> objects.</p></blockquote><p><img src="/images/posts/Flutter/build_context_class_diagram.png" alt="BuildContext继承关系图" title="BuildContext继承关系图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;小部件树中小部件位置的句柄。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此类提供了一组可以从 &lt;code&gt;StatelessWidget.build&lt;/code&gt; 方法和 &lt;code&gt;State&lt;/code&gt; 对象上的方法使用的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bui
      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「转载」When &amp; Where 使用 Key，怎样选择 Key</title>
    <link href="http://blog.ennis.info/2020/03/18/When-Where%E4%BD%BF%E7%94%A8Key%EF%BC%8C%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9Key/"/>
    <id>http://blog.ennis.info/2020/03/18/When-Where使用Key，怎样选择Key/</id>
    <published>2020-03-18T14:02:40.000Z</published>
    <updated>2020-05-18T17:41:10.927Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc" target="_blank" rel="noopener">何时使用密钥 - Flutter小部件 101 第四集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=kn0EOS-ZiIc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;何时使用密钥 - Flutter小部件 101 第四集&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「原创」为什么嵌套一层 Builder 后 Scaffold.of 方法就不报错了</title>
    <link href="http://blog.ennis.info/2020/03/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B5%8C%E5%A5%97%E4%B8%80%E5%B1%82Builder%E5%90%8EScaffold-of%E6%96%B9%E6%B3%95%E5%B0%B1%E4%B8%8D%E6%8A%A5%E9%94%99%E4%BA%86/"/>
    <id>http://blog.ennis.info/2020/03/18/为什么嵌套一层Builder后Scaffold-of方法就不报错了/</id>
    <published>2020-03-18T06:04:31.000Z</published>
    <updated>2020-05-18T17:40:03.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h1><p>我们可能经常需要调用 <code>Scaffold.of()</code> 方法去调用 <code>showSnackBar</code> 或 <code>showBottomSheet</code> 等方法，如下面的代码所示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          Scaffold.of(context)</span><br><span class="line">              .showSnackBar(SnackBar(content: Text(<span class="string">'This is SnackBar!'</span>)));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行这段代码点击按钮后却报出这样的错误：</p><blockquote><p>The following assertion was thrown while handling a gesture:<br><strong>Scaffold.of() called with a context that does not contain a Scaffold.</strong></p><p>No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). This usually happens when the context provided is from the same StatefulWidget as that whose build function actually creates the Scaffold widget being sought.</p></blockquote><p><code>context</code> 没有在祖先 <code>Widget</code> 中找到 <code>Scaffold</code>。<code>FloatingActionBottom</code> 明明是 <code>Scaffold</code> 的孩子 <code>Widget</code>，为什么没有找到呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方案一-嵌套一层-Builder"><a href="#方案一-嵌套一层-Builder" class="headerlink" title="方案一 嵌套一层 Builder"></a>方案一 嵌套一层 Builder</h2><p>如下面代码所示，在 <code>FloatingActionButton</code> 外添加一层 <code>Builder</code> 便可以正常运行。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    floatingActionButton: Builder(</span><br><span class="line">      builder: (context) =&gt; FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          Scaffold.of(context)</span><br><span class="line">              .showSnackBar(SnackBar(content: Text(<span class="string">'This is SnackBar!'</span>)));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-使用-GlobalKey"><a href="#方法二-使用-GlobalKey" class="headerlink" title="方法二 使用 GlobalKey"></a>方法二 使用 GlobalKey</h2><h1 id="of-方法的原理"><a href="#of-方法的原理" class="headerlink" title=".of 方法的原理"></a>.of 方法的原理</h1><p>由源码可知，通过传入的 <code>BuildContext</code> 调用 <code>findAncestorStateOfType</code> 方法找到祖先 <code>ScaffoldState</code>，当祖先 <code>Widget</code> 中没有 <code>Scaffold</code> 时报错。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ScaffoldState of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(nullOk != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> ScaffoldState result = context.findAncestorStateOfType&lt;ScaffoldState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nullOk || result != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[</span><br><span class="line">      ErrorSummary(</span><br><span class="line">        <span class="string">'...'</span></span><br><span class="line">      ),</span><br><span class="line">      ErrorDescription(</span><br><span class="line">        <span class="string">'...'</span></span><br><span class="line">      ),</span><br><span class="line">      ErrorHint(</span><br><span class="line">        <span class="string">'...'</span></span><br><span class="line">      ),</span><br><span class="line">      ErrorHint(</span><br><span class="line">        <span class="string">'...'</span></span><br><span class="line">      ),</span><br><span class="line">      context.describeElement(<span class="string">'The context used was'</span>)</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><p>从错误案例代码我们可以看到，传入 <code>of</code> 的 <code>BuildContext</code> 是 <code>_MyHomePageState</code> 中 <code>build</code> 方法的参数，显然 <code>_MyHomePageState</code> 的祖先中并没有 <code>Scaffold</code>，所以报错没有找到 <code>Scaffold</code>。</p><p><img src="/images/posts/Flutter/scaffold_no_builder.png" alt=""></p><h1 id="Builder-的原理"><a href="#Builder-的原理" class="headerlink" title="Builder 的原理"></a>Builder 的原理</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> WidgetBuilder = Widget <span class="built_in">Function</span>(BuildContext context);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Builder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> WidgetBuilder builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; builder(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，<code>Builder</code> 接收一个 <code>WidgetBuilder</code> 方法，在 <code>build</code> 方法中回调了 <code>WidgetBuilder</code> 方法，并将自己的 <code>BuildContext</code> 传入。</p><h1 id="解决原因"><a href="#解决原因" class="headerlink" title="解决原因"></a>解决原因</h1><p>为了便于查看，我们将修正后源码中 <code>_MyHomePageState.build</code> 的参数名改为 <code>contextA</code>，将传入 <code>Builder</code> 的 <code>WidgetBuilder</code> 方法的参数名改为 <code>contextB</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext contextA) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    floatingActionButton: Builder(</span><br><span class="line">      builder: (contextB) =&gt; FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          Scaffold.of(contextB)</span><br><span class="line">              .showSnackBar(SnackBar(content: Text(<span class="string">'This is SnackBar!'</span>)));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由修正的代码可知，我们传入 <code>Scaffold.of</code> 方法的 <code>BuildContext</code> 已经不再是 <code>_MyHomePageState</code> 的了，而是 <code>Builder</code> 的。而 <code>Builder</code> 的父 <code>Widget</code> 正是 <code>Scaffold</code>，所以正常运行。</p><p><img src="/images/posts/Flutter/scaffold_builder.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误案例&quot;&gt;&lt;a href=&quot;#错误案例&quot; class=&quot;headerlink&quot; title=&quot;错误案例&quot;&gt;&lt;/a&gt;错误案例&lt;/h1&gt;&lt;p&gt;我们可能经常需要调用 &lt;code&gt;Scaffold.of()&lt;/code&gt; 方法去调用 &lt;code&gt;showSnackBar
      
    
    </summary>
    
      <category term="Flutter" scheme="http://blog.ennis.info/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://blog.ennis.info/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>「原创」LinkedHashMap 的相关问题</title>
    <link href="http://blog.ennis.info/2020/02/29/LinkedHashMap%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ennis.info/2020/02/29/LinkedHashMap的相关问题/</id>
    <published>2020-02-29T11:21:49.000Z</published>
    <updated>2020-05-18T17:36:17.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下源码基于 JDK 10</p></blockquote><h1 id="LinkedHashMap-是什么"><a href="#LinkedHashMap-是什么" class="headerlink" title="LinkedHashMap 是什么"></a>LinkedHashMap 是什么</h1><p>LinkedHashMap = HashMap + LinkedList</p><h1 id="LinkedHashMap-主要作用"><a href="#LinkedHashMap-主要作用" class="headerlink" title="LinkedHashMap 主要作用"></a>LinkedHashMap 主要作用</h1><h2 id="实现按添加的顺序访问"><a href="#实现按添加的顺序访问" class="headerlink" title="实现按添加的顺序访问"></a>实现按添加的顺序访问</h2><ul><li>迭代时按添加的顺序访问</li></ul><h2 id="实现按访问顺序排序（最近最少使用）（LRU）"><a href="#实现按访问顺序排序（最近最少使用）（LRU）" class="headerlink" title="实现按访问顺序排序（最近最少使用）（LRU）"></a>实现按访问顺序排序（最近最少使用）（LRU）</h2><ul><li><p>页面置换算法</p></li><li><p><strong>缓存机制</strong></p></li></ul><h1 id="LinkedHashMap-实现原理"><a href="#LinkedHashMap-实现原理" class="headerlink" title="LinkedHashMap 实现原理"></a>LinkedHashMap 实现原理</h1><h2 id="继承关系图"><a href="#继承关系图" class="headerlink" title="继承关系图"></a>继承关系图</h2><p><img src="/images/posts/Java/Collection/class_diagram_linkedhashmap.png" alt="LinkedHashMap 类图" title="LinkedHashMap 类图"></p><p><img src="/images/posts/Java/Collection/class_diagram_treenode.png" alt="所有节点类图" title="所有节点类图"></p><h2 id="put-如何维护双链表"><a href="#put-如何维护双链表" class="headerlink" title="put() 如何维护双链表"></a>put() 如何维护双链表</h2><p><code>LinkedHashMap</code> 未重写 <code>put()</code> 方法，直接使用 <code>HashMap</code> 的 <code>put()</code> 方法，通过重写 <code>newNode()</code> 方法维护双链表的建立，通过重写 <code>afterNodeAccess()</code> 方法和 <code>afterNodeInsertion()</code> 方法维护 LRU。</p><blockquote><p><code>afterNodeAccess()</code> 和 <code>afterNodeInsertion()</code> 在 <code>HashMap</code> 中为空方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// LinkedHashMap 重写 newNode()</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// LinkedHashMap 重写 newNode()</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//维护 LRU</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//维护 LRU</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code> 重写了 <code>newNode()</code> 方法，新建节点后调用 <code>linkNodeLast()</code> 方法连接链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap 源码</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap 源码</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//调用该方法维护双链表</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将新节点放入双链表尾</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-如何维护双链表"><a href="#remove-如何维护双链表" class="headerlink" title="remove() 如何维护双链表"></a>remove() 如何维护双链表</h2><p><code>LinkedHashMap</code> 没有重写 <code>remove()</code> 方法，通过重写 <code>afterNodeRemoval()</code> 方法维护双链表。</p><blockquote><p><code>afterNodeRemoval()</code> 在 <code>HashMap</code> 中为空方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//维护双链表</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap 源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">//移除节点后断开双链表重新连接</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-和-put-如何维护-LRU"><a href="#get-和-put-如何维护-LRU" class="headerlink" title="get() 和 put() 如何维护 LRU"></a>get() 和 put() 如何维护 LRU</h2><p><code>LinkedHashMap</code> 通过重写 <code>afterNodeAccess()</code> 方法维护 LRU，该方法在 <code>HashMap</code> 的 <code>put()</code> 方法中被调用，在 <code>LinkedHashMap</code> 重写的 <code>get()</code> 方法中被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问节点后将该节点移至链尾</span></span><br><span class="line"><span class="comment">//put() 方法中若新值覆盖旧值则会调用该方法</span></span><br><span class="line"><span class="comment">//get() 方法中调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        <span class="comment">//维护 LRU</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code> 重写了 <code>afterNodeInsertion()</code> 方法，该方法在 <code>put()</code> 中添加新节点后被调用，<strong>该方法会移除头节点，也就是最久未被访问的节点</strong>。</p><p>该方法中调用的 <code>removeEldestEntry()</code> 方法直接返回 <code>false</code>，所以该方法<strong>实际逻辑不执行</strong>。</p><p>可以通过重写 <code>removeEldestEntry()</code> 方法实现在某条件下移除最久未被访问节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//put() 中 evict 传入 true</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何开启按访问顺序排序（LRU）"><a href="#如何开启按访问顺序排序（LRU）" class="headerlink" title="如何开启按访问顺序排序（LRU）"></a>如何开启按访问顺序排序（LRU）</h1><p><code>LinkedHashMap</code> 有这样一个构造方法，第三个参数传入 <code>true</code> 即可，默认是 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedHashMap-对于-HashMap-的优化"><a href="#LinkedHashMap-对于-HashMap-的优化" class="headerlink" title="LinkedHashMap 对于 HashMap 的优化"></a>LinkedHashMap 对于 HashMap 的优化</h1><ul><li><p><code>LinkedHashMap</code> 重写 <code>containsValue()</code> 方法。</p></li><li><p><code>LinkedHashIterator</code> 重写 <code>nextNode ()</code> 方法。</p></li></ul><p>LinkedHashMap <strong>直接遍历双链表</strong>，即直接遍历有效数据。</p><p>HashMap <strong>先遍历桶，再遍历链表</strong>，双重循环，但是并不是所有桶都有数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下源码基于 JDK 10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;LinkedHashMap-是什么&quot;&gt;&lt;a href=&quot;#LinkedHashMap-是什么&quot; class=&quot;headerlink&quot; title=&quot;LinkedHash
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.ennis.info/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.ennis.info/tags/Java/"/>
    
      <category term="Java集合" scheme="http://blog.ennis.info/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」LayoutInflater 中 inflate 方法各参数作用（二）</title>
    <link href="http://blog.ennis.info/2019/05/03/LayoutInflater%E4%B8%ADinflate%E6%96%B9%E6%B3%95%E5%90%84%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.ennis.info/2019/05/03/LayoutInflater中inflate方法各参数作用（二）/</id>
    <published>2019-05-03T12:40:47.000Z</published>
    <updated>2020-05-18T17:34:54.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><p><a href="https://blog.csdn.net/u012702547/article/details/52628453" target="_blank" rel="noopener">三个案例带你看懂LayoutInflater中inflate方法两个参数和三个参数的区别</a></p></li><li><p><a href="https://www.jianshu.com/p/342890fcf5c9" target="_blank" rel="noopener">View.inflate() 的前世今生</a></p></li></ul><h1 id="View-inflate-和-LayoutInflater-inflate"><a href="#View-inflate-和-LayoutInflater-inflate" class="headerlink" title="View.inflate 和 LayoutInflater.inflate"></a>View.inflate 和 LayoutInflater.inflate</h1><p>View.inflate 实际上上只是简单的包装了 LayoutInflater.inflate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">inflate</span><span class="params">(Context context, @LayoutRes <span class="keyword">int</span> resource, ViewGroup root)</span> </span>&#123;</span><br><span class="line">    LayoutInflater factory = LayoutInflater.from(context);</span><br><span class="line">    <span class="keyword">return</span> factory.inflate(resource, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LayoutInflater-inflate-两个参数和三个参数的区别"><a href="#LayoutInflater-inflate-两个参数和三个参数的区别" class="headerlink" title="LayoutInflater.inflate 两个参数和三个参数的区别"></a>LayoutInflater.inflate 两个参数和三个参数的区别</h1><h2 id="两个参数"><a href="#两个参数" class="headerlink" title="两个参数"></a>两个参数</h2><p>两个参数的方法实际上也只是简单调用了三个参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 ViewGroup 传入 null 时调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(resource, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ul><li>当 ViewGroup 传入非 null 时调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(resource, root, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h2><h3 id="ViewGroup-传入-null"><a href="#ViewGroup-传入-null" class="headerlink" title="ViewGroup 传入 null"></a>ViewGroup 传入 null</h3><ul><li><p>View 没有父布局</p></li><li><p>View 没有 LayoutParams</p></li><li><p>返回该 View</p></li><li><p>attachToRoot 参数无效</p></li></ul><h3 id="ViewGroup-传入非-null"><a href="#ViewGroup-传入非-null" class="headerlink" title="ViewGroup 传入非 null"></a>ViewGroup 传入非 null</h3><h4 id="attachToRoot-为-true"><a href="#attachToRoot-为-true" class="headerlink" title="attachToRoot 为 true"></a>attachToRoot 为 true</h4><ul><li><p>View 添加到父布局</p></li><li><p>View 设置 LayoutParams 参数</p></li><li><p>返回父布局</p></li></ul><h4 id="attachToRoot-为-true-1"><a href="#attachToRoot-为-true-1" class="headerlink" title="attachToRoot 为 true"></a>attachToRoot 为 true</h4><ul><li><p>View 没有父布局</p></li><li><p>View 设置 LayoutParams 参数</p></li><li><p>返回该 View</p></li></ul><h1 id="ViewGroup-最好传入非-null-的情况"><a href="#ViewGroup-最好传入非-null-的情况" class="headerlink" title="ViewGroup 最好传入非 null 的情况"></a>ViewGroup 最好传入非 null 的情况</h1><p>如果在知道父布局的情况下，ViewGroup 最好传入父布局而不是 null，因为 View 的 LayoutParams 参数始终需要通过父布局来确定。</p><p>当调用 ViewGroup.addView 时，如果添加的 View 的 LayoutParams 为 null，会调用 generateDefaultLayoutParams 方法生成一个宽高都包裹的 LayoutParams，这可能并不是我们想要的效果，因为在 xml 中指定的宽高等属性将失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = generateDefaultLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="attachToRoot-最好传入-true-的情况"><a href="#attachToRoot-最好传入-true-的情况" class="headerlink" title="attachToRoot 最好传入 true 的情况"></a>attachToRoot 最好传入 true 的情况</h1><ul><li>自定义组件</li></ul><h1 id="attachToRoot-必须传入-false-的情况"><a href="#attachToRoot-必须传入-false-的情况" class="headerlink" title="attachToRoot 必须传入 false 的情况"></a>attachToRoot 必须传入 false 的情况</h1><p>否则会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first.</span><br></pre></td></tr></table></figure><h2 id="不负责-View-的展示时，attachToRoot-必须传入-false"><a href="#不负责-View-的展示时，attachToRoot-必须传入-false" class="headerlink" title="不负责 View 的展示时，attachToRoot 必须传入 false"></a>不负责 View 的展示时，attachToRoot 必须传入 false</h2><ul><li>RecyclerView#onCreateViewHolder</li></ul><p>由 RecyclerView 控制展示 ViewHolder 的 View</p><ul><li>Fragment#onCreateView</li></ul><p>由 FragmentManager 控制显示 Fragment</p><h2 id="View-已有父布局时，attachToRoot-必须传入-false"><a href="#View-已有父布局时，attachToRoot-必须传入-false" class="headerlink" title="View 已有父布局时，attachToRoot 必须传入 false"></a>View 已有父布局时，attachToRoot 必须传入 false</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012702547/article/details/526
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>「转载」Android 类加载</title>
    <link href="http://blog.ennis.info/2019/03/18/%E8%BD%AC-Android%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.ennis.info/2019/03/18/转-Android类加载/</id>
    <published>2019-03-18T11:11:04.000Z</published>
    <updated>2020-05-18T17:40:43.738Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5c31c3ebf265da614e2c3b68" target="_blank" rel="noopener">Android Classloader机制</a></p><h1 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h1><p>JVM 将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><blockquote><p>类从被加载到虚拟机内存中开始，到卸载出内存为止。</p></blockquote><p>整个生命周期包括 7 个阶段：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）</strong>。</p><p>验证、准备、解析3个部分统称为连接（Linking）。</p><p><img src="/images/posts/android/类加载/class_lifecycle.jpg" alt="各阶段发生顺序" title="各阶段发生顺序"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li><p><strong>对于任意一个类，需要由加载它的类加载器和这个类本身一同确立其在 JVM 中的唯一性。</strong></p></li><li><p>每一个类加载器，都拥有一个独立的类名称空间。</p></li></ul><blockquote><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 </p></blockquote><h2 id="JDK-8-及之前的双亲委派模型"><a href="#JDK-8-及之前的双亲委派模型" class="headerlink" title="JDK 8 及之前的双亲委派模型"></a>JDK 8 及之前的双亲委派模型</h2><ul><li><p>Java 应用程序一般由 3 种类加载器互相配合进行加载。</p></li><li><p>如果有必要，可以自定义的类加载器。</p></li></ul><p><img src="/images/posts/android/类加载/jvm_classloader.jpg" alt="类加载器之间的关系" title="类加载器之间的关系"></p><ul><li><p>这种层次关系称为类加载器的双亲委派模型（Parents Delegation Model）。</p></li><li><p><strong>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有父类加载器。</strong></p></li><li><p><strong>父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</strong></p></li></ul><h3 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h3><ol><li><p>一个类加载器收到类加载的请求。</p></li><li><p><strong>把这个请求委派给父类加载器去完成。</strong></p></li><li><p>父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）。</p></li><li><p>子加载器尝试自己加载。</p></li></ol><h3 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h3><ul><li><p>加载以下类库到 JVM 内存</p><ul><li><p>存放在 ＜JAVA_HOME＞\lib 目录中的</p></li><li><p>或者被 -Xbootclasspath 参数所指定的路径中的</p></li><li><p>并且是虚拟机识别的类库</p></li></ul></li><li><p>无法被 Java 程序直接引用。</p></li><li><p>把加载请求委派给引导类加载器，直接使用 null 代替。</p></li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul><li><p>由 sun.misc.Launcher $ExtClassLoader 实现。</p></li><li><p>加载以下类库到 JVM 内存</p><ul><li><p>存放在＜JAVA_HOME＞\lib\ext目录中的</p></li><li><p>或者被 java.ext.dirs 系统变量所指定的路径中的所有类库</p></li></ul></li><li><p>开发者可以直接使用扩展类加载器。</p></li></ul><h3 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h3><blockquote><p>也称为系统类加载器</p></blockquote><ul><li><p>由 sun.misc.Launcher $App-ClassLoader 实现。</p></li><li><p>加载以下类库到 JVM 内存</p><ul><li>用户类路径（ClassPath）上所指定的类库</li></ul></li><li><p>开发者可以直接使用这个类加载器。</p></li><li><p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul><h3 id="JDK-9-双亲委派模型的更改"><a href="#JDK-9-双亲委派模型的更改" class="headerlink" title="JDK 9 双亲委派模型的更改"></a>JDK 9 双亲委派模型的更改</h3><ul><li><p>Java 9 引入了模块系统，并且略微更改了上述的类加载器。</p></li><li><p>扩展类加载器被改名为平台类加载器（platform class loader）。</p></li><li><p>Java SE中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p></li></ul><h1 id="Android-类加载机制"><a href="#Android-类加载机制" class="headerlink" title="Android 类加载机制"></a>Android 类加载机制</h1><ul><li><p><strong>本质上 Android 和传统的 JVM 是一样的。</strong></p><ul><li><p>需要通过类加载器将目标类加载到内存</p></li><li><p>类加载器之间符合双亲委派模型</p></li><li><p>类有对应的生命周期</p></li></ul></li><li><p>基于移动设备的特点，如内存以及电量等诸多方面跟一般的 PC 设备都有本质的区别，Google 开发了更符合移动设备的用于执行 Java 代码的虚拟机，即 Dalvik 和 ART。</p></li><li><p>Android 5.0 开始采用 ART 虚拟机替代 Dalvik。</p></li><li><p><strong>ART 从 dex 字节码加载类。将多个 Class 文件合并成一个 classes.dex 文件。</strong></p></li></ul><p><img src="/images/posts/android/类加载/android_classloader.jpg" alt="类加载器关系图" title="类加载器关系图"></p><ul><li><p>在 8.0 之前</p><ul><li><p>DexClassLoader：能够加载未安装的 apk</p></li><li><p>PathClassLoader：只能加载系统中已经安装过的 apk</p></li></ul></li><li><p>从 8.0 开始</p><ul><li><p>PathClassLoader 也可以加载未安装的 apk</p></li><li><p>PathClassLoader 可以完全替代 DexClassLoader</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5c31c3ebf265da614e2c3b68&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Classloader机制&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;JVM-类加载
      
    
    </summary>
    
      <category term="Android" scheme="http://blog.ennis.info/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.ennis.info/tags/Android/"/>
    
      <category term="类加载" scheme="http://blog.ennis.info/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」synchronized 的相关问题</title>
    <link href="http://blog.ennis.info/2019/02/18/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized/"/>
    <id>http://blog.ennis.info/2019/02/18/Java并发之synchronized/</id>
    <published>2019-02-18T06:24:12.000Z</published>
    <updated>2020-05-18T17:30:56.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><p><a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">Java 之 synchronized 详解</a></p></li><li><p><a href="https://blog.csdn.net/xiao__gui/article/details/8188833" target="_blank" rel="noopener">Java线程同步：synchronized锁住的是代码还是对象</a></p></li><li><p><a href="https://www.jianshu.com/p/a499d13ca702" target="_blank" rel="noopener">Java并发之synchronized深度解析</a></p></li></ul><h1 id="锁机制的特性"><a href="#锁机制的特性" class="headerlink" title="锁机制的特性"></a>锁机制的特性</h1><ul><li><p>互斥性</p></li><li><p>可见性</p></li></ul><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类.class) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><ul><li>成员方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(该类.class) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁的是对象还是代码？"><a href="#锁的是对象还是代码？" class="headerlink" title="锁的是对象还是代码？"></a>锁的是对象还是代码？</h1><ul><li><strong>synchronized 锁的是对象</strong>，线程只有拿到了锁对象才能执行 synchronized 那段代码，否则阻塞等待。</li></ul><p>也就是说，如果锁对象是 this，那么同步机制仅对该对象有效。</p><ul><li><p>线程拿到锁对象后，<strong>其他线程可以执行非 synchronized 代码</strong>。</p></li><li><p>同时访问 static synchronized 方法和 synchronized 方法可以并行。</p></li></ul><p>前者锁对象是 Class 对象，后者锁对象是 this，锁对象不同，两个方法可以并行。</p><h2 id="如果想锁全局怎么办"><a href="#如果想锁全局怎么办" class="headerlink" title="如果想锁全局怎么办"></a>如果想锁全局怎么办</h2><ul><li><strong>锁住该类对应的 Class 对象。</strong></li></ul><p>Class 类比较特殊，每个类都会有一个对应的 Class 对象且唯一，由 JVM 维护。</p><ul><li>提供一个公用的锁对象。（例如声明为 static 的字段）</li></ul><h1 id="synchronized-的性质"><a href="#synchronized-的性质" class="headerlink" title="synchronized 的性质"></a>synchronized 的性质</h1><h2 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h2><ul><li><p><strong>同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</strong></p></li><li><p>可避免死锁、提升封装性。</p></li></ul><p>线程从 A 方法进入 B 方法时不需要释放锁后重新申请，可直接获得锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同一个方法是可重入的。</p></li><li><p><strong>可重入不要求是同一个方法。</strong></p></li><li><p><strong>可重入不要求是同一个类中的。</strong></p></li></ul><h2 id="不可中断性"><a href="#不可中断性" class="headerlink" title="不可中断性"></a>不可中断性</h2><ul><li><p>如果锁对象被其他线程获得，只能阻塞等待。</p></li><li><p>如果锁对象永远不被释放，只能永远等待。</p></li></ul><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><ul><li><p><strong>锁对象不能为 null。</strong></p></li><li><p><strong>synchronized 关键字不能被继承。</strong></p></li></ul><p>父类中的 synchronized 修饰方法，子类重写该方法时，默认情况不同步，必须显示的使用 synchronized 关键字。</p><ul><li><p>抽象方法不能使用 synchronized 关键字。</p></li><li><p>构造方法不能使用 synchronized 关键字，但可以使用 <code>synchronized(this) {}</code>。</p></li><li><p>synchronized 有系统开销，尽量减小锁的粒度（作用域范围）。</p></li><li><p>避免死锁。</p></li></ul><h1 id="synchronized-实现原理（字节码）"><a href="#synchronized-实现原理（字节码）" class="headerlink" title="synchronized 实现原理（字节码）"></a>synchronized 实现原理（字节码）</h1><blockquote><p><a href="/2018/10/17/笔记-深入拆解Java虚拟机-14Java虚拟机是怎么实现synchronized的？">详细实现原理</a></p></blockquote><ul><li><p>同步块使用 monitorenter 和 moniterexit 指令。</p></li><li><p>同步方法使用修饰符 ACC_SYNCHRONIZED 。</p></li><li><p>同步本质上都是通过监视器（monitor）提供支持。</p></li><li><p>所有对象都有一个自己的监视器（monitor）。</p></li><li><p>本地内存中共享变量副本发生变化后，解锁之前将本地内存中共享变量的值刷新到主存。</p></li><li><p>其他线程获取到锁后，去主内存中读取该共享变量的新值。</p></li></ul><h2 id="可重入性原理"><a href="#可重入性原理" class="headerlink" title="可重入性原理"></a>可重入性原理</h2><ul><li><p>锁对象监视器计数为 0 时，线程进入监视器，并设置计数器 为 1。（monitorenter）</p></li><li><p>线程重入监视器时，计数器 +1。（monitorenter）</p></li><li><p>线程退出监视器时，计数器 -1。（monitorexit）</p></li><li><p>如果监视器与其他线程关联，该线程阻塞等待，直到监视器计数器为 0。</p></li></ul><h1 id="synchronized-的缺陷"><a href="#synchronized-的缺陷" class="headerlink" title="synchronized 的缺陷"></a>synchronized 的缺陷</h1><ul><li><p><strong>效率低</strong>：试图获得锁时<strong>不能设定超时</strong>，<strong>不能中断</strong>。</p></li><li><p><strong>不灵活</strong>：加锁和解锁的<strong>时机和条件单一</strong>。</p></li><li><p><strong>无法知道是否成功获取到锁。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/594a24defe88c2006aa01f1c&quot; tar
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.ennis.info/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.ennis.info/tags/Java/"/>
    
      <category term="Java多线程" scheme="http://blog.ennis.info/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
