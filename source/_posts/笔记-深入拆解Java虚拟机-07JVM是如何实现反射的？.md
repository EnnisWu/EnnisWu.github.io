---
title: 笔记-深入拆解Java虚拟机-07JVM是如何实现反射的？
date: 2018-08-06 14:33:36
tags: JVM
categories: Java虚拟机
---

# 反射调用的实现

## Methond.invoke

委派给MethodAccessor接口处理。

MethodAccessor两个具体实现：

1. 本地方法实现反射调用
2. 委派模式

## 委派实现

- 每个Method实例的**第一次反射调用**会生成一个委派实现。
- 委派的具体实现是一个**本地实现**。
- Java的反射调用机制还设立了另一种动态生成字节码的**动态实现**。
- 采用委派实现，是为了能够在本地实现以及动态实现中切换。

### 动态实现

- **运行效率比本地实现要快20倍。**
因为动态实现无需经过Java到C++再到Java的切换。

- 由于**生成字节码十分耗时**，仅**调用一次**的话，反而是**本地实现要快上3到4倍**。

### Inflation

Java虚拟机设置了一个阈值15（可以通过 -Dsun.reflect.inflationThreshold= 来调整）。
当某个反射调用的方法调用次数在 15 之下时，采用本地实现。
当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为Inflation。

反射调用的Inflation机制是可以通过参数（-Dsun.reflect.noInflation=true）关闭。
反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。

# 反射调用的开销

## 反射api性能开销

- Class.getMethod会遍历该类的公有方法。如果没有匹配到，遍历父类的公有方法。
- 以getMethod为代表的查找方法操作，会返回查找得到结果的一份拷贝。
**避免在热点代码中使用返回Method数组的方法，减少不必要的堆空间消耗。**

## 反射本身性能开销

### Method.invoke是一个变长参数方法。

Java编译器会在方法调用处生成一个长度为传入参数个数的Object数组，并将传入参数一一存储进该数组中。

### Java编译器会对传入的基本类型参数自动装箱。

Java 缓存了 [-128, 127] 中所有整数所对应的 Integer 对象。
需要自动装箱的整数在这个范围之内时，返回缓存的 Integer，否则需要新建一个Integer对象。

解决方法：

- **扩大缓存范围**（对应参数-Djava.lang.Integer.IntegerCache.high=128）。
- **在外部缓存**自动装箱得到的Integer对象。

**上面两条除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。**

### 权限检查带来的开销

- 关闭权限检查。
setAccessible(true)

### 方法内联

- 没有方法内联优化
- 逃逸分析不起效

具体代码具体分析。

# 参考

> https://time.geekbang.org/column/article/12192