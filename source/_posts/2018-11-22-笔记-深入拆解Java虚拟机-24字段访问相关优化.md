---
title: '「深入拆解 Java 虚拟机」24 字段访问相关优化'
date: 2018-11-22 19:20:50
tags: JVM
categories: 《深入拆解 Java 虚拟机》
---

原文：https://time.geekbang.org/column/article/39683

# 字段读取优化

- 即时编译器会**优化实例字段和静态字段访问**，以减少总的内存访问数目。

	- 沿控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。

	- 遇到对同一字段的读取节点时，如果缓存值还没有失效，将读取节点替换为该缓存值。

	- 遇到对同一字段的存储节点时，更新所缓存的值。

	- 遇到可能更新字段的节点时，采取保守策略，舍弃所有缓存值。

- 如果字段读取节点被替换成一个常量，将进一步触发更多优化。

	- 删除不可达条件分支代码，死循环后的代码。

- 即时编译器将在 volatile 字段访问前后插入内存屏障节点。

- **内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。**

- **加锁、解锁操作会阻止即时编译器的字段读取优化。**

# 字段存储优化

- 即时编译器会**消除冗余的存储节点**。

- 如果字段被标记为 **volatile**，即时编译器**不能**将冗余的存储操作**消除**掉。

# 死代码消除（dead code eliminiation）

- **消除局部变量的死存储**（dead store）（涉及冗余存储）。

- **消除不可达分支。**

# 问题

Q：思考即时编译器会怎么优化下面代码中的除法操作？

```java
int bar(int x, int y) {
	int t = x/y;
	t = x+y;
	return t;
}
```

A：**除法无法优化，因为可能存在除零异常。**s即时编译器需要判断除数是否为 0。
