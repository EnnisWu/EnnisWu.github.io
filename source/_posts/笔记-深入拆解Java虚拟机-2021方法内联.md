---
title: 笔记-深入拆解Java虚拟机-2021方法内联
date: 2018-11-10 18:24:39
tags: JVM
categories: Java虚拟机
---

> 在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。

- 可以**消除调用本身带来的性能开销**。
- 可以进一步**触发更多的优化**。
- 可以算是**编译优化**里**最为重要的一环**。

# 机器码的生成

即时编译器首先解析字节码，并生成 IR 图，然后在该 IR 图上进行优化。优化是由一个个独立的优化阶段（optimization phase）串联起来的。每个优化阶段都会对 IR 图进行转换。最后即时编译器根据 IR 图的节点以及调度顺序生成机器码。

# C2

- 方法内联在**解析字节码的过程**中完成。

每当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用。如果需要内联，则开始解析目标方法的字节码。

# Graal

- 方法内联在**解析字节码的过程**中完成。
- 拥有一个**独立的优化阶段**，寻找指代方法调用的 IR 节点，替换为目标方法的 IR 图。

## 独立优化阶段

- **将被调用方法的 IR 图节点复制到调用者方法的 IR 图中。**
- 被调用方法的传入参数节点，将被替换为调用者方法进行方法调用时所传入参数对应的节点。
- 在调用者方法的 IR 图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。

如果被调用方法存在多个返回节点，则生成一个 Phi 节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。

- 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。
- 在接下来的编译过程中**对新的 IR 图进行进一步优化**。

# 方法内联的条件

- 内联越多➡生成代码的执行效率越高。
- 内联越多➡编译时间也就越长➡程序达到峰值性能的时刻将被推迟。
- 内联越多➡生成的机器码越长。

JVM 中编译生成的机器码会被部署到 Code Cache 之中。Code Cache 有大小限制。Code Cache 已满时，出现即时编译已被关闭的警告信息。

- 即时编译器根据这些规则决定方法调用**能否被内联**。

	- **方法调用指令所在的程序路径的热度**
	- **目标方法的调用次数及大小**
	- **当前 IR 图的大小**
	
- 内联算法**更青睐于小方法**。

![image](http://pcrioz2ch.bkt.clouddn.com/JVM/20/c2_parameters.jpg "C2 相关的虚拟机参数")

## 特殊规则

- 自动拆箱总会被内联。
- Throwable 类的方法不能被其他类中的方法所内联。

## 强制内联

- 由 -XX:CompileCommand 中的 inline 指令指定的方法。
- 由 @ForceInline 注解的方法（仅限于 JDK 内部方法）。

## 不被内联

- 由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法。
- 由 @DontInline 注解的方法（仅限于 JDK 内部方法）。

## 无法内联

- 调用字节码对应的符号引用未被解析。
- 目标方法所在的类未被初始化。
- 目标方法是 native 方法。

## 不支持内联

- **C2 不支持内联超过 9 层的调用**（可以通过虚拟机参数 -XX:MaxInlineLevel 调整）。
- **1 层的直接递归调用**（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。

# 引用

> https://time.geekbang.org/column/article/14575