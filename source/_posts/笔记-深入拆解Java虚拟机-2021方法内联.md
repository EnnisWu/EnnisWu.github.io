---
title: 笔记-深入拆解Java虚拟机-2021方法内联
date: 2018-11-10 18:24:39
tags: JVM
categories: Java虚拟机
---

> 在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。

- 可以**消除调用本身带来的性能开销**。
- 可以进一步**触发更多的优化**。
- 可以算是**编译优化**里**最为重要的一环**。

# 机器码的生成

即时编译器首先解析字节码，并生成 IR 图，然后在该 IR 图上进行优化。优化是由一个个独立的优化阶段（optimization phase）串联起来的。每个优化阶段都会对 IR 图进行转换。最后即时编译器根据 IR 图的节点以及调度顺序生成机器码。

# C2

- 方法内联在**解析字节码的过程**中完成。

每当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用。如果需要内联，则开始解析目标方法的字节码。

# Graal

- 方法内联在**解析字节码的过程**中完成。
- 拥有一个**独立的优化阶段**，寻找指代方法调用的 IR 节点，替换为目标方法的 IR 图。

## 独立优化阶段

- **将被调用方法的 IR 图节点复制到调用者方法的 IR 图中。**
- 被调用方法的传入参数节点，将被替换为调用者方法进行方法调用时所传入参数对应的节点。
- 在调用者方法的 IR 图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。

如果被调用方法存在多个返回节点，则生成一个 Phi 节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。

- 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。
- 在接下来的编译过程中**对新的 IR 图进行进一步优化**。

# 方法内联的条件

- 内联越多➡生成代码的执行效率越高。
- 内联越多➡编译时间也就越长➡程序达到峰值性能的时刻将被推迟。
- 内联越多➡生成的机器码越长。

JVM 中编译生成的机器码会被部署到 Code Cache 之中。Code Cache 有大小限制。Code Cache 已满时，出现即时编译已被关闭的警告信息。

- 即时编译器根据这些规则决定方法调用**能否被内联**。

	- **方法调用指令所在的程序路径的热度**
	- **目标方法的调用次数及大小**
	- **当前 IR 图的大小**
	
- 内联算法**更青睐于小方法**。

![c2_parameters](/images/posts/JVM/2021/c2_parameters.jpg "C2 相关的虚拟机参数")

## 特殊规则

- 自动拆箱总会被内联。
- Throwable 类的方法不能被其他类中的方法所内联。

## 强制内联

- 由 -XX:CompileCommand 中的 inline 指令指定的方法。
- 由 @ForceInline 注解的方法（仅限于 JDK 内部方法）。

## 不被内联

- 由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法。
- 由 @DontInline 注解的方法（仅限于 JDK 内部方法）。

## 无法内联

- 调用字节码对应的符号引用未被解析。
- 目标方法所在的类未被初始化。
- 目标方法是 native 方法。

## 不支持内联

- **C2 不支持内联超过 9 层的调用**（可以通过虚拟机参数 -XX:MaxInlineLevel 调整）。
- **1 层的直接递归调用**（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。

# 静态方法调用

- 即时编译器可以轻易地**确定唯一的目标方法**。

# 虚方法调用
> - 非 static、非 private 、非 final 方法都是虚方法。
>> 换句话说可以被重写的方法都是虚方法。
> - 即时编译器需要先对虚方法调用进行去虚化（devirtualize），即转换为一个或多个直接调用，然后才能进行方法内联。

## 完全去虚化

- 通过**类型推导**或者**类层次分析**（class hierarchy analysis），识别虚方法调用的唯一目标方法，将其**转换为直接调用**。
- **关键在于证明虚方法调用的目标方法是唯一的。**

### 基于类型推导的完全去虚化
> 类型推导属于全局优化，比较浪费时间。

- 通过**数据流分析**推导出调用者的动态类型。
- 如果生成 Sea-of-Nodes IR 后，调用者的**动态类型已能够直接确定，就进行去虚化**。
- 如果**需要额外的数据流分析才能确定**，**不做**，节省编译时间，依赖接下来的去虚化手段优化。

### 基于类层次分析的完全去虚化

- **分析所有已被加载的类**，判断某个抽象方法或者接口方法**是否仅有一个实现**。如果是，调用这些方法只能调用至该具体实现中。
- **无法保证之后的执行过程只有一个具体实现。**
- JVM 为当前编译结果**注册若干个假设**（assumption）。

假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。

- 当新的类被加载，JVM 会重新验证假设。
- 如果某个假设不再成立，对其所属的编译结果去优化。
- 如果使用了 **final 修饰符**，即时编译器可以**不用生成对应的假设，直接去虚化和内联**。

#### 接口方法调用（不懂）

- **去虚化不能移除动态类型检测。**
- 执行 invokeinterface 指令时，JVM 必须对调用者的动态类型进行测试，是否实现了目标接口方法所在的接口。
- Java 类验证器将接口类型直接看成 Object 类型，有可能出现声明类型为接口，实际类型没有继承该接口的情况。

## 条件去虚化（guarded devirtualization）

- 将虚方法调用**转换为若干个类型测试以及直接调用**。
- **关键在于找出需要进行比较的类型。**
- 将调用者的动态类型，依次**与类型 Profile 记录的类型比较**。
- 如果**匹配，直接调用**该记录类型所对应的目标方法。
- 不匹配
	- 如果类型 Profile 是**完整**的，**去优化**，重新收集类型 Profile。
	- 如果类型 Profile 是**不完整**的，进行原本的**虚调用**，通过内联缓存进行调用，或者通过方法表进行动态绑定。（Graal）
- **在 C2 中，如果类型 Profile 是不完整的，不会进行条件去虚化**，直接使用内联缓存或者方法表。

# 引用

> https://time.geekbang.org/column/article/14575