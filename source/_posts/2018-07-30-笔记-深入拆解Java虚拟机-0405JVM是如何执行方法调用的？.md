---
title: 笔记-深入拆解Java虚拟机-0405JVM是如何执行方法调用的？
date: 2018-07-30 15:41:36
tags: JVM
categories: Java虚拟机
---

# 重载和重写

在Java程序里，同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。这个限制可以通过字节码工具绕开。在编译完成之后，可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。

## 重载的方法在编译过程中即可完成识别

Java编译器**根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法**：

1. 在**不考虑对基本类型自动装拆箱**（auto-boxing，auto-unboxing）和**可变长参数**的情况下选取重载方法。
2. 在**允许自动装拆箱**，但**不允许可变长参数**的情况下选取重载方法。
3. 在**允许自动装拆箱和可变长参数**的情况下选取重载方法。

如果Java编译器在同一阶段**多种适配方法**，会在其中**选择一个最贴切的**方法。

**决定贴切程度**的关键之一是形式参数类型的**继承关系**。

## 重载可以作用于这个类所继承而来的方法

如果**子类定义了与父类中非私有方法同名的方法**，而且这两个方法的**参数类型不同**，那么在子类中，这两个方法同样**构成了重载**。

如果**子类定义了与父类中非私有方法同名的方法**，而且这两个**方法的参数类型相同**：

- 如果这两个方法**都是静态的**，那么子类中的方法**隐藏**了父类中的方法。
- 如果这两个方法**都不是静态的，且都不是私有的**，那么子类的方法**重写**了父类中的方法（重写可以扩大访问权限，但不能缩小）。

注：如果子类定义了与父类中私有方法同名的方法，这两个方法之间没有任何关系。

# JVM的静态绑定和动态绑定

**Java虚拟机识别方法的关键：类名、方法名和方法描述符（method descriptor）。**

方法描述符 = 方法的参数类型+返回类型所构成

在同一个类中，

- 出现多个名字相同且描述符也相同的方法
Java虚拟机在类的验证阶段报错。

- **不限制名字与参数类型相同但返回类型不同的方法出现。**

Java虚拟机判定方法重写：

- 子类定义了与父类中**非私有、非静态方法**同名的方法。
- **方法名和方法描述符都相同**。

Java语言中重写而Java虚拟机中非重写的情况：

- 编译器通过生成**桥接方法**来实现Java中的重写语义。

重载方法的区分在编译阶段已经完成，可以认为Java虚拟机不存在重载概念。

Java编译器会将**所有对非私有实例方法的调用**编译为需要**动态绑定**的类型。

Java虚拟机中的静态绑定：在解析时便能够直接识别目标方法。

Java虚拟机中的动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法。

Java字节码中与调用相关的指令共有五种：

- invokestatic：用于调用静态方法。
- invokespecial：用于调用私有实例方法、构造器，使用super调用父类的实例方法或构造器，和所实现接口的默认方法。
- invokevirtual：用于调用非私有实例方法。
- invokeinterface：用于调用接口方法。
- invokedynamic：用于调用动态方法。

invokestatic和invokespecial：Java虚拟机能够**直接识别**具体的目标方法（静态绑定）。

invokevirtual和invokeinterface：在绝大部分情况下，虚拟机需要**在执行过程中根据调用者的动态类型，来确定**具体的目标方法（动态绑定）。

例外：如果虚拟机能够确定目标方法有且仅有一个（如目标方法被标记为final），可以不通过动态类型，直接确定目标方法（虚拟机可以静态绑定该方法）。

# 调用指令的符号引用

符号引用存储在 class 文件的常量池之中。

符号引用分为：接口符号引用和非接口符号引用。

## 非接口符号引用

该符号引用所指向的类为C，Java虚拟机查找步骤：

1. 在C中查找符合名字及描述符的方法。
2. 在C的父类中继续搜索，直至 Object 类。
3. 在C所直接实现或间接实现的接口中搜索。
这一步搜索得到的目标方法必须是非私有、非静态的。
如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。（假如C实现了I，I继承I1，I1继承I2，那么C和I2之间就隔着I和I1）

经过上述的解析步骤之后，符号引用会被解析成实际引用。

**静态绑定的方法调用：实际引用是一个指向方法的指针。**

**动态绑定的方法调用，实际引用是一个方法表的索引。**

## 接口符号引用

该符号引用所指向的接口为I，Java虚拟机查找步骤：

1. 在I中查找符合名字及描述符的方法。
2. 在Object类中的公有实例方法中搜索。
3. 在I的父接口中搜索。
这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。

# 虚方法调用

Java里：

- 所有非私有实例方法调用被编译成invokevirtual指令
- 所有接口方法调用都被编译成invokeinterface指令。

## Java虚拟机实现动态绑定的策略

为每个类生成一张方法表，用以快速定位目标方法（空间换取时间）。

# 方法表

> 类加载的准备阶段除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

下面以虚方法表为例（virtual method table，vtable），接口方法（interface method table，itable）表原理类似，但稍复杂。

方法表**本质：数组**（元素指向一个当前类及其祖先类中非私有的实例方法）。

方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。

方法表**满足两个特质**：

- 子类方法表中**包含父类方法表中的所有方法**。
- 子类方法在方法表中的索引值，**与它所重写的父类方法的索引值相同**。

动态绑定：

- Java 虚拟机将获取调用者的实际类型。
- 在该实际类型的虚方法表中根据索引值获得目标方法。

## 是否可以认为虚方法调用对性能没有太大影响？

**不能，上述优化实际上仅存在最坏情况中。**

**即时编译有两种性能更好的优化手段：**

- 内联缓存（inlining cache）
- 方法内联（method inlining）

# 内联缓存

> 缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。

单态（monomorphic）指的是仅有一种状态的情况。
多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
超多态（megamorphic）指的是更多种状态的情况。通常用一个具体数值来区分多态和超多态。

对于内联缓存:

- 单态内联缓存
- 多态内联缓存
- 超多态内联缓存

在实践中，大部分的虚方法调用均是单态的。

**为了节省内存空间，Java 虚拟机只采用单态内联缓存。**

**内联缓存没有命中**的情况下，Java 虚拟机需要**重新使用方法表进行动态绑定**，有两种选择：

- **替换**单态内联缓存中的纪录。
- **劣化为超多态状态**（Java 虚拟机的具体实现方式）。
直接访问方法表，**牺牲了优化的机会，节省了写缓存的额外开销**。

## 内联缓存并没有内联目标方法。

- 任何方法调用除非被内联，否则都会有固定开销。
- 开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。

# 问题

Q：public final 或 public static final 的方法，是不是在虚拟机中解析为静态绑定的。

A：静态方法都是静态绑定。调用的目标方法是public final的话，HotSpot虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。

# 参考

> https://time.geekbang.org/column/article/11539
> https://time.geekbang.org/column/article/12098