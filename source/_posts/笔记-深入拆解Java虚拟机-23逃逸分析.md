---
title: 笔记-深入拆解Java虚拟机-23逃逸分析
date: 2018-11-15 16:40:59
tags: JVM
categories: Java虚拟机
---

# 逃逸分析

> 一种确定**指针动态范围**的**静态分析**，它可以分析在程序的哪些地方可以访问到指针。

- 在 JVM 的**即时编译**语境下，逃逸分析将**判断新建的对象是否逃逸**。

## 判断对象是否逃逸的依据

- 对象是否被**存入堆**中（静态字段或者堆中对象的实例字段）。
- 对象是否被**传入未知代码**中（对象是否作为方法调用的调用者或者参数）。
	- 方法中未被内联的方法调用当成未知代码。
	- 可以认为**方法调用的调用者以及参数是逃逸的**。

- 通常**逃逸分析**放在**方法内联之后**。

# 基于逃逸分析的优化

## 锁消除

- 如果能证明**锁对象不逃逸**，对该锁对象的**加锁、解锁**操作**没有意义**。
	- 因为其他线程不能获得该所对象，即时编译器可以消除加锁、解锁操作。
	- 传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。
	- 由于即时编译的限制，条件被强化为证明锁**对象不逃逸**出当前编译的**方法**。

- 基于逃逸分析的锁消除实际上不多见。

## 栈上分配（HotSpot 虚拟机未采用）

- 如果逃逸分析能证明某些**新建的对象不逃逸**，可以将其**分配至栈上**。
- new 语句所在的方法退出时，**弹出**当前方法的**栈桢自动回收内存空间**。
- 无须借助垃圾回收器处理。
- 实现需要**更改大量**假设“对象只能堆分配”的**代码**。

## 标量替换

> 标量：就是仅能存储一个值的变量，如局部变量。  
> 聚合量：可能同时存储多个值，如 Java 对象。

- 可以看成将原本**对对象的字段的访问，替换为一个个局部变量的访问**。
- 对象没有被实际分配，和栈上分配一样。
- 可以减轻垃圾回收的压力。
- 与栈上分配相比，**对字段的内存连续性不做要求**。
- 字段甚至可以**直接在寄存器中维护**，无须浪费任何内存空间。

# 部分逃逸分析（partial escape analysis）

- C2 的逃逸分析与控制流无关。
- Graal 引入一个**与控制流有关**的逃逸分析，即部分逃逸分析。
- 部分逃逸分析能够**优化更多的情况，编译时间更长**。
- **解决**所新建的实例仅在**部分程序路径中逃逸**的情况。
- 根据控制流信息，判断出新建对象仅在部分分支中逃逸，**将对象的新建操作推延至对象逃逸的分支中**。
- 使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行 if-else 分支的程序路径之中。（不懂）

# 引用

> https://time.geekbang.org/column/article/18048