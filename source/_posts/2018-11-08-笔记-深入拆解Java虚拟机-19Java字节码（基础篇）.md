---
title: 笔记-深入拆解Java虚拟机-19Java字节码（基础篇）
date: 2018-11-08 14:42:50
tags: JVM
categories: Java虚拟机
---

# 操作数栈

- **解释执行**过程中，为 Java 方法分配栈桢时，JVM **需要开辟一块额外的空间作为操作数栈**，存放计算的操作数和返回结果。
- 执行每一条指令之前，JVM **要求该指令的操作数已被压入操作数栈中**。
- 在执行指令时，JVM 会将该指令**所需的操作数弹出**，并且将指令的**结果重新压入栈**中。

## 直接作用在操作数栈上的指令

### dup 指令

- 复制栈顶元素。
- 常用于复制 new 指令所生成的未经初始化的引用。

### pop 指令

- 舍弃栈顶元素。
- 常用于舍弃调用指令的返回结果。

### dup2 指令和 pop2 指令

- long 类型或 double 类型的值占据两个栈单元。
- dup 指令和 pop 指令只能处理非 long 或非 double 类型的值。
- dup2 指令复制栈顶两个单元。
- pop2 指令弹出栈顶两个单元。

### swap 指令

- 交换栈顶两个元素的值。

## 直接将常量加载在操作数栈上的指令

- 常量类型包括
	- int 类型
	- long 类型
	- float 类型
	- double 类型
	- String 类型
	- Class 类型

- 正常情况下，**操作数栈的压入弹出是一条条指令完成**。
- **例外：抛异常**时会清除操作数栈上的所有内容，然后将异常实例压入操作数栈。

![instructions_const](/images/posts/JVM/19/instructions_const.jpg "常数加载指令表")

### int 类型为例

- 可以通过 iconst 指令加载 -1 至 5 之间的 int 值。
- 可以通过 bipush、sipush 加载一个字节、两个字节所能代表的 int 值。
- 可以通过 ldc 加载常量池中的常量值（如 ldc #18 将加载常量池中的第 18 项）。

# 局部变量区

- 方法栈帧的重要组成部分。
- 可以**缓存计算的结果**。
- JVM 将其**当成一个数组**，依次存放 this 指针（仅非静态方法），所传入的参数，字节码中的局部变量。
- long 类型和 double 类型的值占据两个单元，其余类型占据一个单元。
- **生命周期没有重合的局部变量可以编排至同一单元。**
- 存储在局部变量区的值，**需要加载至操作数栈中，才能进行计算**。
- 计算得到的**结果再存储至局部变量区**中。

![instructons_local_variable](/images/posts/JVM/19/instructons_local_variable.jpg "局部变量区访问指令表")

- 局部变量数组的**加载、存储指令**需要**指明**所加载单元的**下标**。

## iinc M N 指令

- Java 字节码**唯一能够作用于局部变量的指令**。
- M 为非负整数，N 为整数。
- 将局部变量数组的第 M 个单元中的 int 值增加 N。
- 常用于**更新 for 循环的自增量**。

# Java 字节码简介

## Java 相关指令

- new：后跟目标类，生成该类的未初始化的对象。
- instanceof：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（是则压入 1，否则压入 0）。
- checkcast：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（如果不是便抛出异常）。
- athrow：将栈顶异常抛出。
- monitorenter：为栈顶对象加锁。
- monitorexit：为栈顶对象解锁。

## 字段访问指令

- 静态字段访问指令：getstatic、putstatic。
- 实例字段访问指令：getfield、putfield。
- 这四条指令均附带用以定位目标字段的信息。
- 这四条指令所消耗的操作数栈元素皆不同。

## 方法调用指令

- 包括 invokestatic，invokespecial，invokevirtual，invokeinterface 和 invokedynamic。
- 除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素由调用类型和目标方法描述符确定。

## 数组相关指令

- newarray：新建基本类型数组。
- anewarray：新建引用类型数组。
- mutianewarray：新建多维数组。
- arraylength：求数组长度。
- 数组加载指令。
- 数组存储指令。

![instructions_array](/images/posts/JVM/19/instructions_array.jpg "数组访问指令表")

## 控制流指令

- goto：无条件跳转指令。
- tableswitch：条件跳转指令（针对密集的 cases）。
- lookupswtich：条件跳转指令（针对稀疏的 cases）。
- 被废弃的 jsr，ret 指令。
- 返回指令。

![instructons_return](/images/posts/JVM/19/instructons_return.jpg "返回指令表")

- 除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。

# 问题

Q：JVM 为什么使用**基于栈的计算模型**？

A：**实现起来容易**一些，但并**不高效**，因为没有使用底层体系架构的寄存器。在JVM中，只有解释器完整地模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。

***

Q：为什么局部变量要初始化？

A：①如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。②从代码规范来看，使用未经初始化的局部变量意义不明。

***

Q：C/C++ 的汇编指令会有大量寄存器的操作，**Java 的指令会用到寄存器吗**？

A：**Java 字节码不会**，但是**底下的实现（比如解释执行器，即时编译器）是会的**。

# 参考

> https://time.geekbang.org/column/article/14794