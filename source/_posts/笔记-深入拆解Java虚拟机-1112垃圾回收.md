---
title: 笔记-深入拆解Java虚拟机-1112垃圾回收
date: 2018-08-29 15:50:47
tags: JVM
categories: Java虚拟机
---

# 如何辨别对象是否死亡

## 引用计数法（reference counting）

- 为每个对象添加一个引用计数器。
- 为 0 时死亡。

缺点：

1. 需要**额外的空间**。
2. 更新操作**繁琐**。
3. **无法处理循环引用对象**（a 与 b 相互引用）。

## 可达性分析

GC Roots（由堆外指向堆内的引用）包括不限于：

1. Java 方法栈桢中的局部变量。
2. 已加载类的静态变量。
3. JNI handles。**不懂**
4. 已启动且未停止的 Java 线程。

可达性分析算法：

1. 将一系列 GC Roots 作为初始的存活对象合集（live set）。
2. 标记（mark）：从该合集出发，探索所有能够被该集合引用到的对象，将其加入到该集合中。
3. 未被探索到的对象是死亡的，是可以回收的。

需要解决的问题：

在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。

# Stop-the-world

- 停止其他非垃圾回收线程的工作，直到完成垃圾回收。
- 暂停时间（GC pause）。

# 安全点（safepoint）

> 当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。

## 本地代码的安全点

- Java 程序通过 JNI 执行**本地代码**时，这段代码**不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法**。
- **API 入口处进行安全点检测**（safepoint poll）。

## 解释执行字节码的安全点

- **字节码与字节码之间**。
- 有安全点请求时，**执行一条字节码进行一次安全点检测**。

## 执行即时编译器生成的机器码

- 生成机器码时，**即时编译器插入安全点检测**。
- HotSpot 虚拟机：在生成代码的方法出口、非计数循环的循环回边（back-edge）处插入。

## 阻塞的线程属于安全点。

# 垃圾回收的三种方式

## 清除（sweep）

> 把死亡对象所占据的内存标记为空闲内存，记录在一个空闲列表（free list）中。

![sweep](/images/posts/JVM/1112/sweep.png)

缺点：

1. 造成**内存碎片**。
2. 堆中对象必须是连续分布的，可能出现总空闲内存足够，无法分配的极端情况。
3. 分配**效率较低**。

## 压缩（compact）

> 把存活的对象聚集到内存区域的起始位置，留下一段连续的内存空间。

![compact](/images/posts/JVM/1112/compact.png)

缺点：

1. 压缩算法有**性能开销**。

## 复制（copy）

> 把内存区域分为两等分，分别用两个指针 from 和 to 来维护，只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，把存活的对象复制到 to 指针指向的内存区域中，交换 from 指针和 to 指针的内容。

![copy](/images/posts/JVM/1112/copy.png)

缺点：

1.堆空间的使用**效率极其低下**。

12未更新

# 参考

> https://time.geekbang.org/column/article/13091