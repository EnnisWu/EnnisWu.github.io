---
title: '「笔记」为什么双重检查单例需要使用 volatile 关键字'
date: 2020-04-10 12:17:24
tags: [Java,并发]
categories: Java
---

原文：[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

# 内存模型

- CPU 从高速缓存存取数据

- 多核 CPU 每个线程有自己的高速缓存

# 并发编程

## 原子性

- 通过 `synchronized` 和 `Lock` 保证原子性

## 可见性

- 通过 `synchronized` 和 `Lock` 保证可见性

在锁释放之前将修改的变量刷新到主存

- 变量通过 `volatile` 关键字修饰保证可见性

修改变量立即刷新到主存

读取变量强制到主存读取

## 有序性

- 通过 `synchronized` 和 `Lock` 保证有序性

## Java 内存模型 happens-before 原则

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

- 锁定规则：一个 `unLock` 操作先行发生于后面对同一个锁的 `lock` 操作

- `volatile` 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作

- 传递规则：如果操作 A 先行发生于操作 B ，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C

- 线程启动规则：`Thread` 对象的 `start()` 方法先行发生于此线程的每个一个动作

- 线程中断规则：对线程 `interrupt()` 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 `Thread.join()` 方法结束、`Thread.isAlive()` 的返回值手段检测到线程已经终止执行

- 对象终结规则：一个对象的初始化完成先行发生于他的 `finalize()` 方法的开始

# volatile 关键字的两层语义

1. 保证变量的可见性

2. 禁止指令重排序

# 为什么双重检查单例需要使用 volatile 关键字

`instance = new Singleton();` 不是一个原子操作，可以分为 3 步：

1. 分配内存空间

2. 初始化对象

3. 将 `instance` 指向内存地址

由于存在指令重排，执行顺序可能变为 *1 -> 3 -> 2*。

当 3 执行完，2 未执行时，新线程进入检查 `instance != null`，直接返回，会抛出对象未初始化错误。

**使用 volatile 可以禁止指令重排**。
