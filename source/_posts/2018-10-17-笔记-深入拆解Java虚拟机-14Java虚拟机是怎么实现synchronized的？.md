---
title: '「深入拆解 Java 虚拟机」14 Java 虚拟机是怎么实现 synchronized 的？'
date: 2018-10-17 14:08:55
tags: [JVM,看不懂]
categories: 《深入拆解 Java 虚拟机》
---

原文：https://time.geekbang.org/column/article/13530

- 声明 synchronized 的代码块，字节码包含 monitorenter 和 monitorexit 指令。

- 这两种指令会**消耗**操作数栈上的**一个引用类型的元素**。

- 这个元素是用来加解锁的锁对象。（synchronized 括号里的引用，实例方法是 this，静态方法是 class 实例）。

- 用 synchronized 标记方法，字节码中方法的访问标记包括 ACC_SYNCHRONIZED。

# monitorenter 和 monitorexit

## 作用

可以**抽象**地理解为**每个锁对象**有：

1. 一个锁**计数器**

2. 一个指向持有该锁的**线程的指针**

## 执行 monitorenter

- 计数器为 0

	- 说明没有被其他线程所持有。

	- 锁对象的持有线程设置为当前线程。

	- 计数器加 1。

- 计数器不为 0

	- 如果锁对象的持有当前线程，计数器加 1。

	- 否则等待，直至锁释放。

## 执行 monitorexit

- 锁对象的计数器减 1。
- 减为 0 时，锁被释放。

## 为什么采用计数器的方式？

- **允许同一个线程重复获取同一把锁。**

> HotSpot 虚拟机中具体的锁实现。

# 重量级锁

- JVM 中**最基础**的锁实现。

- 阻塞加锁失败的线程，锁被释放时唤醒。

- 阻塞及唤醒依靠操作系统完成，**开销大**。

## 自旋状态

- 为了尽量**避免昂贵的线程阻塞、唤醒操作**。

- 在线程**进入阻塞状态之前**，或被**唤醒后竞争不到锁**的情况下**进入自旋状态**。

- **在处理器上空跑**并且轮询锁是否被释放。

- 与线程阻塞相比，**自旋状态可能会浪费大量的处理器资源**。

- JVM 不能根据等待时间的长短来选择自旋还是阻塞。

- JVM 采用**自适应自旋**，根据以往自旋等待时能否获得锁，**动态调整自旋时间**（循环数目）。

### 自旋状态的副作用：**不公平的锁机制**

- 阻塞状态的线程，没有办法立刻竞争被释放的锁。

- 自旋状态的线程，很有可能优先获得锁。

# 轻量级锁

- **没有锁竞争的情况。**

## 怎样区分轻量级锁和重量级锁？

对象头的标记字段（mark word）最后两位用来表示该对象的锁状态。

| 值 | 含义 |
| -- | ---- |
| 00 | 轻量级锁 |
| 01 | 无锁或偏向锁 |
| 10 | 重量级锁 |
| 11 | 垃圾回收标记 |

## 加锁操作

判断是否是重量级锁

### 判断为非重量级锁

- 在当前线程的当前栈桢中划出一块空间作为该锁的锁记录。

- **将锁对象的标记字段复制到锁记录中。**

- JVM 尝试**用 CAS 操作替换锁对象的标记字段**。（不懂）

比较标记字段是否为 X...X01
	- 是，替换为锁记录地址，成功获得锁，继续执行。
	- 否
		- 线程重复获得同一把锁，JVM 将锁记录清理，代表锁被重复获取。
		- **其他线程持有锁，JVM 将该锁膨胀为重量级锁**，阻塞该线程。

## 解锁操作

### 锁记录值为 0

重复进入同一把锁，直接返回。（不懂）

### 锁记录值不为 0

JVM 尝试用 CAS 操作比较标记字段是否为当前锁记录地址

- 是，替换为锁记录的值，锁释放。

- 否，表示锁已膨胀为重量级锁，进入重量级锁释放过程。

# 偏向锁

## 加锁操作

- 锁对象支持偏向锁。

- JVM 通过 CAS 操作，将**当前线程地址记录在锁对象的标记字段**，将标记字段**最后三位设为 101**。

### 线程请求锁时

判断锁对象标记字段：

1. **最后三位是否为 101**

2. 是否**包含当前线程的地址**

3. epoch 值是否**和锁对象的类的 epoch 值相同**

- 都满足则当前线程持有该偏向锁，直接返回。

- 2 不满足，epoch 值相等时，JVM 需要撤销该偏向锁。

- 2 满足，epoch 值不等时，当前线程可以将该锁重偏向至自己。

## epoch 值

- 每个类维护一个 epoch 值。

- 设置偏向锁时，JVM 要将 epoch 值复制到锁对象标记字段中。

- **撤销偏向锁**要求持有偏向锁的**线程到达安全点**，再将偏向锁**替换成轻量级锁**。

- 某类锁对象**撤销数超过一个阈值，JVM 宣布该类偏向锁失效**。

- 宣布偏向锁失效时，JVM 将该类的 epoch 值加 1。

- 为了保证当前持有偏向锁并且已加锁的线程**不丢锁**，

	- JVM **遍历所有线程的 Java 栈**，找出该类已加锁实例，

	- 将标记字段的 epoch 值加 1（**需要所有线程处于安全点状态**）。

- **总撤销数超过另一个阈值** JVM 认为**这个类不再适合偏向锁**。

	- JVM 会**撤销该类实例的偏向锁**，

	- 之后**加锁直接设置轻量级锁**。
