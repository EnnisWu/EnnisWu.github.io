<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「算法面试通关 40 讲」算法模板]]></title>
    <url>%2F2020%2F05%2F24%2F%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[原文：58 | 课程重点回顾 递归模板123456789101112131415def recursion(level, param1, param2, ...): # recursion terminator if level &gt; MAX_LEVEL print_result return # process logic in current level process_data(level, data...) # drill down self.recursion(level + 1, p1, ...) # reverse the current level status if needed reverse_state(level) 深度优先搜索模板12345678visited = set()def dfs(node, visited): visited.add(node) # process current node here. ... for next_node in node.children(): if not next_node in visited: dif(next_node, visited) 广度优先搜索模板12345678910111213141516def BFS(graph, start, end): queue = [] queue.append([start]) visited.add(start) while queue: node = queue.pop() visited.add(node) process(node) nodes = generate_related_nodes(node) queue.push(nodes) # other processing work ... 二分查找模板1234567891011left, right = 0, len(array) - 1while left &lt;= right: # (left + right) / 2 可能越界 mid = left + (right - left) / 2 if array[mid] == target: # find the target!! break or return result elif array[mid] &lt; target: left = mid + 1 else: right = mid - 1 动态规划模板123456789101112131415161718// 状态定义dp = new int [m + 1][n + 1];// 初始状态dp[0][0] = x;dp[0][1] = y;...// DP状态的推导for i = 0; i &lt;= n; ++i &#123; for j = 0; j &lt;= m; ++j &#123; ... d[i][j] = min &#123;dp[i - 1][j], dp[i][j - 1], etc.&#125; &#125;&#125;return dp[m][n]; 最优解]]></content>
      <categories>
        <category>《算法面试通关 40 讲》</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法面试通关 40 讲」常用的位运算]]></title>
    <url>%2F2020%2F05%2F24%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[原文：39 | 理论讲解：位运算 常用的位运算 判断奇数 x &amp; 1 == 1 清零最低位的 1 X = X &amp; (X - 1) 得到最低位的 1 X &amp; -X 更为复杂的位运算操作 将 x 最右边的 n 位清零 x &amp; (~0 &lt;&lt; n) 获取 x 的第 n 位值 (x &gt;&gt; n) &amp; 1 获取 x 的第 n 位的幂值 x &amp; (1 &lt;&lt; (n - 1)) 仅将第 n 位置为 1 x | (1 &lt;&lt; n) 仅将第 n 为置为 0 x &amp; (~(1 &lt;&lt; n)) 将 x 为高位至第 n 位（含）清零 x &amp; ((1 &lt;&lt; n) - 1) 将第 n 位至第 0 位（含）清零 x &amp; (~((1 &lt;&lt; (n + 1)) - 1))]]></content>
      <categories>
        <category>《算法面试通关 40 讲》</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」HTTP 中 GET 与 POST 的区别]]></title>
    <url>%2F2020%2F05%2F16%2FHTTP%E4%B8%ADGET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[w3schools 答案 GET 在浏览器回退时是无害的，而 POST 会再次提交请求。 GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。 GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。 GET 请求只能进行 url 编码，而 POST 支持多种编码方式。 GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。 GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。 GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。 GET 参数通过 URL 传递，POST 放在 Request body 中。 注意 GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。 对于 GET 方式的请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200（返回数据）。 而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。 只有部分浏览器会发两个数据包，且 header 要加相应参数，且服务端要支持。 增删查改中，GET 语义对应查，POST 语义对应增。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」JVM 内存区域与垃圾回收]]></title>
    <url>%2F2020%2F04%2F26%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[原文 JVM垃圾回收 聊聊Java的GC机制 深入Java虚拟机之 – 总结面试篇 JVM 内存区域 方法区 存储已被虚拟机加载的类信息、常量、静态变量等 堆 JVM 管理的内存中最大的一块 存放对象实例 GC 主要作用的区域 虚拟机栈： 局部变量表、操作数栈 描述 Java 方法执行的内存模型 本地方法栈 与虚拟机栈类似，为 native 方法提供服务 程序计数器 记录当前线程执行的方法执行到了第几行 线程正在执行的是 Java 方法，计数器记录正在执行的虚拟机字节码指令的地址 线程正在执行的是 native 方法，这个计数器值则为空（Undefined） JDK 1.7 之前常量池在方法区，JDK 1.7 之后常量池在堆 堆的划分 JDK 1.8 之前 堆 = 新生代 + 老年代 + 永久代 新生代 = Eden 区 + Survivor from 区 + Survivor to 区 JDK 1.8 之后 堆 = 新生代 + 老年代 + 元空间（使用物理内存） GC 的分类 新生代 GC（Minor GC） 发生新生代的的 GC Minor GC 非常频繁 回收速度一般比较快 老年代 GC（Major GC/Full GC） 发生在老年代的 GC 出现 Major GC 通常会伴随至少一次的 Minor G Major GC 速度一般比 Minor GC 慢 10 倍以上 内存分配规则 对象优先在 Eden 区分配 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC 大对象直接进入老年代 大对象指需要大量连续内存空间的对象（比如：字符串、数组）。 为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 长期存活的对象将进入老年代 动态对象年龄判定 如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 GC Roots 是什么 Garbage Collection RootsA garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:System ClassClass loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .JNI LocalLocal variable in native code, such as user defined JNI code or JVM internal code.JNI GlobalGlobal variable in native code, such as user defined JNI code or JVM internal code.Thread BlockObject referred to from a currently active thread block.ThreadA started, but not stopped, thread.Busy MonitorEverything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.Java LocalLocal variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.Native StackIn or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.FinalizableAn object which is in a queue awaiting its finalizer to be run.UnfinalizedAn object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.UnreachableAn object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.Java Stack FrameA Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.UnknownAn object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump. 由系统类加载器（system class loader）加载的对象 活着的线程，包含处于等待或阻塞的线程 当前被调用的方法（Java 方法，native 方法）的一些参数和局部变量 方法区中静态变量，常量引用的对象 Held by JVM JVM 由于特殊目的为 GC 保留的对象，实际与 JVM 的实现有关。 可能已知的一些类型是：系统类加载器、一些 JVM 知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。 常量池的 gc 该常量没有任何引用 方法区的 gc 该类不存在任何对象 该类 GlassLoader 已被回收 java.lang.Class 对象不存在任何引用，任何地方无反射该类 垃圾回收算法 Mark-Sweep（标记-清除）算法 Copying（复制）算法 1:1 复制 8:1 复制 Mark-Compact（标记-整理）算法 Generational Collection（分代收集）算法 标记-清除算法 标记所有需要回收的对象 统一回收所有被标记的对象 会产生大量不连续的碎片 复制算法（1:1） 将内存分为两块 一块使用完后存活的对象复制到另一块 把已使用的空间清空 标记-整理算法 针对老年代 标记所有需要回收的对象 将存活的对象移到一端 清理端边界以外的内存 分代收集算法 新生代使用复制算法 老年代使用标记-清除算法或标记-整理算法 复制算法（8:1） 新生代内存分配比例： Eden 区 : Survivor from 区 : Survivor to 区 = 8 : 1 : 1 先使用 Eden 区和 from 区 GC 时将存活的对象复制到 to 区 清理 Eden 区和 to 区]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Activity 的相关问题]]></title>
    <url>%2F2020%2F04%2F17%2F%E8%BD%AC-Activity%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[转自：Activity 的 36 大难点，你会几个？「建议收藏」 生命周期Dialog 弹出 如果是单纯是创建的 Dialog，Activity 并不会执行生命周期的方法 什么是 onNewIntent 如果 IntentActivity 处于任务栈的顶端，也就是说之前打开过的 Activity，现在处于 onPause、onStop 状态的话，其他应用再发送 Intent 的话 执行顺序为：onNewIntent，onRestart，onStart，onResume 启动模式Activity 一共有四种 launchMode：Standard、SingleTop、SingleTask、SingleInstance。 Standard 模式（默认模式） 说明：每次启动一个 Activity 都会又一次创建一个新的实例入栈，无论这个实例是否存在。 生命周期：每次被创建的实例 Activity 的生命周期符合典型情况，它的 onCreate、onStart、onResume 都会被调用。 举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 Standard 模式。若在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是还有一个 C Activity 进入栈中，成为栈顶。 SingleTop 模式（栈顶复用模式） 说明：分两种处理情况：须要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity。不会再创建新的 Activity；若须要创建的 Activity 不处于栈顶，此时会又一次创建一个新的 Activity 入栈，同 Standard 模式一样。 生命周期：若情况一中栈顶的 Activity 被直接复用时，它的 onCreate、onStart 不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent 会被回调（Activity 被正常创建时不会回调此方法）。 举例：此时 Activity 栈中以此有 A、B、C 三个 Activity ，此时 C 处于栈顶，启动模式为 SingleTop 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity。结果是直接复用栈顶的 C Activity。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity。结果是创建一个新的 Activity 入栈。成为栈顶。 SingleTask 模式（栈内复用模式） 说明：若须要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶。 如果是在别的应用程序中启动它，则会新建一个 task ，并在该 task 中启动这个 Activity ，SingleTask 允许别的 Activity 与其在一个 task 中共存，也就是说，如果我在这个 SingleTask 的实例中再打开新的 Activity ，这个新的 Activity 还是会在 SingleTask 的实例的 task 中。 生命周期：同 SingleTop 模式中的情况一同样。仅仅会又一次回调 Activity 中的 onNewIntent 方法 举例：此时 Activity 栈中以此有 A、B、C 三个 Activity 。此时 C 处于栈顶，启动模式为 SingleTask 模式。情况一：在 C Activity 中加入点击事件，须要跳转到还有一个同类型的 C Activity 。结果是直接用栈顶的 C Activity 。情况二：在 C Activity 中加入点击事件，须要跳转到还有一个 A Activity 。结果是将 A Activity 上面的 B、C 所有销毁，使 A Activity 成为栈顶。 SingleInstance 模式（单实例模式） 说明：SingleInstance 比较特殊，是全局单例模式，是一种加强的 SingleTask 模式。它除了具有它所有特性外，还加强了一点：只有一个实例，并且这个实例独立运行在一个 task 中，这个 task 只有这个实例，不允许有别的 Activity 存在。 这个经常使用于系统中的应用，比如 Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。 举例：比方 A Activity 是该模式，启动 A 后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的 Activity ，除非这个独特的任务栈被系统销毁。 SingleTask 模式的运用场景 最常见的应用场景就是保持我们应用开启后仅仅有一个 Activity 的实例。 最典型的样例就是应用中展示的主页（Home 页）。 假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用 SingleTask 模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。 SingleTop 模式的运用场景 假设你在当前的 Activity 中又要启动同类型的 Activity 此时建议将此类型 Activity 的启动模式指定为 SingleTop ，能够降低Activity的创建，节省内存！ 注意：复用 Activity 时的生命周期回调 这里还须要考虑一个 Activity 跳转时携带页面參数的问题。 由于当一个 Activity 设置了 SingleTop 或者 SingleTask 模式后，跳转此 Activity 出现复用原有 Activity 的情况时，此 Activity 的 onCreate 方法将不会再次运行。onCreate 方法仅仅会在第一次创建 Activity 时被运行。 而一般 onCreate 方法中会进行该页面的数据初始化、UI 初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题 若页面展示的数据就是通过 getIntent() 方法来获取，那么问题就会出现：getIntent() 获取的一直都是老数据，根本无法接收跳转时传送的新数据！ 这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的 intent ，这样我们就能够解决上述问题。这里建议的方法是又一次去 setIntent。然后又一次去初始化数据和 UI。 数据Activity 间通过 Intent 传递数据大小限制 Intent 在传递数据时是有大小限制的，这里官方并未详细说明，不过通过实验的方法可以测出数据应该被限制在 1MB 之内（1024KB） 我们采用传递 Bitmap 的方法，发现当图片大小超过 1024（准确地说是 1020 左右）的时候，程序就会出现闪退、停止运行等异常(不同的手机反应不同) 因此可以判断 Intent 的传输容量在 1MB 之内。 内存不足时系统会杀掉后台的 Activity，若需要进行一些临时状态的保存，在哪个方法进行 Activity 的 onSaveInstanceState() 和 onRestoreInstanceState() 并不是生命周期方法，它们不同于 onCreate()、onPause() 等生命周期方法，它们并不一定会被触发。 onSaveInstanceState() 方法，当应用遇到意外情况（如：内存不足、用户直接按 Home 键）由系统销毁一个 Activity， onSaveInstanceState() 会被调用。 但是当用户主动去销毁一个 Activity 时，例如在应用中按返回键，onSaveInstanceState() 就不会被调用。 除非该 Activity 不是被用户主动销毁的，通常 onSaveInstanceState() 只适合用于保存一些临时性的状态，而 onPause() 适合用于数据的持久化保存。 onSaveInstanceState() 被执行的场景系统不知道你按下 HOME 后要运行多少其他的程序，自然也不知道 Activity A 是否会被销毁 因此系统都会调用 onSaveInstanceState() ，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则： 当用户按下 HOME 键时 长按 HOME 键，选择运行其他的程序时 锁屏时 从 Activity A 中启动一个新的 Activity 时 屏幕方向切换时]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>四大组件</tag>
        <tag>启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」HashMap 之扰动函数]]></title>
    <url>%2F2020%2F04%2F17%2FHashMap%E4%B9%8B%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[以下源码基于 JDK11 HashMap 添加数据时 Key 的 hashCode 值通过扰动函数重新计算 hash 值，新 hash 值与数组的长度取模得到数组目标下标。 123//长度等于 2 的 n 次幂时，这两种写法效果相同//i = hash % (tab.length - 1)i = (tab.length - 1) &amp; hash 这也是为什么数组的长度始终保持 2 的 n 次幂大小的原因。 详细推理可以看由HashMap哈希算法引出的求余%和与运算&amp;转换问题 当哈希函数映射得比较松散时，碰撞就很难发生，但是 HashMap 的数组长度是有限的，要进行取模操作。这时就算散列值分布松散，只取最后几位碰撞也很严重。 JDK8 之后的扰动函数是这样实现的： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 将 hashCode 值无符号右移 16 位再与自身异或，这样混合了 hashCode 的高位和低位，增加低位的随机性，混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Glide 面试问答]]></title>
    <url>%2F2020%2F04%2F13%2F%E8%BD%AC-Glide%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[转自：聊一聊关于Glide在面试中的那些事 来简单介绍下 Glide 的缓存分析 （这货滔滔不绝的说了一大通，从 LruCache 说到了 LinkedHashMap，巴拉巴拉。。。个人建议这块一定要简述，面试时原理说的太多，第一很多细节会被打断问到，第二点，说这么多，给人的感觉就是在背诵东西，原理概括能力很弱或者感觉根本就没有自己的体会。） 答案 Glide 的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。正式因为有着这两种缓存的结合，才构成了 Glide 极佳的缓存效果。 （先告诉人家有哪几种缓存，主要是为了什么目的才用的缓存，然后可以看着面试官，要么等着他继续问，如果他不问，等着你，这个时候你就可以继续的往细节处介绍） 嗯，具体说一说 Glide 的三级缓存原理分析 （记得，如果需要具体谈原理时，要先宏观，后细节） 答案 读取一张图片的时候，获取顺序：Lru 算法缓存-》弱引用缓存-》磁盘缓存（如果设置了的话）。 当我们的 APP 中想要加载某张图片时，先去 LruCache 中寻找图片，如果 LruCache 中有，则直接取出来使用，并将该图片放入 WeakReference 中，如果 LruCache 中没有，则去 WeakReference 中寻找，如果 WeakReference 中有，则从 WeakReference 中取出图片使用，如果 WeakReference 中也没有图片，则从磁盘缓存/网络中加载图片。 注：图片正在使用时存在于 activeResources 弱引用 map 中。流程如下图： 将图片缓存的时候，写入顺序：弱引用缓存-》Lru算法缓存-》磁盘缓存中。 当图片不存在的时候，先从网络下载图片，然后将图片存入弱引用中，glide 会采用一个 acquired（int）变量用来记录图片被引用的次数， 当 acquired 变量大于 0 的时候，说明图片正在使用中，也就是将图片放到弱引用缓存当中；如果 acquired 变量等于 0 了，说明图片已经不再被使用了，那么此时会调用方法来释放资源，首先会将缓存图片从弱引用中移除，然后再将它 put 到 LruResourceCache 当中。这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。 引深关于 LruCache最近最少使用算法，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致 OOM。LruCache 内部用 LinkHashMap 存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面 put 数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。 关于 LinkedHashMapLinkHashMap 继承 HashMap，在 HashMap 的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头 header 之前，这样就保证了链表头 header 节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在 map 中的位置是不变的）。 Glide加载一个一兆的图片（100 x 100），是否会压缩后再加载，放到一个 300 x 300 的 View 上会怎样，800 x 800 呢，图片会很模糊，怎么处理？分析 （因为你缓存机制无论是看博客还是看一些面试宝典，如果只是考原理或者定义，光把上面的文字背诵下来就可以了，但是背诵和真正的理解是两回事，自己没有形成感悟，不理解这个框架，只是一味的迎合面试，这个问题就可以卡住你，另外千万别和面试官嘚瑟，果然，这个面试的哥们，这块就卡住了，支支吾吾的半天没答上来，果然是只看了博客，没真正的阅读过源码） 答案 当我们调整 ImageView 的大小时，Picasso 会不管 ImageView 大小是什么，总是直接缓存整张图片，而 Glide 就不一样了，它会为每个不同尺寸的 ImageView 缓存一张图片，也就是说不管你的这张图片有没有加载过，只要 ImageView 的尺寸不一样，那么 Glide 就会重新加载一次，这时候，它会在加载的 ImageView 之前从网络上重新下载，然后再缓存。 举个例子，如果一个页面的 ImageView 是 300 x 300 像素，而另一个页面中的 ImageView 是 100 x 100 像素，这时候想要让两个 ImageView 像是同一张图片，那么 Glide 需要下载两次图片，并且缓存两张图片。 12345public &lt;R&gt; LoadStatus load() &#123; // 根据请求参数得到缓存的键 EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options);&#125; 看到了吧，缓存 Key 的生成条件之一就是控件的长宽。 简单说一下内存泄漏的场景，如果在一个页面中使用 Glide 加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？分析 （注意一定要审题，因为之前问了这个小伙，内存泄漏的原因，无非是长生命周期引用了短生命周期的对象等等，然后突然画风一变，直接问了 Glide 加载图片会不会引起图片泄漏，这个小伙想也没想，直接回答道会引起内存泄漏，可以用 LeakCanary 检测，巴拉巴拉。。。） 答案 因为 Glide 在加载资源的时候，如果是在 Activity、Fragment 这一类有生命周期的组件上进行的话，会创建一个透明的 RequestManagerFragment 加入到FragmentManager 之中，感知生命周期，当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源。但是如果，是在非生命周期的组件上进行时，会采用 Application 的生命周期贯穿整个应用，所以 ApplicationManager 只有在应用程序关闭的时候终止加载。 如何设计一个大图加载框架分析 (这个孩子，总算是羞愧的低下了头，一脸懵逼的和我说，这个我忘记了) 答案 概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作。 封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程； 解析路径：图片的来源有多种，格式也不尽相同，需要规范化； 读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（Bitmap）即可； 查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载； 解码：这一步是整个过程中最复杂的步骤之一，有不少细节，下个博客会说； 变换：解码出 Bitmap 之后，可能还需要做一些变换处理（圆角，滤镜等）； 缓存：得到最终 bitmap 之后，可以缓存起来，以便下次请求时直接取结果； 显示：显示结果，可能需要做些动画（淡入动画，CrossFade 等）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>图片框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」为什么 View.post() 能获取到 View 的宽高]]></title>
    <url>%2F2020%2F04%2F13%2F%E4%B8%BA%E4%BB%80%E4%B9%88View-post-%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0View%E7%9A%84%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[为什么在 onCreate() 和第一次 onResume() 中无法获取到宽高我们知道 View 的绘制是从 ViewRootImpl.performTraversals() 方法开始的，而 performTraversals() 是在 onResume() 之后才被调用，所以在 onCreate() 和第一次 onResume() 中无法获取到 View 的宽高。 为什么 View.post() 能获取到宽高123456789101112//class Viewpublic boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; attachInfo 不为空时直接发送事件 attachInfo 为空时会暂时缓存任务 12345678910111213141516//class HandlerActionQueuepublic void post(Runnable action) &#123; postDelayed(action, 0);&#125;public void postDelayed(Runnable action, long delayMillis) &#123; final HandlerAction handlerAction = new HandlerAction(action, delayMillis); synchronized (this) &#123; if (mActions == null) &#123; mActions = new HandlerAction[4]; &#125; mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction); mCount++; &#125;&#125; 缓存的任务何时发送在 View.dispatchAttachedToWindow() 方法中发送事件 123456789//class Viewvoid dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; ... if (mRunQueue != null) &#123; mRunQueue.executeActions(info.mHandler); mRunQueue = null; &#125; ...&#125; 12345678910111213//class HandlerActionQueuepublic void executeActions(Handler handler) &#123; synchronized (this) &#123; final HandlerAction[] actions = mActions; for (int i = 0, count = mCount; i &lt; count; i++) &#123; final HandlerAction handlerAction = actions[i]; handler.postDelayed(handlerAction.action, handlerAction.delay); &#125; mActions = null; mCount = 0; &#125;&#125; dispatchAttachedToWindow() 何时被调用在 ViewRootImpl.performTraversals() 方法中会调用 dispatchAttachedToWindow() 方法，该方法在 View 的测量、布局、绘制之前被调用。 dispatchAttachedToWindow() 方法和测量、布局、绘制一样会递归调用子 View。 12345678910111213141516171819202122232425262728293031323334353637383940414243//class ViewRootImplprivate void performTraversals() &#123; final View host = mView; ... if (mFirst) &#123; ... host.dispatchAttachedToWindow(mAttachInfo, 0); ... &#125; else &#123; ... &#125; ... if (mFirst || ...) &#123; ... if (...) &#123; ... if (...) &#123; ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... if (measureAgain) &#123; ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; ... &#125; &#125; &#125; else &#123; ... &#125; ... if (...) &#123; performLayout(lp, mWidth, mHeight); ... &#125; if (...) &#123; ... performDraw(); &#125; else &#123; ... &#125; ...&#125; 为何 dispatchAttachedToWindow() 先于测量调用却能获取到宽高实际上 ViewRootImpl.performTraversals() 也是在事件循环中被执行的，所以缓存的任务会在 ViewRootImpl.performTraversals() 之后执行。 123456789//class ViewRootImplvoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; ... mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ... &#125;&#125; 12345678//class ViewRootImplfinal class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 12345678//class ViewRootImplvoid doTraversal() &#123; if (mTraversalScheduled) &#123; ... performTraversals(); ... &#125;&#125; 总结View.post() 中的任务在 ViewRootImpl.performTraversals()，执行完之前会被缓存，待 ViewRootImpl.performTraversals() 执行完后执行，所以可以获取到宽高。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」RenderObject 和 RenderBox]]></title>
    <url>%2F2020%2F04%2F10%2F%E8%BD%AC-RenderObject%E5%92%8CRenderBox%2F</url>
    <content type="text"><![CDATA[转自：14.3 RenderObject和RenderBox RenderObject就是渲染树中的一个对象，它拥有一个parent和一个parentData 插槽（slot），所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而parentData正是一个预留变量，它正是由parent 来赋值的，parent通常会通过子RenderObject的parentData存储一些和子元素相关的数据，如在Stack布局中，RenderStack就会将子元素的偏移数据存储在子元素的parentData中（具体可以查看Positioned实现）。 RenderObject类本身实现了一套基础的layout和绘制协议，但是并没有定义子节点模型（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。 它也没有定义坐标系统（如子节点定位是在笛卡尔坐标中还是极坐标？）和具体的布局协议（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，Flutter提供了一个RenderBox类，它继承自RenderObject，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴，大多数情况下，我们直接使用RenderBox就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下RenderBox。 布局过程Constraints在RenderBox 中，有个size属性用来保存控件的宽和高。RenderBox的layout是通过在组件树中从上往下传递BoxConstraints对象的实现的。BoxConstraints对象可以限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件。 在布局阶段，父节点会调用子节点的layout()方法，下面我们看看RenderObject中layout()方法的大致实现（删掉了一些无关代码和异常捕获）: 1234567891011121314151617void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123; ... RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123; relayoutBoundary = this; &#125; else &#123; final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; &#125; ... if (sizedByParent) &#123; performResize(); &#125; performLayout(); ...&#125; 可以看到layout方法需要传入两个参数，第一个为constraints，即 父节点对子节点大小的限制，该值根据父节点的布局逻辑确定。另外一个参数是 parentUsesSize，该值用于确定 relayoutBoundary，该参数表示子节点布局变化是否影响父节点，如果为true，当子节点布局发生变化时父节点都会标记为需要重新布局，如果为false，则子节点布局发生变化后不会影响父节点。 relayoutBoundary上面layout()源码中定义了一个relayoutBoundary变量，什么是 relayoutBoundary？在前面介绍Element时，我们讲过当一个Element标记为 dirty 时便会重新build，这时RenderObject便会重新布局，我们是通过调用 markNeedsBuild() 来标记Element为dirty的。在RenderObject中有一个类似的markNeedsLayout()方法，它会将RenderObject的布局状态标记为 dirty，这样在下一个frame中便会重新layout，我们看看RenderObject的markNeedsLayout()的部分源码： 1234567891011121314void markNeedsLayout() &#123; ... assert(_relayoutBoundary != null); if (_relayoutBoundary != this) &#123; markParentNeedsLayout(); &#125; else &#123; _needsLayout = true; if (owner != null) &#123; ... owner._nodesNeedingLayout.add(this); owner.requestVisualUpdate(); &#125; &#125;&#125; 代码大致逻辑是先判断自身是不是relayoutBoundary，如果不是就继续向parent 查找，一直向上查找到是 relayoutBoundary 的 RenderObject为止，然后再将其标记为 dirty 的。这样来看它的作用就比较明显了，意思就是当一个控件的大小被改变时可能会影响到它的 parent，因此 parent 也需要被重新布局，那么到什么时候是个头呢？答案就是 relayoutBoundary，如果一个 RenderObject 是 relayoutBoundary，就表示它的大小变化不会再影响到 parent 的大小了，于是 parent 也就不用重新布局了。 performResize 和 performLayoutRenderBox实际的测量和布局逻辑是在performResize() 和 performLayout()两个方法中，RenderBox子类需要实现这两个方法来定制自身的布局逻辑。根据layout() 源码可以看出只有 sizedByParent 为 true 时，performResize() 才会被调用，而 performLayout() 是每次布局都会被调用的。sizedByParent 意为该节点的大小是否仅通过 parent 传给它的 constraints 就可以确定了，即该节点的大小与它自身的属性和其子节点无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent就应该返回true，此时其大小在 performResize() 中就确定了，在后面的 performLayout() 方法中将不会再被修改了，这种情况下 performLayout() 只负责布局子节点。 在 performLayout() 方法中除了完成自身布局，也必须完成子节点的布局，这是因为只有父子节点全部完成后布局流程才算真正完成。所以最终的调用栈将会变成：layout() &gt; performResize()/performLayout() &gt; child.layout() &gt; … ，如此递归完成整个UI的布局。 RenderBox子类要定制布局算法不应该重写layout()方法，因为对于任何RenderBox的子类来说，它的layout流程基本是相同的，不同之处只在具体的布局算法，而具体的布局算法子类应该通过重写performResize() 和 performLayout()两个方法来实现，他们会在layout()中被调用。 ParentData当layout结束后，每个节点的位置（相对于父节点的偏移）就已经确定了，RenderObject就可以根据位置信息来进行最终的绘制。但是在layout过程中，节点的位置信息怎么保存？对于大多数RenderBox子类来说如果子类只有一个子节点，那么子节点偏移一般都是Offset.zero ，如果有多个子节点，则每个子节点的偏移就可能不同。而子节点在父节点的偏移数据正是通过RenderObject的parentData属性来保存的。在RenderBox中，其parentData属性默认是一个BoxParentData对象，该属性只能通过父节点的setupParentData()方法来设置： 12345678abstract class RenderBox extends RenderObject &#123; @override void setupParentData(covariant RenderObject child) &#123; if (child.parentData is! BoxParentData) child.parentData = BoxParentData(); &#125; ...&#125; BoxParentData定义如下： 12345678/// Parentdata 会被RenderBox和它的子类使用.class BoxParentData extends ParentData &#123; /// offset表示在子节点在父节点坐标系中的绘制偏移 Offset offset = Offset.zero; @override String toString() =&gt; 'offset=$offset';&#125; 一定要注意，RenderObject的parentData 只能通过父元素设置. 当然，ParentData并不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的ParentData中，如ContainerBox的ParentData就保存了指向兄弟节点的previousSibling和nextSibling，Element.visitChildren()方法也正是通过它们来实现对子节点的遍历。再比如KeepAlive 组件，它使用KeepAliveParentDataMixin（继承自ParentData） 来保存子节的keepAlive状态。 绘制过程RenderObject可以通过paint()方法来完成具体绘制逻辑，流程和布局流程相似，子类可以实现paint()方法来完成自身的绘制逻辑，paint()签名如下： 1void paint(PaintingContext context, Offset offset) &#123; &#125; 通过context.canvas可以取到Canvas对象，接下来就可以调用Canvas API来实现具体的绘制逻辑。 如果节点有子节点，它除了完成自身绘制逻辑之外，还要调用子节点的绘制方法。我们以RenderFlex对象为例说明： 123456789101112131415161718192021222324252627282930313233@overridevoid paint(PaintingContext context, Offset offset) &#123; // 如果子元素未超出当前边界，则绘制子元素 if (_overflow &lt;= 0.0) &#123; defaultPaint(context, offset); return; &#125; // 如果size为空，则无需绘制 if (size.isEmpty) return; // 剪裁掉溢出边界的部分 context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, defaultPaint); assert(() &#123; final String debugOverflowHints = '...'; //溢出提示内容，省略 // 绘制溢出部分的错误提示样式 Rect overflowChildRect; switch (_direction) &#123; case Axis.horizontal: overflowChildRect = Rect.fromLTWH(0.0, 0.0, size.width + _overflow, 0.0); break; case Axis.vertical: overflowChildRect = Rect.fromLTWH(0.0, 0.0, 0.0, size.height + _overflow); break; &#125; paintOverflowIndicator(context, offset, Offset.zero &amp; size, overflowChildRect, overflowHints: debugOverflowHints); return true; &#125;());&#125; 代码很简单，首先判断有无溢出，如果没有则调用defaultPaint(context, offset)来完成绘制，该方法源码如下： 123456789void defaultPaint(PaintingContext context, Offset offset) &#123; ChildType child = firstChild; while (child != null) &#123; final ParentDataType childParentData = child.parentData; //绘制子节点， context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; &#125;&#125; 很明显，由于Flex本身没有需要绘制的东西，所以直接遍历其子节点，然后调用paintChild()来绘制子节点，同时将子节点ParentData中在layout阶段保存的offset加上自身偏移作为第二个参数传递给paintChild()。而如果子节点还有子节点时，paintChild()方法还会调用子节点的paint()方法，如此递归完成整个节点树的绘制，最终调用栈为： paint() &gt; paintChild() &gt; paint() … 。 当需要绘制的内容大小溢出当前空间时，将会执行paintOverflowIndicator() 来绘制溢出部分提示，这个就是我们经常看到的溢出提示，如图所示： RepaintBoundary我们已经在CustomPaint一节中介绍过RepaintBoundary，现在我们深入的了解一些。与 RelayoutBoundary 相似，RepaintBoundary是用于在确定重绘边界的，与RelayoutBoundary不同的是，这个绘制边界需要由开发者通过RepaintBoundary 组件自己指定，如： 1234567CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), child: RepaintBoundary( child: Container(...), ),), 下面我们看看RepaintBoundary的原理，RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立于其父元素，如果该属性值为true ，则独立绘制，反之则一起绘制。那独立绘制是怎么实现的呢？ 答案就在paintChild()源码中： 12345678910void paintChild(RenderObject child, Offset offset) &#123; ... if (child.isRepaintBoundary) &#123; stopRecordingIfNeeded(); _compositeChild(child, offset); &#125; else &#123; child._paintWithContext(this, offset); &#125; ...&#125; 我们可以看到，在绘制子节点时，如果child.isRepaintBoundary 为 true则会调用_compositeChild()方法，_compositeChild()源码如下： 1234567891011void _compositeChild(RenderObject child, Offset offset) &#123; // 给子节点创建一个layer ，然后再上面绘制子节点 if (child._needsPaint) &#123; repaintCompositedChild(child, debugAlsoPaintedParent: true); &#125; else &#123; ... &#125; assert(child._layer != null); child._layer.offset = offset; appendLayer(child._layer);&#125; 很明显了，独立绘制是通过在不同的layer（层）上绘制的。所以，很明显，正确使用isRepaintBoundary属性可以提高绘制效率，避免不必要的重绘。具体原理是：和触发重新build和layout类似，RenderObject也提供了一个markNeedsPaint()方法，其源码如下： 1234567891011121314151617181920212223void markNeedsPaint() &#123; ... //如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制 if (isRepaintBoundary) &#123; ... if (owner != null) &#123; //找到最近的layer，绘制 owner._nodesNeedingPaint.add(this); owner.requestVisualUpdate(); &#125; &#125; else if (parent is RenderObject) &#123; // 没有自己的layer, 会和一个祖先节点共用一个layer assert(_layer == null); final RenderObject parent = this.parent; // 向父级递归查找 parent.markNeedsPaint(); assert(parent == this.parent); &#125; else &#123; // 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。 if (owner != null) owner.requestVisualUpdate(); &#125;&#125; 可以看出，当调用 markNeedsPaint() 方法时，会从当前 RenderObject 开始一直向父节点查找，直到找到 一个isRepaintBoundary 为 true的RenderObject 时，才会触发重绘，这样便可以实现局部重绘。当 有RenderObject 绘制的很频繁或很复杂时，可以通过RepaintBoundary Widget来指定isRepaintBoundary 为 true，这样在绘制时仅会重绘自身而无需重绘它的 parent，如此便可提高性能。 还有一个问题，通过RepaintBoundary 如何设置isRepaintBoundary属性呢？其实，如果使用了RepaintBoundary，其对应的RenderRepaintBoundary会自动将isRepaintBoundary设为true的： 1234567class RenderRepaintBoundary extends RenderProxyBox &#123; /// Creates a repaint boundary around [child]. RenderRepaintBoundary(&#123; RenderBox child &#125;) : super(child); @override bool get isRepaintBoundary =&gt; true;&#125; 命中测试一个对象是否可以响应事件，取决于其对命中测试的返回，当发生用户事件时，会从根节点（RenderView）开始进行命中测试，下面是RenderView的hitTest()源码： 123456bool hitTest(HitTestResult result, &#123; Offset position &#125;) &#123; if (child != null) child.hitTest(result, position: position); //递归子RenderBox进行命中测试 result.add(HitTestEntry(this)); //将测试结果添加到result中 return true;&#125; 我们再看看RenderBox默认的hitTest()实现： 12345678910bool hitTest(HitTestResult result, &#123; @required Offset position &#125;) &#123; ... if (_size.contains(position)) &#123; if (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123; result.add(BoxHitTestEntry(this, position)); return true; &#125; &#125; return false;&#125; 我们看到默认的实现里调用了hitTestSelf()和hitTestChildren()两个方法，这两个方法默认实现如下： 12345@protectedbool hitTestSelf(Offset position) =&gt; false;@protectedbool hitTestChildren(HitTestResult result, &#123; Offset position &#125;) =&gt; false; hitTest 方法用来判断该RenderObject 是否在被点击的范围内，同时负责将被点击的 RenderBox 添加到 HitTestResult 列表中，参数 position 为事件触发的坐标（如果有的话），返回 true 则表示有RenderBox 通过了命中测试，需要响应事件，反之则认为当前RenderBox没有命中。在继承RenderBox时，可以直接重写hitTest()方法，也可以重写 hitTestSelf() 或 hitTestChildren(), 唯一不同的是 hitTest()中需要将通过命中测试的节点信息添加到命中测试结果列表中，而 hitTestSelf() 和 hitTestChildren()则只需要简单的返回true或false。 语义化语义化即Semantics，主要是提供给读屏软件的接口，也是实现辅助功能的基础，通过语义化接口可以让机器理解页面上的内容，对于有视力障碍用户可以使用读屏软件来理解UI内容。如果一个RenderObject要支持语义化接口，可以实现 describeApproximatePaintClip和 visitChildrenForSemantics方法和semanticsAnnotator getter。更多关于语义化的信息可以查看API文档。 总结本节我们介绍了RenderObject主要的功能和方法，理解这些内容可以帮助我们更好的理解Flutter UI底层原理。我们也可以看到，如果要从头到尾实现一个RenderObject是比较麻烦的，我们必须去实现layout、绘制和命中测试逻辑，但是值得庆幸的是，大多数时候我们可以直接在Widget层通过组合或者CustomPaint完成自定义UI。如果遇到只能定义一个新RenderObject的场景时（如要实现一个新的layout算法的布局容器），可以直接继承自RenderBox，这样可以帮我们减少一部分工作。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「原创」Flutter 输入框获得焦点失效问题]]></title>
    <url>%2F2020%2F04%2F10%2FFlutter%E8%BE%93%E5%85%A5%E6%A1%86%E8%8E%B7%E5%BE%97%E7%84%A6%E7%82%B9%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述Flutter 中 TextField 由 disable 状态变为 enable 状态时获取焦点会失效，比如下面这段代码： 1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; final focusNode = FocusNode(); var editable = false; void _changeFocus() &#123; setState(() &#123; editable = !editable; if (editable) &#123; FocusScope.of(context).requestFocus(focusNode); &#125; &#125;); &#125; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( title: Text('输入框获得焦点'), ), body: TextField( focusNode: focusNode, enabled: editable, decoration: InputDecoration(hintText: '输入'), ), floatingActionButton: FloatingActionButton( onPressed: _changeFocus, child: Icon(Icons.edit), ), );&#125; 或者是这样 12345678void _changeFocus() &#123; setState(() &#123; editable = !editable; &#125;); if (editable) &#123; FocusScope.of(context).requestFocus(focusNode); &#125;&#125; 我们希望将 TextField 的状态改为 enable 并获得焦点，但这两种写法都是无法获取到焦点的。 问题原因我们知道 Flutter 是通过事件驱动更新 UI 的，通过 setState() 方法添加一个更新 UI 事件，当这个事件到达时就会更新 UI。 上述写法失效的原因就在于我们获取焦点时 UI 还未更新，TextField 还处于 disable 状态，是无法获取到焦点的。 我们应该在 build() 方法完成后获取焦点，这时 TextField 已处于 enable 状态。 addPostFrameCallback()通过 SchedulerBinding.instance.addPostFrameCallback() 方法可以注册下一帧绘制完成回调方法。 该回调只会在下一帧绘制结束时被调用一次，调用后会被系统移除。 可以通过该方法监听下一次 build 完成，然后获取焦点。 解决方法下面的写法就可以成功获取到焦点 123456789void _changeFocus() &#123; setState(() &#123; editable = !editable; if (editable) &#123; SchedulerBinding.instance.addPostFrameCallback( (_) =&gt; FocusScope.of(context).requestFocus(focusNode)); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」为什么双重检查单例需要使用 volatile 关键字]]></title>
    <url>%2F2020%2F04%2F10%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8D%95%E4%BE%8B%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[原文：Java并发编程：volatile关键字解析 内存模型 CPU 从高速缓存存取数据 多核 CPU 每个线程有自己的高速缓存 并发编程原子性 通过 synchronized 和 Lock 保证原子性 可见性 通过 synchronized 和 Lock 保证可见性 在锁释放之前将修改的变量刷新到主存 变量通过 volatile 关键字修饰保证可见性 修改变量立即刷新到主存 读取变量强制到主存读取 有序性 通过 synchronized 和 Lock 保证有序性 Java 内存模型 happens-before 原则 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作 A 先行发生于操作 B ，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始 volatile 关键字的两层语义 保证变量的可见性 禁止指令重排序 为什么双重检查单例需要使用 volatile 关键字instance = new Singleton(); 不是一个原子操作，可以分为 3 步： 分配内存空间 初始化对象 将 instance 指向内存地址 由于存在指令重排，执行顺序可能变为 1 -&gt; 3 -&gt; 2。 当 3 执行完，2 未执行时，新线程进入检查 instance != null，直接返回，会抛出对象未初始化错误。 使用 volatile 可以禁止指令重排。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」事件分发流程简述]]></title>
    <url>%2F2020%2F04%2F09%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[原文 通过流程图来分析Android事件分发 事件分发机制，我们从细节中学习！ 触摸事件 Android 用来描述手对屏幕做的事情得最小单元关键字：手势，最小单元 点击事件、长按事件、滑动事件由不可拆分得事件组合。 MotionEvent 事件类型 getAction() 如 ACTION_DOWN（按下）、ACTION_ MOVE（移动）、ACTION_ UP（抬起）等 屏幕参考线坐标 getRawX() getRawY() View 参考系坐标 getX() getY() 事件序列 ACTION_DOWN（1个） ACTION_MOVE（N个） ACTION_UP（1个） TouchTarget1234567891011private static final class TouchTarget &#123; // The touched child view. @UnsupportedAppUsage public View child; // The combined bit mask of pointer ids for all pointers captured by the target. public int pointerIdBits; // The next target in the target list. public TouchTarget next;&#125; child 消耗事件的目标 View pointerIdBits 目标捕获的所有指针 id 的组合位掩码 next 组成链表 dispatchTouchEvent(MotionEvent) 分发触摸事件给 Target（包括自己） 返回是否已处理触摸事件 View 不存在子 View 所以不存在分发，只处理自己 View 的事件分发dispatchTouchEvent(MotionEvent) ViewGroup 的事件分发dispatchTouchEvent(MotionEvent) 特点 责任链模式，但不是纯责任链模式 target、disallowIntercept 影响 1 个事件序列的不同触摸事件 ACTION_DOWN 事件寻找 target 非 ACTION_DOWN 使用 target，根据 target 和 disallowIntercept 控制事件传递流程 事件传递可能被抛回来 ACTION_DOWN 事件 清空 target 无需考虑 disallowIntercept onInterceptTouchEvent() 不拦截，沿着责任链向后传 子 View 处理，找到 target，返回 true 子 View 不处理，ViewGroup 事件分发退化为 View 事件分发 返回 super.dispatchTouchEvent() onInterceptTouchEvent() 拦截 返回 super.dispatchTouchEvent() 非 ACTION_DOWN 事件 检查是否有 target 无 target返回 super.dispatchTouchEvent() 有 target 子 View 禁止拦截，直接传递给 target 子 View 不禁止拦截，onInterceptEvent() 不拦截，传递给 target 子 View 不禁止拦截，onInterceptEvent() 拦截 返回 super.dispatchTouchEvent() disallowIntercept 变量 通过 public requestDisallowInterceptTouchEvent(boolean) 设置 true 标识禁止拦截，即子 View 一定要这个事件 false 表示不禁止拦截，即子 View 不知道要不要 两级 View 事件分发规律ViewGroup 需要所有事件 ACTION_DOWN 事件里拦截事件，不传递给子 View ACTION_DOWN 事件 -&gt; onInterceptTouchEvent() 拦截 -&gt; super.dispatchTouchEvent() 子 View 需要所有事件 设置 disallowIntercept 禁止拦截 ACTION_DOWN 事件 -&gt; onInterceptTouchEvent() 不拦截 -&gt; 子 View 的 dispatchTouchEvent()，设置 disallowIntercept 禁止拦截 ViewGroup 和子 View 需要特定事件 ACTION_DOWN 事件，ViewGroup 不拦截，子 View 必须处理 不确定是否处理，target -&gt; disallowIntercept 不禁止拦截 -&gt; onInterceptTouchEvent() 不拦截 -&gt; 子 View 的 dispatchTouchEvent() ViewGroup 决定要的事件，onInterceptTouchEvent() 拦截 View 决定要的事件，设置 disallowIntercept 禁止拦截]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」TCP 为什么需要 3 次握手和 4 次挥手]]></title>
    <url>%2F2020%2F03%2F26%2FTCP%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%813%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[原文 TCP为什么需要3次握手与4次挥手 iOS：为什么TCP连接要三次握手，四次挥手 三次握手为什么便于阅读，我们将三次握手称为 hello1，hello2，hello3。 防止服务端一直等待假设只需要两次握手，如果服务端收到一条已失效的 hello1 请求，服务端会认为是客户端的新请求并回复 hello2 ，客户端收到后不会 hello3 和发送数据，这时候服务端会一直保持等待状态，浪费资源。 从另一个角度思考 A 向 B 发送 hello1：B 确认 A 发送正常，B 接收正常 B 向 A 发送 hello2：A 确认 A 发送接收正常，B 发送接收正常 A 向 B 发送 hello3：B 确认 A 接收正常，B 发送正常 三次握手可以保证客户端和服务端双方确认双方的发送和接收都是正常的。 三次握手状态 客户端发送：SYN = 1, seq = x 客户端 SYN-SENT 状态 服务端发送：SYN = 1, seq = y, ACK = 1, ack = x + 1 服务端 SYN-RCVD 状态 客户端发送：ACK = 1, ack = y + 1 客户端，服务端 ESTABLISHED 状态 四次挥手四次挥手状态 客户端发送：FIN = 1, seq = x 客户端停止发送数据，但接收数据 客户端 FIN-WAIT-1 状态 服务端发送：seq = y, ACK = 1, ack = x + 1 服务端确认，发送最后的数据 服务端 CLOSE-WAIT 状态 客户端 FIN-WAIT-2 状态 服务端发送：FIN = 1, seq = z, ACK = 1, ack = x + 1 服务端停止发送数据 服务端 LAST-ACK 状态 客户端发送：seq = x + 1, ACK = 1, ack = z + 1 服务端 CLOSE 状态 客户端 TIME-WAIT 状态，2MSL 后 CLOSE 状态 为什么需要四次挥手？因为 TCP 是全双工模式，双方都都需要确认关闭，为了保证服务端的数据发送完全，服务端的 ACK 和 FIN 分为两个报文发送（对比三次握手）。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Flutter 动画曲线 Curves 效果一览]]></title>
    <url>%2F2020%2F03%2F23%2F%E8%BD%AC-Flutter%E5%8A%A8%E7%94%BB%E6%9B%B2%E7%BA%BFCurves%E6%95%88%E6%9E%9C%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[Flutter 动画曲线 Curves 效果一览]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」HTTPS 是如何保证安全的]]></title>
    <url>%2F2020%2F03%2F20%2FHTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%2F</url>
    <content type="text"><![CDATA[原文：写一篇最好懂的HTTPS讲解 对称加密 客户端和服务端使用同一个密钥 加解密效率高 非对称加密 密钥分为公钥和私钥 公钥加密只有私钥才能解密 私钥加密只有公钥才能解密 公钥一般存放在客户端，私钥一般存放在服务端 安全性更高 HTTPS 原理简述 网站管理员向 CA 机构申请证书 证书包含该网站的公钥，域名等其他信息 证书使用 CA 自己的私钥加密 服务端配置证书 客户端发起请求，服务端返回证书 客户端使用 CA 的公钥解密证书 解密成功且域名和其他信息与该网站相符则安全 得到网站公钥 客户端与服务端商定对称加密密钥 过程中客户端使用网站公钥，服务端使用私钥 对称加密密钥由客户端随机生成 双方使用对称加密通信 问题为什么 HTTP 不安全 明文传输 可能被监听 可能被篡改 如何既保证效率又保证安全 保证效率 采用对称加密 保证安全 对称加密密钥由客户端随机生成 首次商定密钥使用非对称加密，客户端公钥加密，服务端私钥解密 如何保证获的服务端公钥不被篡改 由 CA 机构签发证书，证书包含网站公钥和域名等其他信息 证书使用 CA 机构私钥加密 CA 机构数量有限，操作系统可以内置所有 CA 机构公钥 HTTPS 使用对称加密还是非对称加密？HTTP 使用两种加密结合的方式 CA 证书使用非对称加密 网站商定密钥使用非对称加密 传输内容使用对称加密 为什么不直接使用非对称加密通信？对称加密更高效]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」BuildContext是什么？]]></title>
    <url>%2F2020%2F03%2F19%2FBuildContext%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[小部件树中小部件位置的句柄。 此类提供了一组可以从 StatelessWidget.build 方法和 State 对象上的方法使用的方法。 BuildContext 对象将传递到 WidgetBuilder 函数（例如 StatelessWidget.build），并且可以从 State.context 成员获得。一些静态函数（例如 showDialog，Theme.of 等）也采用构建上下文，以便它们可以代表调用窗口小部件执行操作，或获取特定于给定上下文的数据。 每个窗口小部件都有其自己的BuildContext，它将成为 StatelessWidget.build 或 State.build 函数返回的窗口小部件的父级。 （同样，RenderObjectWidgets 的任何子项的父项。） 随着小部件在树上移动，特定小部件的 BuildContext 可以随时间改变位置。因此，从类的方法返回的值不应在执行单个同步函数之后进行缓存。 BuildContext对象实际上是Element对象。 BuildContext接口用于阻止对Element对象的直接操作。 原文：BuildContext class A handle to the location of a widget in the widget tree. This class presents a set of methods that can be used from StatelessWidget.build methods and from methods on State objects. BuildContext objects are passed to WidgetBuilder functions (such as StatelessWidget.build), and are available from the State.context member. Some static functions (e.g. showDialog, Theme.of, and so forth) also take build contexts so that they can act on behalf of the calling widget, or obtain data specifically for the given context. Each widget has its own BuildContext, which becomes the parent of the widget returned by the StatelessWidget.build or State.build function. (And similarly, the parent of any children for RenderObjectWidgets.) The BuildContext for a particular widget can change location over time as the widget is moved around the tree. Because of this, values returned from the methods on this class should not be cached beyond the execution of a single synchronous function. BuildContext objects are actually Element objects. The BuildContext interface is used to discourage direct manipulation of Element objects.]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」When & Where 使用 Key，怎样选择 Key]]></title>
    <url>%2F2020%2F03%2F18%2FWhen-Where%E4%BD%BF%E7%94%A8Key%EF%BC%8C%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9Key%2F</url>
    <content type="text"><![CDATA[何时使用密钥 - Flutter小部件 101 第四集]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「原创」为什么嵌套一层 Builder 后 Scaffold.of 方法就不报错了]]></title>
    <url>%2F2020%2F03%2F18%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B5%8C%E5%A5%97%E4%B8%80%E5%B1%82Builder%E5%90%8EScaffold-of%E6%96%B9%E6%B3%95%E5%B0%B1%E4%B8%8D%E6%8A%A5%E9%94%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[错误案例我们可能经常需要调用 Scaffold.of() 方法去调用 showSnackBar 或 showBottomSheet 等方法，如下面的代码所示。 12345678910111213141516171819202122232425262728293031323334353637383940import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( floatingActionButton: FloatingActionButton( onPressed: () &#123; Scaffold.of(context) .showSnackBar(SnackBar(content: Text('This is SnackBar!'))); &#125;, child: Icon(Icons.add), ), ); &#125;&#125; 当运行这段代码点击按钮后却报出这样的错误： The following assertion was thrown while handling a gesture:Scaffold.of() called with a context that does not contain a Scaffold. No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). This usually happens when the context provided is from the same StatefulWidget as that whose build function actually creates the Scaffold widget being sought. context 没有在祖先 Widget 中找到 Scaffold。FloatingActionBottom 明明是 Scaffold 的孩子 Widget，为什么没有找到呢？ 解决方案方案一 嵌套一层 Builder如下面代码所示，在 FloatingActionButton 外添加一层 Builder 便可以正常运行。 1234567891011121314@overrideWidget build(BuildContext context) &#123; return Scaffold( floatingActionButton: Builder( builder: (context) =&gt; FloatingActionButton( onPressed: () &#123; Scaffold.of(context) .showSnackBar(SnackBar(content: Text('This is SnackBar!'))); &#125;, child: Icon(Icons.add), ), ), );&#125; 方法二 使用 GlobalKey.of 方法的原理由源码可知，通过传入的 BuildContext 调用 findAncestorStateOfType 方法找到祖先 ScaffoldState，当祖先 Widget 中没有 Scaffold 时报错。 12345678910111213141516171819202122static ScaffoldState of(BuildContext context, &#123; bool nullOk = false &#125;) &#123; assert(nullOk != null); assert(context != null); final ScaffoldState result = context.findAncestorStateOfType&lt;ScaffoldState&gt;(); if (nullOk || result != null) return result; throw FlutterError.fromParts(&lt;DiagnosticsNode&gt;[ ErrorSummary( '...' ), ErrorDescription( '...' ), ErrorHint( '...' ), ErrorHint( '...' ), context.describeElement('The context used was') ]); &#125; 报错原因从错误案例代码我们可以看到，传入 of 的 BuildContext 是 _MyHomePageState 中 build 方法的参数，显然 _MyHomePageState 的祖先中并没有 Scaffold，所以报错没有找到 Scaffold。 Builder 的原理1typedef WidgetBuilder = Widget Function(BuildContext context); 12345678910111213class Builder extends StatelessWidget &#123; const Builder(&#123; Key key, @required this.builder, &#125;) : assert(builder != null), super(key: key); final WidgetBuilder builder; @override Widget build(BuildContext context) =&gt; builder(context);&#125; 由源码可知，Builder 接收一个 WidgetBuilder 方法，在 build 方法中回调了 WidgetBuilder 方法，并将自己的 BuildContext 传入。 解决原因为了便于查看，我们将修正后源码中 _MyHomePageState.build 的参数名改为 contextA，将传入 Builder 的 WidgetBuilder 方法的参数名改为 contextB。 1234567891011121314@overrideWidget build(BuildContext contextA) &#123; return Scaffold( floatingActionButton: Builder( builder: (contextB) =&gt; FloatingActionButton( onPressed: () &#123; Scaffold.of(contextB) .showSnackBar(SnackBar(content: Text('This is SnackBar!'))); &#125;, child: Icon(Icons.add), ), ), );&#125; 由修正的代码可知，我们传入 Scaffold.of 方法的 BuildContext 已经不再是 _MyHomePageState 的了，而是 Builder 的。而 Builder 的父 Widget 正是 Scaffold，所以正常运行。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「原创」LinkedHashMap 的相关问题]]></title>
    <url>%2F2020%2F02%2F29%2FLinkedHashMap%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[以下源码基于 JDK 10 LinkedHashMap 是什么LinkedHashMap = HashMap + LinkedList LinkedHashMap 主要作用实现按添加的顺序访问 迭代时按添加的顺序访问 实现按访问顺序排序（最近最少使用）（LRU） 页面置换算法 缓存机制 LinkedHashMap 实现原理继承关系图 put() 如何维护双链表LinkedHashMap 未重写 put() 方法，直接使用 HashMap 的 put() 方法，通过重写 newNode() 方法维护双链表的建立，通过重写 afterNodeAccess() 方法和 afterNodeInsertion() 方法维护 LRU。 afterNodeAccess() 和 afterNodeInsertion() 在 HashMap 中为空方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//HashMap 源码public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // LinkedHashMap 重写 newNode() tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // LinkedHashMap 重写 newNode() p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //维护 LRU afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); //维护 LRU afterNodeInsertion(evict); return null;&#125; LinkedHashMap 重写了 newNode() 方法，新建节点后调用 linkNodeLast() 方法连接链表。 1234//HashMap 源码Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125; 1234567891011121314151617181920//LinkedHashMap 源码Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e); //调用该方法维护双链表 linkNodeLast(p); return p;&#125;private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; //将新节点放入双链表尾 LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; remove() 如何维护双链表LinkedHashMap 没有重写 remove() 方法，通过重写 afterNodeRemoval() 方法维护双链表。 afterNodeRemoval() 在 HashMap 中为空方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//HashMap 源码public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; //维护双链表 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 123456789101112131415//LinkedHashMap 源码void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink //移除节点后断开双链表重新连接 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; get() 和 put() 如何维护 LRULinkedHashMap 通过重写 afterNodeAccess() 方法维护 LRU，该方法在 HashMap 的 put() 方法中被调用，在 LinkedHashMap 重写的 get() 方法中被调用。 12345678910111213141516171819202122232425262728293031323334353637//访问节点后将该节点移至链尾//put() 方法中若新值覆盖旧值则会调用该方法//get() 方法中调用该方法void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125;public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) //维护 LRU afterNodeAccess(e); return e.value;&#125; LinkedHashMap 重写了 afterNodeInsertion() 方法，该方法在 put() 中添加新节点后被调用，该方法会移除头节点，也就是最久未被访问的节点。 该方法中调用的 removeEldestEntry() 方法直接返回 false，所以该方法实际逻辑不执行。 可以通过重写 removeEldestEntry() 方法实现在某条件下移除最久未被访问节点。 123456789101112void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; //put() 中 evict 传入 true if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 如何开启按访问顺序排序（LRU）LinkedHashMap 有这样一个构造方法，第三个参数传入 true 即可，默认是 false。 123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; LinkedHashMap 对于 HashMap 的优化 LinkedHashMap 重写 containsValue() 方法。 LinkedHashIterator 重写 nextNode () 方法。 LinkedHashMap 直接遍历双链表，即直接遍历有效数据。 HashMap 先遍历桶，再遍历链表，双重循环，但是并不是所有桶都有数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」LayoutInflater 中 inflate 方法各参数作用（二）]]></title>
    <url>%2F2019%2F05%2F03%2FLayoutInflater%E4%B8%ADinflate%E6%96%B9%E6%B3%95%E5%90%84%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文 三个案例带你看懂LayoutInflater中inflate方法两个参数和三个参数的区别 View.inflate() 的前世今生 View.inflate 和 LayoutInflater.inflateView.inflate 实际上上只是简单的包装了 LayoutInflater.inflate 1234public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) &#123; LayoutInflater factory = LayoutInflater.from(context); return factory.inflate(resource, root);&#125; LayoutInflater.inflate 两个参数和三个参数的区别两个参数两个参数的方法实际上也只是简单调用了三个参数的方法 123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125; 当 ViewGroup 传入 null 时调用 1inflate(resource, null, false); 当 ViewGroup 传入非 null 时调用 1inflate(resource, root, true); 三个参数ViewGroup 传入 null View 没有父布局 View 没有 LayoutParams 返回该 View attachToRoot 参数无效 ViewGroup 传入非 nullattachToRoot 为 true View 添加到父布局 View 设置 LayoutParams 参数 返回父布局 attachToRoot 为 true View 没有父布局 View 设置 LayoutParams 参数 返回该 View ViewGroup 最好传入非 null 的情况如果在知道父布局的情况下，ViewGroup 最好传入父布局而不是 null，因为 View 的 LayoutParams 参数始终需要通过父布局来确定。 当调用 ViewGroup.addView 时，如果添加的 View 的 LayoutParams 为 null，会调用 generateDefaultLayoutParams 方法生成一个宽高都包裹的 LayoutParams，这可能并不是我们想要的效果，因为在 xml 中指定的宽高等属性将失效。 12345678910111213public void addView(View child, int index) &#123; if (child == null) &#123; throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup"); &#125; LayoutParams params = child.getLayoutParams(); if (params == null) &#123; params = generateDefaultLayoutParams(); if (params == null) &#123; throw new IllegalArgumentException("generateDefaultLayoutParams() cannot return null"); &#125; &#125; addView(child, index, params);&#125; attachToRoot 最好传入 true 的情况 自定义组件 attachToRoot 必须传入 false 的情况否则会抛出异常 1java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first. 不负责 View 的展示时，attachToRoot 必须传入 false RecyclerView#onCreateViewHolder 由 RecyclerView 控制展示 ViewHolder 的 View Fragment#onCreateView 由 FragmentManager 控制显示 Fragment View 已有父布局时，attachToRoot 必须传入 false]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Android 类加载]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%BD%AC-Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[转自：Android Classloader机制 JVM 类加载机制JVM 将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 类的生命周期 类从被加载到虚拟机内存中开始，到卸载出内存为止。 整个生命周期包括 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。 验证、准备、解析3个部分统称为连接（Linking）。 类加载器 对于任意一个类，需要由加载它的类加载器和这个类本身一同确立其在 JVM 中的唯一性。 每一个类加载器，都拥有一个独立的类名称空间。 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 JDK 8 及之前的双亲委派模型 Java 应用程序一般由 3 种类加载器互相配合进行加载。 如果有必要，可以自定义的类加载器。 这种层次关系称为类加载器的双亲委派模型（Parents Delegation Model）。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有父类加载器。 父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 双亲委派模型的工作过程 一个类加载器收到类加载的请求。 把这个请求委派给父类加载器去完成。 父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）。 子加载器尝试自己加载。 启动类加载器（Bootstrap ClassLoader） 加载以下类库到 JVM 内存 存放在 ＜JAVA_HOME＞\lib 目录中的 或者被 -Xbootclasspath 参数所指定的路径中的 并且是虚拟机识别的类库 无法被 Java 程序直接引用。 把加载请求委派给引导类加载器，直接使用 null 代替。 扩展类加载器（Extension ClassLoader） 由 sun.misc.Launcher $ExtClassLoader 实现。 加载以下类库到 JVM 内存 存放在＜JAVA_HOME＞\lib\ext目录中的 或者被 java.ext.dirs 系统变量所指定的路径中的所有类库 开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader） 也称为系统类加载器 由 sun.misc.Launcher $App-ClassLoader 实现。 加载以下类库到 JVM 内存 用户类路径（ClassPath）上所指定的类库 开发者可以直接使用这个类加载器。 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 JDK 9 双亲委派模型的更改 Java 9 引入了模块系统，并且略微更改了上述的类加载器。 扩展类加载器被改名为平台类加载器（platform class loader）。 Java SE中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。 Android 类加载机制 本质上 Android 和传统的 JVM 是一样的。 需要通过类加载器将目标类加载到内存 类加载器之间符合双亲委派模型 类有对应的生命周期 基于移动设备的特点，如内存以及电量等诸多方面跟一般的 PC 设备都有本质的区别，Google 开发了更符合移动设备的用于执行 Java 代码的虚拟机，即 Dalvik 和 ART。 Android 5.0 开始采用 ART 虚拟机替代 Dalvik。 ART 从 dex 字节码加载类。将多个 Class 文件合并成一个 classes.dex 文件。 在 8.0 之前 DexClassLoader：能够加载未安装的 apk PathClassLoader：只能加载系统中已经安装过的 apk 从 8.0 开始 PathClassLoader 也可以加载未安装的 apk PathClassLoader 可以完全替代 DexClassLoader]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」synchronized 的相关问题]]></title>
    <url>%2F2019%2F02%2F18%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%2F</url>
    <content type="text"><![CDATA[原文 Java 之 synchronized 详解 Java线程同步：synchronized锁住的是代码还是对象 Java并发之synchronized深度解析 锁机制的特性 互斥性 可见性 用法修饰代码块1synchronized(object) &#123;&#125; 1synchronized(类.class) &#123;&#125; 修饰方法 成员方法 1synchronized void method1() &#123;&#125; 等同于 123void method1() &#123; synchronized(this) &#123;&#125;&#125; 静态方法 1synchronized static void method2() &#123;&#125; 等同于 123static void method2() &#123; synchronized(该类.class) &#123;&#125;&#125; 锁的是对象还是代码？ synchronized 锁的是对象，线程只有拿到了锁对象才能执行 synchronized 那段代码，否则阻塞等待。 也就是说，如果锁对象是 this，那么同步机制仅对该对象有效。 线程拿到锁对象后，其他线程可以执行非 synchronized 代码。 同时访问 static synchronized 方法和 synchronized 方法可以并行。 前者锁对象是 Class 对象，后者锁对象是 this，锁对象不同，两个方法可以并行。 如果想锁全局怎么办 锁住该类对应的 Class 对象。 Class 类比较特殊，每个类都会有一个对应的 Class 对象且唯一，由 JVM 维护。 提供一个公用的锁对象。（例如声明为 static 的字段） synchronized 的性质可重入性 同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。 可避免死锁、提升封装性。 线程从 A 方法进入 B 方法时不需要释放锁后重新申请，可直接获得锁对象。 12345synchronized void methodA() &#123; methodB();&#125;synchronized void methodB() &#123;&#125; 同一个方法是可重入的。 可重入不要求是同一个方法。 可重入不要求是同一个类中的。 不可中断性 如果锁对象被其他线程获得，只能阻塞等待。 如果锁对象永远不被释放，只能永远等待。 其他注意事项 锁对象不能为 null。 synchronized 关键字不能被继承。 父类中的 synchronized 修饰方法，子类重写该方法时，默认情况不同步，必须显示的使用 synchronized 关键字。 抽象方法不能使用 synchronized 关键字。 构造方法不能使用 synchronized 关键字，但可以使用 synchronized(this) {}。 synchronized 有系统开销，尽量减小锁的粒度（作用域范围）。 避免死锁。 synchronized 实现原理（字节码） 详细实现原理 同步块使用 monitorenter 和 moniterexit 指令。 同步方法使用修饰符 ACC_SYNCHRONIZED 。 同步本质上都是通过监视器（monitor）提供支持。 所有对象都有一个自己的监视器（monitor）。 本地内存中共享变量副本发生变化后，解锁之前将本地内存中共享变量的值刷新到主存。 其他线程获取到锁后，去主内存中读取该共享变量的新值。 可重入性原理 锁对象监视器计数为 0 时，线程进入监视器，并设置计数器 为 1。（monitorenter） 线程重入监视器时，计数器 +1。（monitorenter） 线程退出监视器时，计数器 -1。（monitorexit） 如果监视器与其他线程关联，该线程阻塞等待，直到监视器计数器为 0。 synchronized 的缺陷 效率低：试图获得锁时不能设定超时，不能中断。 不灵活：加锁和解锁的时机和条件单一。 无法知道是否成功获取到锁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Android 在子线程中更新 UI]]></title>
    <url>%2F2019%2F02%2F17%2FAndroid%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9B%B4%E6%96%B0UI%2F</url>
    <content type="text"><![CDATA[原文 https://www.zhihu.com/question/24764972 https://ivanljt.github.io/blog/2017/08/16/Android%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97/ 源码版本 SDK 28 Android 中控件都是线程不安全的，Google 规范只能在主线程中更新 UI，在子线程中发送网络请求。假如在子线程中更新 UI，会抛出异常 12android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:7753) 但如果运行下面这段代码，你会发现程序完美运行，没有任何问题，为什么这时却又可以在子线程更新 UI 了呢？ 123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d("子线程更新UI", "onCreate"); Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName()); setContentView(R.layout.activity_main); textView = findViewById(R.id.text_view); new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName()); textView.setText(String.valueOf(System.currentTimeMillis())); &#125; &#125;).start();&#125; 如果我们将子线程 sleep 1 秒呢，这时便抛出了上述不能更新 UI 的异常。 1234567891011121314151617181920212223@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d("子线程更新UI", "onCreate"); Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName()); setContentView(R.layout.activity_main); textView = findViewById(R.id.text_view); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName()); textView.setText(String.valueOf(System.currentTimeMillis())); &#125; &#125;).start();&#125; 为什么在 onCreate 中在子线程可以更新 UITextView.setText 的调用过程是这样的 12345678TextView.setText -&gt; TextView.checkForRelayout-&gt; View.invalidate -&gt; View.invalidateInternal -&gt; ViewGroup.invalidateChild-&gt; ViewParent.invalidateChildInParent //这里会不断Loop去取上一个结点的mParent-&gt; ViewRootImpl.invalidateChildInParent //DecorView的mParent是ViewRootImpl-&gt; ViewRootImpl.checkThread //在这里执行checkThread，如果非UI线程则抛出异常 ViewRootImpl.checkThread检查线程的逻辑是检查当前线程是否为创建 ViewRootImpl 对象的线程，因为一般情况 ViewRootImpl 对象由系统在主线程中创建，即一般情况检查是否为主线程。 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 12public ViewRootImpl(Context context, Display display) &#123; mThread = Thread.currentThread(); View.invalidateInternalView.invalidateInternal 方法中有这样一段，它会判断 mAttachInfo 和 mParent 均不为空时才会调用 ViewGroup.invalidateChild ，onCreate 时 View 的 mAttachInfo 字段还未被赋值，此时为 null，所以此时更新 UI 未执行到 ViewRootImpl.checkThread 方法，未检查线程，所以更新 UI 成功。 123456789...final AttachInfo ai = mAttachInfo;final ViewParent p = mParent;if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage);&#125;... mAttachInfo 什么时候被赋值？当我们将子线程 sleep 一定时间后更新 UI 发现抛出异常，最简单的解释就是 View 的 mAttachInfo 字段已被赋值。 那 mAttachInfo 是何时被赋值的？ ViewRootImpl 对根节点 DecorView 执行 performTraversals 时，调用 dispatchAttachedToWindow 对所有 View 赋值 mAttachInfo。（类似 measure，layout，draw 的递归调用）。 而 ViewRootImpl 执行 performTraversals 是在 Activity.onResume 之后，所以当子线程试图更新 UI 时，如果在 performTraversals 之前更新 UI 是可以成功的，当 mAttachInfo 字段已被赋值后便会抛出异常。 我们可以通过打印日志验证 在子线程中更新 UI由上述可知子线程中可以更新 UI，如下面这段代码就可以完美运行 123456789101112131415161718192021222324252627282930private void runOnChildThread() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); final TextView textView = new MyTextView(MainActivity.this); Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName() + "创建TextView"); textView.setText("子线程" + System.currentTimeMillis()); textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("子线程更新UI", Thread.currentThread().getId() + Thread.currentThread().getName() + "点击TextView"); textView.setText("子线程" + System.currentTimeMillis()); &#125; &#125;); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(); //设置为透明，默认效果是黑色 layoutParams.format = PixelFormat.TRANSPARENT; layoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; layoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; //设置window透传，也就是当前view所在的window不阻碍底层的window获得触摸事件 layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; MainActivity.this.getWindowManager().addView(textView, layoutParams); Looper.loop(); &#125; &#125;).start();&#125; 我们可以打印日志验证，点击 TextView 时，UI 在子线程中更新。 当子线程满足以下条件时便可以在子线程中更新 UI 创建子线程的根视图 根视图添加到 WindowManager 创建子线程的 Looper 实际项目请在主线程中更新 UI！！！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「原创」HashSet 为什么要使用 Object 对象填充 value 而不是 null]]></title>
    <url>%2F2019%2F02%2F16%2FHashSet%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Object%E5%AF%B9%E8%B1%A1%E5%A1%AB%E5%85%85value%E8%80%8C%E4%B8%8D%E6%98%AFnull%2F</url>
    <content type="text"><![CDATA[我们知道 HashSet 内部使用 HashMap 实现，HashSet 的元素存储在 HashMap 的 key 中（唯一），value 使用了一个 Object 对象填充。为什么 HashSet 不使用 null 去填充 value 呢？ 以下所有原代码基于 JDK 1.10 1234private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); 从 remove 的角度123public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; HashSet 使用 HashMap 的 remove(Object) : Object 方法移除元素，如果使用 null 作为 value 填充，其返回值始终为 null，因为当存在该 key 并移除成功使返回原 value 为 null，当不存在该 key 时返回 null ，即无法判断是否移除成功。 HashMap 存在 remove(Object, Object) : boolean 方法，但该方法在 JDK 1.8 才出现。并且该方法相对于上一个方法更加耗时。 从 add 的角度123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet 使用 HashMap 的 put(Object, Object) : Object 方法添加元素，但该方法无法判断是否添加成功。 HashSet 的 add 方法添加元素时若该元素之前未被添加则返回 true，若该元素之前已被添加则返回 false。 HashMap 的 put 添加键值对时若该键值对的 key 未被添加则返回 null，若该键值对的 key 已被添加则返回原 value。 即当使用 null 作为 value 填充，其返回值始终为 null，无法判断是否添加成功。 可以使用 HashMap 的 containsKey(Object) : boolean 方法加以条件判断，但这样会更加耗时。并且若添加一个之前未被添加的元素需要遍历整个 HashMap。而添加元素是一个使用频繁的方法，尤其是添加新元素更为频繁，每次都加以判断并不是一个明智的选择。 从消耗内存的角度HashSet 使用的填充对象 PRESENT 用 static 修饰，所有 HashSet 的所有元素都使用该对象作为 value 填充，并不会消耗多大内存，可以忽略不计。 总结综上，HashSet 使用一个 Object 对象而不是 null 作为 value 填充 HashMap 在时间上效率会更优越，并且消耗的内存可以忽略不计。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」HashMap 的相关问题]]></title>
    <url>%2F2019%2F02%2F16%2FHashMap%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文 HashMap实现原理及源码分析 Java HashMap中在resize()时候的rehash,即再哈希法的理解 HashMap(3)进阶篇–HashMap扩容机制 HashMap工作原理和扩容机制 Java LinkedHashMap工作原理及实现 HashMap 扩容机制扩容时机基于 JDK 1.7 添加元素前容器元素的个数 >= 阈值（size &gt;= threshold）。 当前要添加元素所在数组（桶）的位置（index）不等于null。 也就是说发生了 hash 冲突。 以上两个条件都满足时触发 HashMap 扩容。 基于 JDK 1.10 添加元素后容器的元素个数 > 阈值（++size &gt; threshold） threshold 说明 threshold = 数组（桶）的长度。 当扩容到最大值时，threshold = int 最大值。 使用提供初始值的构造方法时，threshold = 初始值最接近的 2 的 n 次幂的值。 扩容大小 扩容大小为当前数组（桶）的 2 倍（HashMap 中数组的大小始终为 2 的 n 次幂）。 扩容时触发 rehash ，也就是重新计算每个元素的位置。 经过 rehash 后，元素在原位置或者在原位置移动 2 次幂的位置。 原代码以下原代码基于 JDK 1.7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * HashMap 添加节点 * * @param hash 当前key生成的hashcode * @param key 要添加到 HashMap 的key * @param value 要添加到 HashMap 的value * @param bucketIndex 桶，也就是这个要添加 HashMap 里的这个数据对应到数组的位置下标 */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //size：The number of key-value mappings contained in this map. //threshold：The next size value at which to resize (capacity * load factor) //数组扩容条件：1.已经存在的key-value mappings的个数大于等于阈值 // 2.底层数组的bucketIndex坐标处不等于null if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//扩容之后，数组长度变了 hash = (null != key) ? hash(key) : 0;//为什么要再次计算一下hash值呢？ bucketIndex = indexFor(hash, table.length);//扩容之后，数组长度变了，在数组的下标跟数组长度有关，得重算。 &#125; createEntry(hash, key, value, bucketIndex); &#125; /** * 这地方就是链表出现的地方，有2种情况 * 1，原来的桶bucketIndex处是没值的，那么就不会有链表出来啦 * 2，原来这地方有值，那么根据Entry的构造函数，把新传进来的key-value mapping放在数组上，原来的就挂在这个新来的next属性上了 */ void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K, V&gt; e = table[bucketIndex]; table[bucketIndex] = new HashMap.Entry&lt;&gt;(hash, key, value, e); size++; &#125;void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int) (newCapacity * loadFactor);//修改阈值&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K, V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K, V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; 以下原代码基于 JDK 1.10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &#123;@code key&#125;, or * &#123;@code null&#125; if there was no mapping for &#123;@code key&#125;. * (A &#123;@code null&#125; return can also indicate that the map * previously associated &#123;@code null&#125; with &#123;@code key&#125;.) */public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap 插入链表时是头插还是尾插其实这个问题很简单，只需要观察 HashMap 的 Node 节点类的字段。 Node 类仅保存了它的下一个节点，也就是说这个链表是单向的，并且只保存了头节点，所以肯定是头插法性能较高。 2020-04-29 更正 尾插，会遍历链表比较 Key 是否相同，相同直接修改 Value，遍历到尾说明没有 Key，直接尾插。 LinkedHashMap 是怎样实现有序的我们知道 HashMap 中保存的元素是无序的，并且 HashMap 不保证其元素的位置不变，而 Map 接口的另一个实现类 LinkedHashMap 则可以保证其遍历时以添加的顺序返回，那它是怎样实现的？ 注意 LinkedHashMap 不可以随机访问，其内部元素仍无序，只是通过迭代器遍历时返回顺序与添加顺序相同。 以下代码基于 JDK 1.10 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 123456789101112131415static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; //其余方法省略&#125; LinkedHashMap 直接继承于 HashMap，其源代码非常短，仅对 HashMap 做了少量更改。LinkedHashMap 中的节点 Node 也直接继承于 HashMap 中的节点 Node。 从节点代码中我们可以了解到 LinkHashMap 中节点添加了前驱、后继两个新字段，其他不变。 正如官方文档所说 LinkedHashMap 是哈希表和双向链表的实现。 图片来自 HashMap 与 HashTable 的区别继承不同HashMap 与 HashTable 都实现了 Map 接口，但是 HashMap 直接继承于 AbstractMap 类，HashTable 直接继承于 Dictionary 类。 迭代器不同HashMap 与 HashTable 的迭代器都实现了 Iterator 接口，但是 HashTable 的迭代器还实现了 Enumeration 接口。 线程安全不同HashMap 是线程不安全的，而 HashTable 是线程安全的。 在单线程情况下，HashMap 效率高于 HashTable。 哈希算法不同HashMap 中元素的 hash 值使用 key 的 hashcode 值经过一定的算法计算得到。以减少哈希冲突。 HashTable 中元素的 hash 值直接使用 key 的 hashcode 值。 允不允许 null 值不同HashMap 可以使用 null 作为键和值。HashTable 均不允许。 扩容大小不同HashMap 扩容为原数组（桶）的 2 倍，HashTable 扩容为原数组（桶）的 2 倍 + 1。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「原创」Java 内部类中 private 的探讨]]></title>
    <url>%2F2019%2F02%2F15%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%ADprivate%E7%9A%84%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[Java 内部类一直是一个很特殊的类，它与外部类和该外部类的其他内部类总有着千丝万缕的联系，本文讨论的是内部类中的 private 修饰符。 以下测试基于下面的代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class Outer &#123; private int outer; public Outer(int outer) &#123; this.outer = outer; &#125; public void accessInnerPrivateMethod(Inner inner) &#123; inner.privateMethod(1, 1.1, 'a'); &#125; public void print(Inner inner) &#123; System.out.println(inner.inner); &#125; private void privateMethod(String str) &#123; &#125; class Inner &#123; private int inner; public Inner(int inner) &#123; this.inner = inner; &#125; public void accessOuterPrivateMethod(Outer outer) &#123; outer.privateMethod(null); &#125; public void print(Outer outer) &#123; System.out.println(outer.outer); &#125; private void privateMethod(int a, double b, char c) &#123; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.lang.reflect.*;public class Test &#123; private static String parseExecutable(Executable executable) &#123; StringBuilder sb = new StringBuilder(); sb.append(Modifier.toString(executable.getModifiers())).append(" "); sb.append(executable.getName()).append("("); for (Parameter parameter : executable.getParameters()) &#123; sb.append(parameter.getType().getSimpleName()).append(" ").append(parameter.getName()).append(", "); &#125; sb.delete(sb.length() - 2, sb.length()); sb.append("): "); sb.append(executable.getAnnotatedReturnType().getType().getTypeName()); return sb.toString(); &#125; private static void printExecutables(Executable[] executables) &#123; for (Executable executable : executables) &#123; System.out.println(parseExecutable(executable)); &#125; &#125; private static String parseField(Field field) &#123; StringBuilder sb = new StringBuilder(); sb.append(Modifier.toString(field.getModifiers())).append(" "); sb.append(field.getType().getSimpleName()).append(" "); sb.append(field.getName()); return sb.toString(); &#125; private static void printFields(Field[] fields) &#123; for (Field field : fields) &#123; System.out.println(parseField(field)); &#125; &#125; public static void main(String[] args) &#123; Class&lt;Outer&gt; outerClass = Outer.class; Class&lt;Outer.Inner&gt; innerClass = Outer.Inner.class; Outer outer = new Outer(0); Outer.Inner inner = outer.new Inner(0); System.out.println("外部类的方法"); printExecutables(outerClass.getDeclaredMethods()); System.out.println(); System.out.println("内部类的构造方法"); printExecutables(innerClass.getDeclaredConstructors()); System.out.println(); System.out.println("内部类的方法"); printExecutables(innerClass.getDeclaredMethods()); System.out.println(); System.out.println("内部类的字段"); printFields(innerClass.getDeclaredFields()); System.out.println(); &#125;&#125; 运行结果 1234567891011121314151617181920外部类的方法static access$200(Outer arg0, String arg1): voidstatic access$300(Outer arg0): intpublic print(Inner arg0): voidpublic accessInnerPrivateMethod(Inner arg0): voidprivate privateMethod(String arg0): void内部类的构造方法public Outer$Inner(Outer arg0, int arg1): Outer$Inner内部类的方法static access$100(Inner arg0): intstatic access$000(Inner arg0, int arg1, double arg2, char arg3): voidpublic print(Outer arg0): voidpublic accessOuterPrivateMethod(Outer arg0): voidprivate priviteMethod(int arg0, double arg1, char arg2): void内部类的字段private int innerfinal Outer this$0 内部类为什么可以直接访问外部类的字段和方法 内部类对象的创建依赖外部类对象。 12Outer outer = new Outer(0);Outer.Inner inner = outer.new Inner(0); 从反射的结果可以看出生成的内部类 构造方法添加了一个外部类的参数。 添加了一个外部类的字段。 实际上内部类的对象“隐式“引用了外部类对象，所以可以直接访问外部类的字段和方法。 private 在外部类与内部类中的访问限制 外部类可以访问内部类的 private 字段和方法。 内部类可以访问外部类的 private 字段和方法。 从反射的结果可以看出外部类与内部类均添加了 2 个 static 的 access 方法，如果你会反编译的话，通过反编译的结果可以看出实际上这些 access 方法会返回相应 private 字段的值或者调用相应 private 方法，内部类与外部类之间访问 private 字段和方法实际上通过调用这些 static 方法间接访问。 内部类与内部类 同一个外部类的内部类之间可以访问 private 字段和方法。 原理同上。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」View 绘制流程]]></title>
    <url>%2F2019%2F02%2F14%2FView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[原文：Android视图绘制流程完全解析，带你一步步深入了解View(二) 每个 View 的绘制都会经过 measure（测量）、layout（布局）、draw（绘图）3 个流程。 系统的绘制流程从 ViewRootImpl.performTraversals 开始。 测量 测量从 ViewRootImpl.performTraversals 开始。 measure 方法接收两个参数，widthMeasureSpec 和 heightMeasureSpec。 measure 方法用 final 修饰，不允许子类重写。 measure 可能被多次调用。 真正测量 View 大小的是 onMeasure 方法，会在 measure 方法中调用。 若要改变默认的测量流程需要重写 onMeasure 方法。 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; onMeasure 默认通过调用 getDefaultSize 方法获取大小，然后调用 setMeasuredDimension 设定测量的大小。 调用 setMeasuredDimension 方法后可以通过 getMeasuredWidth 和 getMeasuredHeight 获取 View 测量出的宽高。 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; measureSpec 通过 measure 方法传入。 ViewGroup 可能包含子 View，每个 View 都要调用 measure。 ViewGroup 定义了 measureChildren 和 measureChild 方法，依次调用子 View 的 measure 方法触发测量。 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; ViewGroup 通过调用 getChildMeasureSpec 方法计算子 View 的 MeasureSpec。 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; MeasureSpec 值由 specSize 和 specMode 共同组成。 specSize 记录大小，specMode 记录规格。 通过 MeasureSpec.makeMeasureSpec 方法组装 MeasureSpec。 通过 MeasureSpec.getMode 方法和 MeasureSpec.getSize 方法拆分。 specMode 的三种类型 EXACTLY表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 AT_MOST表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 UNSPECIFIED表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。 父 View 经过计算得出 widthMeasureSpec 和 heightMeasureSpec 后传给子 View。 根 View 通过 ViewRootImpl.getRootMeasureSpec 方法获得 widthMeasureSpec 和 heightMeasureSpec。 123//截取自 ViewRootImpl.performTraversals 方法int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; rootDimension 参数等于 MATCH_PARENT 时，MeasureSpec 的 specMode 等于 EXACTLY。 rootDimension 参数等于 WRAP_CONTENT 时，MeasureSpec 的 specMode 等于 AT_MOST。 rootDimension 参数等于 MATCH_PARENT 或 WRAP_CONTENT 时，specSize 都等于 windowSize，也就是根视图总是会充满全屏。 布局 ViewRoot.performTraversals 方法在测量结束开始布局。 layout 方法接收 4 个参数，表示左、上、右、下 4 个位置的坐标。 layout 方法会判断 View 大小是否发生变化，确定是否需要重绘。 layout 可能被多次调用。 12boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); 真正实现布局的是 onLayout 方法。 View.onLayout 是空方法，ViewGroup.onLayout 是抽象方法。 onLayout 方法结束后可以通过 getWidth 和 getHeight 方法获取 View 的宽高。 getWidth / getHeight 与 getMeasureWidth / getMeasureHeight getMeasureWidth / getMeasureHeight 的值通过 setMeasuredDimension 方法设置。 getWidth / getHeight 的值通过坐标相减计算得出。 绘图 ViewRoot.performTraversals 方法在布局结束开始绘图。 draw 方法接收一个 Canvas 对象的参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) &#123; debugDrawFocus(canvas); &#125; // we're done... return; &#125; /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ //完整流程省略 绘制流程共有 6 个步骤，其中第 2 步和第 5 步可跳过。 绘制背景。 如有必要，保存图层以准备褪色。 绘制 View 的内容。 绘制子 View。 如有必要，绘制淡化边缘和恢复图层。 绘制装饰。（如滚动条） 绘制内容在 onDraw 方法，对应第 3 步。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」36 SubstrateVM：AOT 编译框架]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-36SubstrateVM%EF%BC%9AAOT%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/41582 AOT（Ahead-Of-Time）编译 程序运行之前，将字节码转换为机器码的过程。 编译后可以需要链接至托管环境中的动态共享库，也可以是独立运行的可执行文件。 狭义的 AOT 编译针对的目标代码是可以被即时编译的代码。 可以简单地理解为类似 GCC 的静态编译器。 优点 无须在运行时耗费 CPU 资源进行即时编译。 程序能在启动时就达到理想的性能。 缺点 无法得知程序运行时的信息。 无法进行基于类层次分析的完全虚方法内联。（不懂） 无法进行基于程序 profile 的投机性优化。（不懂） 影响程序的峰值性能。 jaotc Java 9 引入的实验性 AOT 编译工具。 借助 Graal 编译器，将类文件转换为机器码，存放在生成的动态共享库中。 在方法调用时切入，能够去优化至解释执行。 由于 JVM 可能通过 Java agent 或者 C agent 改动加载的字节码，或者这份 AOT 编译生成的机器码针对的是旧版本的 Java 类，因此它需要额外的验证机制，来保证即将链接的机器码的语义与对应的 Java 类的语义是一致的。 类指纹（class fingerprinting） 在动态共享库中保存被编译的 Java 类的摘要信息。 JVM 比较摘要信息和已加载的 Java 类。 不匹配则舍弃。 应用 编译 java.base module（Java 核心类库中最为基础的类）。 这些类可能被应用程序调用，但频率未必高到能触发即时编译。 将它们提前编译为机器码，避免在执行即时编译生成的机器码时，因为调用到这些基础类，而需要切换至解释执行的性能惩罚。 SubstrateVM 的设计与实现 设计初衷是提供一个高启动性能、低内存开销，并且能够无缝衔接 C 代码的 Java 运行时。 SubstrateVM 的限制 文档 脱离 HotSpot 虚拟机，拥有独立运行时（包含异常处理，同步，线程管理，内存管理（垃圾回收）和 JNI 等组件）。 要求目标程序是封闭的，不能动态加载其他类库等。 探索整个编译空间，通过静态分析推算所有虚方法调用的目标方法。 将所有可能执行到的方法都纳入编译范围，避免实现解释执行器。 主要用于 JVM 语言的 AOT 编译。 Truffle 语言实现可以在 SubstrateVM 上运行，但不会 AOT 编译。 native image generator 是一个 Java 程序。 包含 AOT 编译逻辑。 采用指针分析（points-to analysis），从程序入口出发，探索所有可达代码。 执行初始化代码。 最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。 SubstrateVM 运行时 精简运行时，经过 AOT 编译的目标程序将跑在该运行时之上。 直接从目标程序开始运行，无须进行 JVM 初始化。 SubstrateVM 的启动时间与内存开销 启动时间和内存开销非常少。 适合嵌入其他系统中。 Metropolis 项目 实现“Java-on-Java”的目标。 Oracle 的架构师 John Rose 提出的使用 Java 开发 Java 虚拟机的好处： 能够完全控制编译 Java 虚拟机时所使用的优化技术。 能够与 C++ 语言的更新解耦合。 能够减轻开发人员以及维护人员的负担。 能够以更为敏捷的方式实现 Java 的新功能。 JikesRVM 项目和Maxine VM 项目已用 Java 完整地实现了一套 Java 虚拟机（后者的即时编译器 C1X 是 Graal 编译器的前身）。 Java-on-Java 技术通常会干扰应用程序的垃圾回收、即时编译优化。 严重影响 JVM 的启动性能。 深入拆解Java虚拟机完结]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>看不懂</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」35 Truffle：语言实现框架]]></title>
    <url>%2F2018%2F12%2F16%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-35Truffle%EF%BC%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/41347 语言实现编译型语言 实现一门新编程语言的传统做法是实现一个编译器。 编译器分为前端和后端： 前端：负责词法分析、语法分析、类型检查和中间代码生成。 后端：负责编译优化和目标代码生成。 另一种做法是将新语言编译成某种已知语言，或者已知的中间形式（如 Java 字节码）。 可以直接享用 JVM 自带的各项优化（即时编译、自动内存管理等等）。 解释型语言 无须编译步骤，依赖于解释执行器进行解析并执行。 通常将其包装在虚拟机里（实现如即时编译、垃圾回收等其他组件）。 理想情况下，希望不同的语言实现中复用这些组件，只要实现解释执行器。 Truffle 项目简介 用 Java 写的语言实现框架。 基于 Truffle 的语言可以享用由 Truffle 提供的各项运行时优化。需实现： 用 Java 实现词法分析 语法分析 针对语法分析所生成的抽象语法树（Abstract Syntax Tree，AST）的解释执行器 可以运行在任何 JVM 上。 如果 Truffle 运行在附带了 Graal 编译器的 Java 虚拟机之上，它将调用 Graal 编译器所提供的 API，主动触发对 Truffle 语言的即时编译，将对 AST 的解释执行转换为执行即时编译后的机器码。 对于解释型语言，经由 Graal 编译器加速的 Truffle 语言解释器的性能十分优越。 对于拥有专业即时编译器语言，仍处于追赶者的位置。 Partial Evaluation 将 P: I -&gt; O 转化为 P’: ID -&gt; O P’ 是 P 的特化（Specialization）。 符号 含义 对应关系 P 程序 Truffle 语言的解释执行器 P’ 等价的另一段程序 通过 Partial Evaluation 特化为P’ I 输入 IS 已知常量 Truffle 语言写的程序 ID 未知变量 O 输出 可以利用 Graal 编译器将 P’ 编译为二进制码。 节点重写（node rewriting） 动态语言中，需要在运行时动态确定操作数的具体类型。 在运行时选择语义的节点，不利于即时编译，严重影响到程序的性能。 Truffle 语言解释器会收集每个 AST 节点所代表的操作的类型，在即时编译时作出 profile 的特化（specialization）。 在即时编译过后，如果运行过程中发现实际类型和假设类型不同，会去优化返回至解释执行状态，并且重新收集 AST 节点的类型信息。 Polyglot 允许在同一段代码中混用不同的编程语言。 Truffle 语言之间能够共用对象（与其他 Polyglot 框架的区别）。 Truffle 的 Polyglot 在切换语言时，性能开销非常小，甚至零开销。 通过 Polyglot API 来实现。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」34 Graal：用 Java 编译 Java]]></title>
    <url>%2F2018%2F12%2F15%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-34Graal%EF%BC%9A%E7%94%A8Java%E7%BC%96%E8%AF%91Java%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/41245 GraalVM GraalVM 是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK 上运行，也可以通过 AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。 除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。 Graal 编译器 用 Java 写就的即时编译器，它从 Java 9u 开始便被集成自 JDK 中，作为实验性质的即时编译器。 启用时将替换掉 HotSpot 中的 C2 编译器。 响应原本 C2 负责的编译请求。 Graal 和 Java 虚拟机的交互即时编译器与 JVM 的交互可以分为三个方面： 响应编译请求。 获取编译所需的元数据（如类、方法、字段）和反映程序执行状态的 profile。 将生成的二进制码部署至代码缓存（code cache）里。 传统情况，即时编译器是与 JVM 紧耦合。 更改即时编译器需要重新编译整个 JVM。 引入 JVM 编译器接口（JVM Compiler Interface，JVMCI）解耦合 JVM 和 Graal。 Java 程序可以直接调用 Graal，编译并部署指定方法（因为 JVMCI）。 Graal 的单元测试和 Truffle 语言实现框架基于上述技术。 Graal 和 C2 的区别 Graal 由 Java 编写，C2 由 C++ 编写。 Graal 更加模块化，更容易开发与维护。 Graal 中被证实有效的部分逃逸分析（partial escape analysis）未被移植到 C2 中。 Graal 的内联算法对新语法、新语言更加友好。 Graal 的实现 编译过程分为前端和后端。 前端实现平台无关的优化（如方法内联），和小部分平台相关的优化。 后端实现大部分平台相关优化（如寄存器分配），和生成机器码。 前端的 IR 称为 High-level IR（HIR）（如Sea-of-Nodes IR），后端的 IR 称为 Low-level IR（LIR）。 前端由一个个单独的优化阶段（optimization phase）构成。 前端编译阶段除了少数几个关键的之外，其余均可以通过配置选项开启或关闭。 Graal 比 C2 更加激进，设计上十分青睐基于假设的优化手段。 Graal 支持自定义假设，和直接与去优化节点相关联。 Graal 实现高性能的 intrinsic 方法相对简单。 问题Q：GraalVM 和 JVM 是什么关系？ A：可以将 GraalVM 看成泛指带 Graal 编译器的虚拟机。 Q：可不可以把 profile 和编译的机器码保存到磁盘，在代码和运行平台不变的情况下，下次启动（或部署多实例）的时候直接装载这部分数据？这算作是一种系统预热的可行性方案吗？ A：已经有这种做法，但同时需要承担 profile 不能反映当前执行状态的风险。 Q：Graal 自身的及时编译是调用 Graal 自身吗？如果这么做会不会出现无穷递归？ A：默认情况下，由 C1 编译Graal。调用 Graal 编译 Graal 并不会造成无穷递归。因为 JVM 里有解释执行器，能够执行 Graal 代码。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」30 31 Java 虚拟机的监控及诊断工具]]></title>
    <url>%2F2018%2F12%2F13%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-3031Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/40821 随便看看了解下就好。 命令行jps 打印所有正在运行的 Java 进程的相关信息。帮助文档 参数 作用 默认 打印 Java 进程 ID 和主类名 -l 打印模块名和包名 -v 打印传递给 JVM 的参数 -m 打印传递给主类的参数 如果某 Java 进程关闭了默认开启的 UsePerfData 参数 jps 命令和 jstat 命令无法探知该 Java 进程。 jstat 打印目标 Java 进程的性能数据。包括多条子命令。帮助文档 12345678910111213$ jstat -options-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation 子命令 作用 -class 打印类加载相关数据 -compiler 打印即时编译相关数据 -printcompilation 同上 -gc 前缀 打印垃圾回收相关数据 -t 参数，打印进程的启动时间。 默认情况 jstat 只打印一次性能数据。 可以配置为每隔一段时间打印一次（直至进程终止或达到最大次数）。 jmap 分析 JVM 堆中的对象。包括多条子命令。帮助文档 子命令 作用 -clstats 打印被加载类的信息 -finalizerinfo 打印所有待 finalize 的对象 -histo 统计各个类的实例数目以及占用内存 -histo:live 只统计堆中的存活对象 -dump 导出堆的快照 -dump:live 只保存堆中的存活对象 jinfo 查看进程的参数。帮助文档 可以修改进程的 “manageable” 虚拟机参数。 jstack 打印进程中各个线程的栈轨迹和线程所持有的锁。帮助文档 死锁检测。 jcmd 替代除了 jstat 之外的所有命令。帮助文档 GUIeclipse MAT 解析二进制快照工具。 获取二级制快照的方式 使用 Attach API 新建一个 JVM 运行 Attach API 使用 jmap 进程启用 DisableAttachMechanism 参数时 不显示 不显示 运行时报错 计算对象占据内存的两种方式 Shallow heap：对象自身所占据的内存。 Retained heap：对象不再被引用时，垃圾回收器所能回收的总内存，包括对象自身所占据的内存，和仅能够通过该对象引用到的其他对象所占据的内存。 直方图（histogram）：展示各个类的实例数目和实例的堆总和。 支配树（dominator tree）：按照每个对象 Retained heap 的大小排列支配树。 自动匹配内存泄漏常见模式，汇报潜在内存泄漏问题。帮助文档 博客 Java Mission Control JVM 上的性能监控工具。包含一个 GUI 客户端，众多用来收集 JVM 性能数据的插件，虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。 JFR 的性能开销很小，默认配置下平均低于 1%。 JFR 能够直接访问虚拟机内的数据，不会影响虚拟机的优化。 适用于生产环境下满负荷运行的 Java 程序。 JFR 记录运行过程中发生的一系列事件（包括 Java 和 JVM）。 事件类型 说明 瞬时事件（Instant Event） 关心发生与否，如异常、线程启动 持续事件（Duration Event） 关心持续时间，如垃圾回收 计时事件（Timed Event） 时长超出指定阈值的持续事件 取样事件（Sample Event） 周期性取样的事件，如方法抽样 JFR 的取样事件比其他工具更加精确。 JFR 的 3 种启用方式 命令行中使用 -XX:StartFlightRecording= 参数。 使用 jcmd 的 JFR.* 子命令。 使用 JMC 的 JFR 插件。 VisualVM https://visualvm.github.io/index.html JITWatch https://github.com/AdoptOpenJDK/jitwatch]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」33 JavaAgent 与字节码注入]]></title>
    <url>%2F2018%2F12%2F08%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-33JavaAgent%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/41186 premain 方法 在 main 方法前执行的方法。 JVM 能识别的 premain 方法参数类型是 String 以 Java agent 方式运行 premain 方法 方法一：打包成 jar 包，在的 MANIFEST.MF 配置文件中，指定的 Premain-class。 方法二：通过 Attach API 远程加载。 不会先于 main 方法执行。 取决于调用 Attach API 的时机。 运行不再是 premain 方法，而是 agentmain 方法。 更新 jar 包的 manifest 文件，包含 Agent-Class 配置。 JVM 不限制 Java agent 的数量。 字节码注入123456789101112131415161718192021package org.example;import java.lang.instrument.*;import java.security.ProtectionDomain;public class MyAgent &#123; public static void premain(String args, Instrumentation instrumentation) &#123; instrumentation.addTransformer(new MyTransformer()); &#125; static class MyTransformer implements ClassFileTransformer &#123; public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; //打印该数组的前四个字节，也就是 Java class 文件的魔数（magic number）0xCAFEBABE。 System.out.printf("Loaded %s: 0x%X%X%X%X\n", className, classfileBuffer[0], classfileBuffer[1], classfileBuffer[2], classfileBuffer[3]); //如果返回 null 或抛出异常，JVM 使用原来的 byte 数组完成类加载工作。 return null; &#125; &#125;&#125; Instrumentation 接口：注册类加载时间拦截器。 ClassFileTransformer 接口：拦截器需要实现，重写 transform 方法。 transform 方法： byte[] 参数：正在被加载的类的字节码。 byte[] 返回值：更新过后的类的字节码。 redefine 和 retransform（不懂，怎么实现？） 要求传入所需类实例。 redefine 舍弃原本的字节码，并替换成由用户提供的 byte 数组。 比较危险，一般用于修复出错了的字节码。 retransform 针对所传入的类，重新调用所有已注册的 ClassFileTransformer 的 transform 方法。 使用 retransform 注入已加载但未注入的类。 在执行 premain 或者 agentmain 方法前，JVM 早已加载了不少类，这些类的加载事件并没有被拦截。 定义了多个 Java agent，多个注入的情况下，移除部分注入。 JVMTI agent（不懂） JVMTI 是一个事件驱动的工具实现接口。 Java agent 通过 JVMTI agent（C agent）实现。 在 C agent 加载后的入口方法 Agent_OnLoad 注册各个事件的钩子（hook）方法。 JVM 触发这些事件时，调用对应的钩子方法。 为 JVMTI 中的 ClassFileLoadHook 事件设置钩子，在 C 层面拦截所有的类加载事件。 关于 JVMTI 的其他事件 基于字节码注入的 profiler 实现代码覆盖工具，或者各式各样的 profiler。 在某一程序行为的周围，注入某运行时类方法的调用，表示该程序行为正要发生或已经发生。 需排除对 JDK 类和运行时类的注入（可能造成死循环调用）。 设置一个线程私有标识位，区分应用代码上下文和注入代码上下文。（不懂） 借助自定义类加载器来隔离命名空间。 观察者效应（observer effect）对所收集的数据造成的影响。 使用字节码注入开发 profiler 时，需要辩证地看待所收集的数据。 仅表示在被注入的情况下程序的执行状态，不是没有注入情况下的程序执行状态。 面向方面（切面）编程（AOP） 字节码注入实现。 问题Q：如何注入方法出口。除了正常执行路径之外，还需考虑异常执行路径。 A：不用管有没有 catch 块，有没有 throw，直接给所有代码罩一个 catch any 的异常处理就行了。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>看不懂</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」27 注解处理器]]></title>
    <url>%2F2018%2F12%2F06%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-27%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/40189 注解处理器（annotation processor） 可以为 Java 编译器添加编译规则。 可以修改已有的 Java 源文件。 可以生成新的 Java 源文件。 注解处理器的原理Java 编译器的工作流程 将源文件解析为抽象语法树。 调用已注册的注解处理器。 生成字节码。 2 调用注解处理器生成了新的源文件将重复 1、2。 实现注解处理器Processor 接口1234567891011121314151617181920212223public interface Processor &#123; //不用构造器 //注解处理器的实例通过反射生成 //注解处理器类需要定义一个无参数构造器 //注解处理器通常不声明任何构造器 //存放注解处理器的初始化代码 void init(ProcessingEnvironment processingEnv); //返回注解处理器所支持的注解类型 //注解类型用字符串形式表示 Set&lt;String&gt; getSupportedAnnotationTypes(); //返回该处理器支持的 Java 版本 //通常版本与 Java 编译器版本一致 SourceVersion getSupportedSourceVersion(); //注解处理方法 boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv); //剩余方法略...&#125; JDK 提供了一个实现 Processor 接口的抽象类 AbstractProcessor。 该抽象类实现了 init、getSupportedAnnotationTypes 和 getSupportedSourceVersion方法。它的子类可以通过 @SupportedAnnotationTypes 和 @SupportedSourceVersion 注解来声明所支持的注解类型以及 Java 版本。 所有的注解处理器类需要实现 Processor 接口。 注册 Java 编译器的插件 方法一：直接使用 javac 命令的 -processor 参数。 方法二：将注解处理器编译生成的 class 文件压缩入 jar 包中，在 jar 包配置文件中记录该注解处理器的包名及类名。 启动 Java 编译器时，会寻找 classpath 路径上的 jar 包是否包含上述配置文件，并自动注册其中记录的注解处理器。 方法三：在 IDE 中配置注解处理器。 利用注解处理器修改已有的源码 注解处理器并不能真正地修改已有源代码。这里指的是修改由 Java 源代码生成的抽象语法树，在其中修改已有树节点或者插入新的树节点，从而使生成的字节码发生变化。 修改抽象语法树涉及 Java 编译器的内部 API，可能随着版本变更失效。 利用注解处理器生成新的源码 通过 Filer.createSourceFile 方法获得一个文件的概念。 并通过 PrintWriter 将具体的内容写入。 附件 Element 类 API 3 修改抽象语法树 API Lombok 的回应]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」32 JNI 的运行机制]]></title>
    <url>%2F2018%2F12%2F05%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-32JNI%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/40839 Java 无法表达的场景 使用汇编语言提升关键代码的性能。 调用 Java 核心类库无法提供的，某个体系架构或者操作系统特有的功能。 牺牲可移植性，在 Java 代码中调用 C/C++ 代码实现。 这种跨语言调用，需要借助 Java Native Interface 机制。 native 方法的链接 动态链接库的名字以 lib 为前缀，以 .dylib 或 .so 为扩展名。 通过 System.loadLibrary(&quot;---&quot;) 方法加载 lib—.dylib。 如果库不在当前路径下，可以配置 java.library.path 参数指向路径（JVM 启动时）。 JVM 自动查找符合默认命名规范的 C 函数并链接 javac -h 命令可以根据 native 方法声明，自动生成包含符合命名规范的 C 函数的头文件。 命名规范 函数都要以Java_为前缀，后跟完整的包名和方法名。 路径中 / 转换为 _ 原方法名中 _ 转换为 _1 有重载 native 方法时，自动链接对象时的考虑参数类型。 重载方法函数名在原本基础上追加 __ 以及方法描述符作为后缀。 方法描述符的特殊符号会被替换。 引用类型中 ; 替换为 _2 数组类型中 [ 替换为 _3 在 C 代码中主动链接 对 C 函数名没有要求。 通常使用一个名为 registerNatives 的 native 方法，按照第一种链接方式定义所能自动链接的 C 函数。在该函数中，手动链接该类的其他 native 方法。 需要在其他 native 方法被调用之前完成链接。 通常在类的初始化方法里调用该 registerNatives 方法。 JNI 的 API C 代码中可以使用 Java 的语言特性（如 instanceof，通过特殊的 JNI 函数实现）。 JNIEnv JVM 会将所有 JNI 函数的函数指针聚合到一个名为 JNIEnv 的数据结构中。 JNIEnv 线程私有，每个线程都拥有一个 JNIEnv。 规定 C 代码不能共享 JNIEnv 给其他线程，否则 JNI 函数无法保证正确性。 原因： 给 JNI 函数提供一个单独命名空间。 允许 JVM 通过更改函数指针替换 JNI 函数的具体实现。 Java 类型与本地类型 JNI 会将 Java 层面的基本类型以及引用类型映射为另一套可供 C 代码使用的数据结构。 基本类型对应关系： Java 类型 c 数据结构 位（bit） boolean jboolean 8, unsigned byte jbyte 8 char jchar 16, unsigned short jshort 16 int jint 32 long jlong 64 float jfloat 32 double jdouble 64 void void n/a 引用类型对应数据结构的继承关系： 1234567891011121314jobject|- jclass (java.lang.Class objects)|- jstring (java.lang.String objects)|- jthrowable (java.lang.Throwable objects)|- jarray (arrays) |- jobjectArray (object arrays) |- jbooleanArray (boolean arrays) |- jbyteArray (byte arrays) |- jcharArray (char arrays) |- jshortArray (short arrays) |- jintArray (int arrays) |- jlongArray (long arrays) |- jfloatArray (float arrays) |- jdoubleArray (double arrays) JNI 访问字段类似反射 API。 异常 调用 JNI 函数时，JVM 便已生成异常实例，并缓存在内存中。 不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。 从可能触发异常的 JNI 函数返回时，需要通过 JNI 函数 ExceptionOccurred 检查是否发生了异常，并且作出相应的处理。 如果无须抛出该异常，需要通过 JNI 函数 ExceptionClear 显式地清空已缓存的异常。 局部引用（Local Reference）与全局引用（Global Reference） C 代码中可以访问所传入的引用类型参数。 可以通过 JNI 函数创建新的 Java 对象。 JVM 需要一种机制告知垃圾回收算法不要回收 C 代码中可能引用到的 Java 对象。 垃圾回收算法会将被局部引用和全局引用指向的对象标记为不可回收。 无论是传入的引用类型参数，还是通过 JNI 函数（除 NewGlobalRef 及 NewWeakGlobalRef 之外）返回的引用类型对象，都属于局部引用。 从 C 函数中返回至 Java 方法中，局部引用将失效。 不能缓存局部引用，以供另一 C 线程或下一次 native 方法调用时使用。 通过 JNI 函数 NewGlobalRef，将该局部引用转换为全局引用。 通过 JNI 函数 DeleteGlobalRef 消除全局引用。 C 函数运行时间极其长时，应该考虑通过 JNI 函数DeleteLocalRef，消除不再使用的局部引用。 句柄（handle） 句柄指的是内存中 Java 对象的指针的指针。 垃圾回收器可能会移动对象在内存中的位置，JVM 需要另一种机制保证局部引用或者全局引用将正确地指向移动过后的对象。HotSpot 虚拟机是通过句柄（handle）来完成。 局部引用和全局引用都是句柄。 局部引用句柄的两种存储方式 在本地方法栈帧中：主要用于存放 C 函数所接收的来自 Java 层面的引用类型参数。 在线程私有的句柄块：主要用于存放 C 函数中创建的局部引用。 从 C 函数返回至 Java 方法时，本地方法栈帧中的句柄将会被自动清除。 线程私有句柄块需要 JVM 显式清理。 JNI 调用的额外性能开销 进入 C 函数时对引用类型参数的句柄化。 调整参数位置（C 调用和 Java 调用传参的方式不一样）。 从 C 函数返回时清理线程私有句柄块。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」28 29 基准测试框架 JMH]]></title>
    <url>%2F2018%2F12%2F04%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-2829%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6JMH%2F</url>
    <content type="text"><![CDATA[原文 https://time.geekbang.org/column/article/40275 https://time.geekbang.org/column/article/40281 通过 System.nanoTime 或者 System.currentTimeMillis 来测量程序所花费的时间过于理性化，忽略了 Java 虚拟机、操作系统，硬件系统所带来的影响。 性能测试的坑Java 虚拟机的影响 Java 虚拟机堆空间的自适配 即时编译 循环展开 等 操作系统和硬件系统的影响 电源管理策略 CPU 缓存 分支预测器 超线程技术 等 JMH（Java Microbenchmark Harness） OpenJDK 中的开源项目。是一个面向 Java 语言或者其他 Java 虚拟机语言的性能基准测试框架。 JMH 内置许多功能来控制即时编译器的优化。 其他影响性能评测的因素也提供了不少策略降低影响，甚至彻底解决。 如何使用 JMHwww.baidu.com www.google.com]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」26 向量化]]></title>
    <url>%2F2018%2F12%2F03%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-26%E5%90%91%E9%87%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/39838 SIMD 寄存器名称 所属指令集 位数 备注 XMM 寄存器 SSE（Streaming SIMD Extensions）指令集 128 位 YMM 寄存器 AVX（Advanced Vector Extensions）指令集 256 位 XMM升级版 ZMM 寄存器 AVX512 指令集 512 位 YMM升级版 原本使用 XMM 寄存器的指令，使用 YMM 寄存器的低 128 位。 支持 AVX512 指令集的 CPU 都比较贵，目前在生产环境中很少见到。 HotSpot 虚拟机更新了不少基于 AVX512 指令集以及 ZMM 寄存器的优化。 单指令流多数据流（Single Instruction Multiple Data，SIMD）：即通过单条指令操控多组数据的计算操作。这些指令称之为 SIMD 指令。 SIMD 指令将上述寄存器中的值看成多个整数或者浮点数组成的向量，进行批量计算。 128 位 XMM 寄存器里的值可以看成 16 个 byte 值组成的向量，或者 8 个 short 值组成的向量，4 个 int 值组成的向量，两个 long 值组成的向量。 SIMD 指令 PADDB、PADDW、PADDD 以及 PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。 SIMD 指令也被看成 CPU 指令级别的并行。 使用 SIMD 指令的 HotSpot Intrinsic SIMD 指令虽然非常高效，但是使用很麻烦。 不同的 CPU 所支持的 SIMD 指令可能不同。 Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的，将被替换为具体 SIMD 指令的 intrinsic 方法。 HotSpot 虚拟机提供 Java 层面的 intrinsic 方法，这些 intrinsic 方法的语义要比单个 SIMD 指令复杂得多。 使用 SIMD 指令的 HotSpot intrinsic 是虚拟机开发人员根据其语义定制的，因而性能相当优越。 由于开发及维护成本较高，这种类型的 intrinsic 屈指可数。 intrinsic 方法只能做到点覆盖，在多数情况下，应用程序不会用到这些 intrinsic 的语义，却又存在向量化优化的机会（借助自动向量化）。 自动向量化（auto vectorization） 即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。 计数循环的判定 自动向量化的条件较为苛刻。 C2 支持的整数向量化操作不多（加法，减法，按位与、或、异或，以及批量移位和批量乘法）。 C2 支持向量点积的自动向量化，需要多条 SIMD 指令完成，并不是十分高效。 自动向量化的条件 循环变量的增量为 1（能够遍历整个数组）。 循环变量不能为 long 类型（ C2 无法将循环识别为计数循环）。 循环迭代之间最好不要有数据依赖（循环展开之后，循环体内存在数据依赖，C2 无法进行自动向量化）。 循环体内不要有分支跳转。 不要手工进行循环展开（如果 C2 无法自动展开，也无法进行自动向量化）。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」25 循环优化]]></title>
    <url>%2F2018%2F11%2F24%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-25%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/39814 循环无关代码外提 所谓的循环无关代码（Loop-invariant Code），指的是循环中值不变的表达式。 在不改变程序语义的情况下，将循环无关代码提出循环之外。 外提循环中值不变的表达式 通过 Sea-of-Nodes IR 以及节点调度共同完成。 外提循环无关检测 通过循环预测（Loop Prediction）完成。 比如 null 检测（null check），数组下标范围检测（range check）。 null 检测涉及控制流依赖，无法通过 Sea-of-Nodes IR 转换以及节点调度外提。 循环展开（Loop Unrolling） 指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。 在 C2 中，只有计数循环（Counted Loop）才能被展开。 随着循环体的增大，优化机会不断增加。 如果循环展开能够触发进一步优化，总体的代码复杂度将降低。 缺点：可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。 循环完全展开（Full Unroll） 当循环数目是固定值而且非常小时，会将循环全部展开（Full Unroll）。 仅迭代三次（或以下）的循环，即时编译器将进行完全展开。 循环体 IR 节点数目超过阈值的循环，即时编译器不会进行任何循环展开。 计数循环需满足的 4 个条件 维护一个循环计数器，并且基于计数器的循环出口只有一个（但可以有基于其他判断条件的出口）。 循环计数器的类型为 int、short 或者 char（即不能是 byte、long，更不能是 float 或者 double）。 每个迭代循环计数器的增量为常数。 循环计数器的上限（增量为正数）或下限（增量为负数）是循环无关的数值。 循环判断外提（loop unswitching） 指的是将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。 与循环无关检测外提所针对的代码模式比较类似。 循环剥离（loop peeling） 指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。 一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。 剥离出去后，可以使原本的循环体的规律性更加明显，触发进一步的优化。 问题Q： 如果有这样一段代码： 123for ( ... ) &#123; sum += x + y + a[i];&#125; 借助 Sea-of-Nodes IR 能把 x + y 表达式外提出去。但，如果表达式变成如下： 1sum += x + a[i] + y; 也能借助 IR 外提 x + y 吗？ A：能。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」24 字段访问相关优化]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-24%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/39683 字段读取优化 即时编译器会优化实例字段和静态字段访问，以减少总的内存访问数目。 沿控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。 遇到对同一字段的读取节点时，如果缓存值还没有失效，将读取节点替换为该缓存值。 遇到对同一字段的存储节点时，更新所缓存的值。 遇到可能更新字段的节点时，采取保守策略，舍弃所有缓存值。 如果字段读取节点被替换成一个常量，将进一步触发更多优化。 删除不可达条件分支代码，死循环后的代码。 即时编译器将在 volatile 字段访问前后插入内存屏障节点。 内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。 加锁、解锁操作会阻止即时编译器的字段读取优化。 字段存储优化 即时编译器会消除冗余的存储节点。 如果字段被标记为 volatile，即时编译器不能将冗余的存储操作消除掉。 死代码消除（dead code eliminiation） 消除局部变量的死存储（dead store）（涉及冗余存储）。 消除不可达分支。 问题Q：思考即时编译器会怎么优化下面代码中的除法操作？ 12345int bar(int x, int y) &#123; int t = x/y; t = x+y; return t;&#125; A：除法无法优化，因为可能存在除零异常。s即时编译器需要判断除数是否为 0。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」23 逃逸分析]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-23%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/18048 逃逸分析 一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。 在 JVM 的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。 判断对象是否逃逸的依据 对象是否被存入堆中（静态字段或者堆中对象的实例字段）。 对象是否被传入未知代码中（对象是否作为方法调用的调用者或者参数）。 方法中未被内联的方法调用当成未知代码。 可以认为方法调用的调用者以及参数是逃逸的。 通常逃逸分析放在方法内联之后。 基于逃逸分析的优化锁消除 如果能证明锁对象不逃逸，对该锁对象的加锁、解锁操作没有意义。 因为其他线程不能获得该所对象，即时编译器可以消除加锁、解锁操作。 传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。 由于即时编译的限制，条件被强化为证明锁对象不逃逸出当前编译的方法。 基于逃逸分析的锁消除实际上不多见。 栈上分配（HotSpot 虚拟机未采用） 如果逃逸分析能证明某些新建的对象不逃逸，可以将其分配至栈上。 new 语句所在的方法退出时，弹出当前方法的栈桢自动回收内存空间。 无须借助垃圾回收器处理。 实现需要更改大量假设“对象只能堆分配”的代码。 标量替换 标量：就是仅能存储一个值的变量，如局部变量。 聚合量：可能同时存储多个值，如 Java 对象。 可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。 对象没有被实际分配，和栈上分配一样。 可以减轻垃圾回收的压力。 与栈上分配相比，对字段的内存连续性不做要求。 字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。 部分逃逸分析（partial escape analysis） C2 的逃逸分析与控制流无关。 Graal 引入一个与控制流有关的逃逸分析，即部分逃逸分析。 部分逃逸分析能够优化更多的情况，编译时间更长。 解决所新建的实例仅在部分程序路径中逃逸的情况。 根据控制流信息，判断出新建对象仅在部分分支中逃逸，将对象的新建操作推延至对象逃逸的分支中。 使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行 if-else 分支的程序路径之中。（不懂）]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>看不懂</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」22 HotSpot 虚拟机的 intrinsic]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-22HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84intrinsic%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/18046 HotSpot 虚拟机中，所有被标注 @HotSpotIntrinsicCandidate 注解的方法都是 HotSpot intrinsic。 这些方法的调用，会被 HotSpot 虚拟机替换成高效的指令序列。原本的方法实现则会被忽略掉。 如果 Java 核心类库的开发者更改了原本的实现，虚拟机中的高效实现也需要进行相应的修改。 其他虚拟机不一定维护了这些 intrinsic 的高效实现。 这些高效实现通常依赖于具体的 CPU 指令，而这些 CPU 指令不好在 Java 源程序中表达。 如果换了一个体系架构，可能没有对应的 CPU 指令，无法进行 intrinsic 优化。 intrinsic 与方法内联独立的桩程序 可以被解释执行器利用，直接替换对原方法的调用。 可以被即时编译器所利用，把代表对原方法的调用的 IR 节点，替换为对这些桩程序的调用的 IR 节点。 这种形式实现的比较少，主要包括 Math 类的一些方法。 特殊的编译器 IR 节点 只能被即时编译器所用。 将对原方法的调用的 IR 节点，替换成特殊的 IR 节点，并参与接下来的优化过程。 替换过程是在方法内联时进行。 native 方法被标记为 intrinsic 也能够 “ 内联 “ 进来，并插入特殊的 IR 节点。 即时编译器的后端根据这些特殊的 IR 节点，生成指定的 CPU 指令。 -native 方法经过 intrinsic 优化之后，JNI 开销直接消失不见，最终的结果十分高效。 大部分实现通过这种形式。 已有 intrinsic 简介 最新版本的 HotSpot 虚拟机定义了三百多个 intrinsic（Java 10.0.2）。 有三成以上是 Unsafe 类的方法。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Android 学习路线指南]]></title>
    <url>%2F2018%2F11%2F14%2F%E8%BD%AC-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[转自：Android学习路线指南 前言看到一篇文章中提到“最近几年国内的初级 Android 程序员已经很多了，但是中高级的 Android 技术人才仍然稀缺“，这的确不假，从我在百度所进行的一些面试来看，找一个适合的高级 Android 工程师的确不容易，一般需要进行大量的面试才能挑选出一个比较满意的。为什么中高级 Android 程序员不多呢？这是一个问题，我不好回答，但是我想写一篇文章来描述下 Android 的学习路线，期望可以帮助更多的 Android 程序员提升自己。由于我也是从一个菜鸟过来的，所以我会结合我的个人经历以及我对 Android 学习过程的认识来写这篇文章，这会让这篇文章更加真实，而并非纸上谈兵。 我的工作经历前面说到，我也是从一个 Android 菜鸟过来的。其实这句话放在任何人的身上都是适用的，即大家都是一步步过来的，因此作为初学者也不必因为技术差而郁闷，同理，高手也不要看不起一些所谓的菜鸟，因为这不公平，技术只有在同等的工作年限上才具有一定的可比性，也许你眼中的菜鸟只是个工作半年的新手，而你已经工作 5 年，可想而知，这根本不具有可比性，搞不好别人 5 年后可以达到比你更高的技术高度。 我有若干个技术 QQ 群，群里（481798332）的小伙伴对我的工作经历比较感兴趣，刚好在这里我就做下介绍。我是硕士研究生毕业，我已经工作 3 年零 3 个月了，职位上从最开始的腾讯初级工程师变成了现在的百度 Android 资深工程师。最开始我并不是做 Android 的，先是做了半年的 C++，接着做了 3 个月的 Web 前端，然后公司内部转岗做 Android 到至今，纯 Android 工作年限的话其实是 2.5 年。但是我认为我的 Android 工作经验（注：工作年限不等同于工作经验）不止 2.5 年，我投入大量的业余时间在 Android 开发上，并且我习惯去思考问题、总结问题并将其融会贯通，因此我的 Android 技术在短时间内有了很大的提升。 在 Android 学习过程中，初学者踩过的坑我也都踩过，我也深深地知道大家在学习过程中最棘手的问题是什么。举个例子，在 3 年前，我想在 SlidingMenu 中放入一个 ListView，发现二者总是不能很好地一起工作，这肯定是由于滑动冲突的问题，我也知道，但是不知道怎么解决。我就去学校图书馆翻遍了所有的 Android 书籍，无果。大家肯定都知道原因，为什么我无法从书中查找到问题的答案，因为入门书不讲滑动冲突，所谓的高级编程书也不讲。还有一个问题，我曾经以为 view.post(runnable) 可以让 runnable 的 run 方法在线程中执行，所以我就在 run 方法里面去做耗时的操作，现在想想我当时是多菜啊，因此我曾经也是菜鸟。 直到若干年后的某一天，我终于琢磨透了滑动冲突的事，然后我就把解决问题的思想写在了 CSDN 博客上，但是好像看得人并不多，很多人并不能体会我的用心，后来我博客的访问量越来越大，这才慢慢地得到了一些人的关注。后来有一天我有了写书的契机，我想到了我最开始学习 Android 时所踩过的坑，想到滑动冲突对我的困扰，为了更好地传播我的技术经验，为了让更多的人少踩一些坑，为了让更多地人成为 Android 高级工程师，我毅然决定将 Android 开发中最重要的、最疑难的、最容易困扰大家的、成为高级工程师所必备的知识点和盘托出，这就是《Android 开发艺术探索》存在的原因以及意义。书的反响怎么样呢？从目前读者的评价来看，内容基本无差评，我收到了很多读者的肯定以及感谢，这说明很多人能够理解我的用心。 说了那么多，言归正传，下面说下 Android 学习路线的话题，本文打算从 4 个阶段来对 Android 的学习过程做一个全面的分析，分别为 Android 初级、中级、高级以及资深工程师，具体请看下面的分析。同理，本篇学习路线仍然只针对 Android 应用开发，不针对 Rom 开发和逆向工程等。这里虚拟一位“小明”的角色，在这里小明就是 Android 初学者的代表。 初级工程师小明之前完全没接触过 Android 开发，是个应届生，他的待遇是 13k，然后小明以校招的身份进入了百度，然后小明需要怎么学习才能成为初级工程师呢？这个时候，小明对编程基础、数据结构、C 语言都有一定基础，Java 语法什么的也都掌握的比较好，Android 才有 java 语言，无奈的是小明并不会搞 Android。 小明首先需要购买一本 Android 入门的书籍，为了更快地学习 Android，小明业余时间也都用来一边看书一边照着书中的例子敲代码，结果 2 周时间小明就把这本书学了一遍。看完这本书后，小明对 Android 的历史、结构、代码规范等都有了一个大概的了解，并且，小明已经可以写出一些简单的 Activity 了。这个时候在小明眼里，Android 开发很简单很好玩，通过在 xml 中摆放一些按钮文本框什么的就可以做一些界面了。 小明开始跟着他的技术导师做需求，一些简单的小需求小明自然是不在话下了。突然有一天来了一个需求，该需求要求小明在 Activity 中为一个 button 加一个动画效果，小明慌了：“完全没接触过，书上也没有讲，怎么办呢？”小明冷静了下，打开了百度搜索，输入“Android 动画”，打开前几个链接，小明恍然大悟，照着网上的例子把需求给实现了。后来导师告诉他：“学好 Android，官方文档是必须看的，既全面又权威”。然后小明如获至宝，花了一年时间把上面的 guide 和 training 都看了一遍，并且他还动手抄了几个小例子。 有一天，小明又需要做一个动画相关的需求，这可难不倒小明，它熟练地打开了 www.baidu.com，输入“Android 动画”，突然他楞了一下：”总不能每次写动画都要百度一下吧！“，于是他在 CSDN 开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用百度去搜了，事实如何呢？后面再写动画相关的代码，小明的确不用再去百度搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小明还学会了把一些琐碎的不方便放在博客上的东西写到了印象笔记上面，什么时候忘了 10 秒钟以内都可以快速找回来，而不是花 10 分钟去再次搜索一遍。 这里总结一下，Android 入门的时候，需要有一本入门书，好好学习书中的内容，同时花一年时间把 Android 官方文档中的 training 和 guide 看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。 技术要求： 基本知识点 比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐 《第一行代码 Android》、《疯狂 Android》 中级工程师小明经过一年的努力学习终于成为 Android 中级工程师了，月薪变成了 17k。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小明还不能一个人承担起来，这个时候小明需要学习的内容就很多了，如下所示： AIDL：熟悉 AIDL，理解其工作原理，懂 transact 和 onTransact 的区别； Binder：从 Java 层大概理解 Binder 的工作原理，懂 Parcel 对象的使用； 多进程：熟练掌握多进程的运行机制，懂 Messenger、Socket 等； 事件分发：弹性滑动、滑动冲突等； 玩转 View：View 的绘制原理、各种自定义 View； 动画系列：熟悉 View 动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉 mat 等工具 懂点常见的设计模式 学习方法阅读进阶书籍，阅读 Android 源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有 2 个点是比较困扰大家的，一个是阅读源码，另一个是自定义 View 以及滑动冲突。 如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。 如何玩转自定义 View 呢？我的建议是不要通过学习自定义 view 而学习自定义 view。为什么这么说呢？因为自定义 view 的种类太多了，各式各样的绚丽的自定义效果，如何学的玩呢！我们要透过现象看本质，更多地去关注自定义 view 所需的知识点，这里做如下总结： 搞懂 view 的滑动原理 搞懂如何实现弹性滑动 搞懂 view 的滑动冲突 搞懂 view 的 measure、layout 和 draw 然后再学习几个已有的自定义 view 的例子 最后就可以搞定自定义 view 了，所谓万变不离其宗 大概再需要 1-2 年时间，即可达到高级工程师的技术水平。我个人认为通过《Android 开发艺术探索》和《Android 群英传》可以缩短这个过程为 0.5-1 年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。 技术要求： 稍微深入的知识点 AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义 View、消息队列等 书籍推荐 《Android 开发艺术探索》、《Android 群英传》 高级工程师小明成为了梦寐以求的高级工程师，月薪达到了 20k，还拿到了一丢丢股票。这个时候小明的 Android 水平已经不错了，但是小明的目标是资深工程师，小明听说资深工程师月薪可以达到 30k+。 为了成为 Android 资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解 SystemServer 的启动过程 了解主线程的消息循环模型 了解 AMS 和 PMS 的工作原理 能够回答问题”一个应用存在多少个 Window ？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity 的启动模式以及异常情况下不同 Activity 的表现 Service 的 onBind 和 onReBind 的关联 onServiceDisconnected(ComponentName className) 和 binderDied() 的区别 AsyncTask 在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识 学习方法这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，最近一本新书推荐给大家《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到 Android 源码中的设计思想，我最近也在阅读此书。 技术要求： 稍微深入的知识点 系统核心机制 基本知识点的细节 设计模式和架构 书籍推荐 《Android 开发艺术探索》、《Android 源码设计模式解析与实战》、《Android 内核剖析》 资深工程师这个阶段的程序员也许并没有太具体的学习路线了。]]></content>
      <categories>
        <category>学习指南</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」20 21 方法内联]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-2021%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/14575 在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。 可以消除调用本身带来的性能开销。 可以进一步触发更多的优化。 可以算是编译优化里最为重要的一环。 机器码的生成即时编译器首先解析字节码，并生成 IR 图，然后在该 IR 图上进行优化。优化是由一个个独立的优化阶段（optimization phase）串联起来的。每个优化阶段都会对 IR 图进行转换。最后即时编译器根据 IR 图的节点以及调度顺序生成机器码。 C2 方法内联在解析字节码的过程中完成。 每当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用。如果需要内联，则开始解析目标方法的字节码。 Graal 方法内联在解析字节码的过程中完成。 拥有一个独立的优化阶段，寻找指代方法调用的 IR 节点，替换为目标方法的 IR 图。 独立优化阶段 将被调用方法的 IR 图节点复制到调用者方法的 IR 图中。 被调用方法的传入参数节点，将被替换为调用者方法进行方法调用时所传入参数对应的节点。 在调用者方法的 IR 图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。 如果被调用方法存在多个返回节点，则生成一个 Phi 节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。 在接下来的编译过程中对新的 IR 图进行进一步优化。 方法内联的条件 内联越多➡生成代码的执行效率越高。 内联越多➡编译时间也就越长➡程序达到峰值性能的时刻将被推迟。 内联越多➡生成的机器码越长。 JVM 中编译生成的机器码会被部署到 Code Cache 之中。Code Cache 有大小限制。Code Cache 已满时，出现即时编译已被关闭的警告信息。 即时编译器根据这些规则决定方法调用能否被内联。 方法调用指令所在的程序路径的热度 目标方法的调用次数及大小 当前 IR 图的大小 内联算法更青睐于小方法。 特殊规则 自动拆箱总会被内联。 Throwable 类的方法不能被其他类中的方法所内联。 强制内联 由 -XX:CompileCommand 中的 inline 指令指定的方法。 由 @ForceInline 注解的方法（仅限于 JDK 内部方法）。 不被内联 由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法。 由 @DontInline 注解的方法（仅限于 JDK 内部方法）。 无法内联 调用字节码对应的符号引用未被解析。 目标方法所在的类未被初始化。 目标方法是 native 方法。 不支持内联 C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整）。 1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。 静态方法调用 即时编译器可以轻易地确定唯一的目标方法。 虚方法调用 非 static、非 private 、非 final 方法都是虚方法。 换句话说可以被重写的方法都是虚方法。 即时编译器需要先对虚方法调用进行去虚化（devirtualize），即转换为一个或多个直接调用，然后才能进行方法内联。 完全去虚化 通过类型推导或者类层次分析（class hierarchy analysis），识别虚方法调用的唯一目标方法，将其转换为直接调用。 关键在于证明虚方法调用的目标方法是唯一的。 基于类型推导的完全去虚化 类型推导属于全局优化，比较浪费时间。 通过数据流分析推导出调用者的动态类型。 如果生成 Sea-of-Nodes IR 后，调用者的动态类型已能够直接确定，就进行去虚化。 如果需要额外的数据流分析才能确定，不做，节省编译时间，依赖接下来的去虚化手段优化。 基于类层次分析的完全去虚化 分析所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。如果是，调用这些方法只能调用至该具体实现中。 无法保证之后的执行过程只有一个具体实现。 JVM 为当前编译结果注册若干个假设（assumption）。 假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。 当新的类被加载，JVM 会重新验证假设。 如果某个假设不再成立，对其所属的编译结果去优化。 如果使用了 final 修饰符，即时编译器可以不用生成对应的假设，直接去虚化和内联。 接口方法调用（不懂） 去虚化不能移除动态类型检测。 执行 invokeinterface 指令时，JVM 必须对调用者的动态类型进行测试，是否实现了目标接口方法所在的接口。 Java 类验证器将接口类型直接看成 Object 类型，有可能出现声明类型为接口，实际类型没有继承该接口的情况。 条件去虚化（guarded devirtualization） 将虚方法调用转换为若干个类型测试以及直接调用。 关键在于找出需要进行比较的类型。 将调用者的动态类型，依次与类型 Profile 记录的类型比较。 如果匹配，直接调用该记录类型所对应的目标方法。 不匹配 如果类型 Profile 是完整的，去优化，重新收集类型 Profile。 如果类型 Profile 是不完整的，进行原本的虚调用，通过内联缓存进行调用，或者通过方法表进行动态绑定。（Graal） 在 C2 中，如果类型 Profile 是不完整的，不会进行条件去虚化，直接使用内联缓存或者方法表。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」19 Java 字节码（基础篇）]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-19Java%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/14794 操作数栈 解释执行过程中，为 Java 方法分配栈桢时，JVM 需要开辟一块额外的空间作为操作数栈，存放计算的操作数和返回结果。 执行每一条指令之前，JVM 要求该指令的操作数已被压入操作数栈中。 在执行指令时，JVM 会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。 直接作用在操作数栈上的指令dup 指令 复制栈顶元素。 常用于复制 new 指令所生成的未经初始化的引用。 pop 指令 舍弃栈顶元素。 常用于舍弃调用指令的返回结果。 dup2 指令和 pop2 指令 long 类型或 double 类型的值占据两个栈单元。 dup 指令和 pop 指令只能处理非 long 或非 double 类型的值。 dup2 指令复制栈顶两个单元。 pop2 指令弹出栈顶两个单元。 swap 指令 交换栈顶两个元素的值。 直接将常量加载在操作数栈上的指令 常量类型包括 int 类型 long 类型 float 类型 double 类型 String 类型 Class 类型 正常情况下，操作数栈的压入弹出是一条条指令完成。 例外：抛异常时会清除操作数栈上的所有内容，然后将异常实例压入操作数栈。 int 类型为例 可以通过 iconst 指令加载 -1 至 5 之间的 int 值。 可以通过 bipush、sipush 加载一个字节、两个字节所能代表的 int 值。 可以通过 ldc 加载常量池中的常量值（如 ldc #18 将加载常量池中的第 18 项）。 局部变量区 方法栈帧的重要组成部分。 可以缓存计算的结果。 JVM 将其当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，字节码中的局部变量。 long 类型和 double 类型的值占据两个单元，其余类型占据一个单元。 生命周期没有重合的局部变量可以编排至同一单元。 存储在局部变量区的值，需要加载至操作数栈中，才能进行计算。 计算得到的结果再存储至局部变量区中。 局部变量数组的加载、存储指令需要指明所加载单元的下标。 iinc M N 指令 Java 字节码唯一能够作用于局部变量的指令。 M 为非负整数，N 为整数。 将局部变量数组的第 M 个单元中的 int 值增加 N。 常用于更新 for 循环的自增量。 Java 字节码简介Java 相关指令 new：后跟目标类，生成该类的未初始化的对象。 instanceof：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（是则压入 1，否则压入 0）。 checkcast：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（如果不是便抛出异常）。 athrow：将栈顶异常抛出。 monitorenter：为栈顶对象加锁。 monitorexit：为栈顶对象解锁。 字段访问指令 静态字段访问指令：getstatic、putstatic。 实例字段访问指令：getfield、putfield。 这四条指令均附带用以定位目标字段的信息。 这四条指令所消耗的操作数栈元素皆不同。 方法调用指令 包括 invokestatic，invokespecial，invokevirtual，invokeinterface 和 invokedynamic。 除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素由调用类型和目标方法描述符确定。 数组相关指令 newarray：新建基本类型数组。 anewarray：新建引用类型数组。 mutianewarray：新建多维数组。 arraylength：求数组长度。 数组加载指令。 数组存储指令。 控制流指令 goto：无条件跳转指令。 tableswitch：条件跳转指令（针对密集的 cases）。 lookupswtich：条件跳转指令（针对稀疏的 cases）。 被废弃的 jsr，ret 指令。 返回指令。 除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。 问题Q：JVM 为什么使用基于栈的计算模型？ A：实现起来容易一些，但并不高效，因为没有使用底层体系架构的寄存器。在 JVM 中，只有解释器完整地模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。 Q：为什么局部变量要初始化？ A：① 如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。② 从代码规范来看，使用未经初始化的局部变量意义不明。 Q：C/C++ 的汇编指令会有大量寄存器的操作，Java 的指令会用到寄存器吗？ A：Java 字节码不会，但是底下的实现（比如解释执行器，即时编译器）是会的。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」18 即时编译器的中间表达形式]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-18%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/14270 目测太难看不懂。。。 待更新]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>看不懂</tag>
        <tag>未完成</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Android 的视图优化方法]]></title>
    <url>%2F2018%2F11%2F07%2FAndroid%E7%9A%84%E8%A7%86%E5%9B%BE%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[过度绘制（Overdraw） 过度绘制（Overdraw）指的是屏幕上的某个像素在同一帧的时间内被绘制了多次。 检测过度绘制Android 中打开过度绘制检测工具的方式： 开发者选项 ➡ 调试GPU过度绘制 ➡ 显示过度绘制区域 界面中会出现不同颜色的区域，各颜色代表的意思： 过度绘制优化移除布局中不需要的背景移除 Window 默认的 Background通常使用的 theme 会包含一个 windowBackground。 1&lt;item name="android:windowBackground"&gt;@color/background_material_light&lt;/item&gt; 然后又给跟布局添加了一个背景，这会导致整个页面被多绘制一次。 移掉 windowBackground 即可解决，有两种方法。 在 theme 中设置 1&lt;item name="android:windowBackground"&gt;@null&lt;/item&gt; 在 onCreate() 方法中添加 1getWindow().setBackgroundDrawable(null); 移除控件中不需要的背景 父布局和子布局设置了相同的 background，选择其一设置即可。 减少透明度的使用View 设置了 alpha 值至少渲染两次。 布局优化 LinearLayout 与 RelativeLayout 作用相同时使用 LinearLayout。 LinearLayout 需要嵌套时使用 RelativeLayout。 使用 ConstraintLayout。 使用 Layout Inspector 查看 layout 层次结构 Tools &gt; Android &gt; Layout Inspector 使用 lint 优化布局的层次结构 Analyze&gt; Inspect Code Android&gt; Lint&gt; Performance &lt;include> 标签 只支持 android:layout_ 开头的属性（android:id 是特例）。 &lt;include> 指定了 id 属性，包含的布局文件根元素也指定了 id 属性，以 &lt;include> 指定的为准。 &lt;merge> 标签 配合 &lt;include> 标签使用可以减少布局的层级。 ViewStub 继承自 View，宽高都是 0，本身不参与任何的布局和绘制过程。 按需加载所需的布局文件（如网络异常时的界面），使用的时候再加载，提高初始化性能。 不支持 &lt;merge> 标签。 使用 inflatedId 属性指定加载的布局 id。 123&lt;ViewStub android:id="@+id/stub_import" android:inflatedId="@+id/panel_import" /&gt; 怎样加载？1((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); 或 1View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 加载后 ViewStub 不在属于布局，为 null。 绘制优化onDraw 方法 不要创建新的布局对象。 不要做耗时的任务。 减少自定义 View 的过度绘制 假如有多张图片叠层显示时，可以使用 Canvas 的 clipRect() 等方法将图片裁剪。 使用 GPU 呈现模式分析工具Android 中打开 GPU 呈现模式分析工具的方式： 开发者模式 ➡ 监控 ➡ GPU呈现模式]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
        <tag>视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」16 17 即时编译]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1617%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[原文 https://time.geekbang.org/column/article/14061 https://time.geekbang.org/column/article/14070 分层编译模式HotSpot 包含的即时编译器： C1 C2 Graal（实验性质的即时编译器） Java 7 以前需要根据程序特性选择对应的即使编译器C1 执行时间较短的程序。 对启动性能有要求的程序。 C1 编译效率较快。 对应参数 -client C2 执行时间较长的程序。 对峰值性能有要求的程序。 C2 生成代码的执行效率较快。 对应参数 -server Java 7 引入分层编译 综合 C1 的启动性能优势和 C2 的峰值性能优势。 分层编译将 Java 虚拟机的执行状态分为 5 个层次。 0.解释执行 1.执行不带 profiling 的 C1 代码 2.执行仅带方法调用次数和循环回边执行次数 profiling 的C1 代码 3.执行带所有 profiling 的 C1 代码 4.执行 C2 代码 C2 代码的执行效率比 C1 代码高 30% 以上。 C1 执行效率 1 层 &gt; 2 层 &gt; 3 层。（1 层比 2 层稍高，2 层比 3 层高 30% 以上）。 profile profiling：在程序执行过程中，收集能够反映程序执行状态的数据。 这里所收集的数据我们称之为程序的 profile。 例如 JDK 附带的 hprof。 profiler 大多通过注入或 JVMTI 事件来实现。 第 0 层和第 3 层还会收集用于第 4 层 C2 编译的数据。 如：分支跳转字节码的分支 profile（branch profile）（跳转次数和不跳转次数），非私有实例方法调用指令，强制类型转换 checkcast 指令，类型测试 instanceof 指令，引用类型的数组存储 aastore 指令的 profile（receiver type profile）。 分支 profile 和类型 profile 的收集会给应用程序带来不少性能开销。 通常情况，不会在解释执行中收集分支 profile 和类型 profile。 只有触发 C1 编译后，JVM 认为可能被 C2 编译，才收集这些 profile。 比较极端情况下，JVM 才会在解释执行时收集 profile（如等待 C1 编译的方法过多时）。 C2 可以根据收集到的数据进行猜测，作出比较激进的优化。 基于分支 profile 的优化 根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉。 节省编译时间和部署代码要消耗的内存空间。 将精简程序的数据流，触发更多的优化。 根据分支 profile，计算每一条程序执行路径的概率，优化优先处理概率较高的路径。 基于类型 profile 的优化instanceof 测试 目标类型是 final 类型，只比较测试对象的动态类型是否为该类型。 目标类型是非 final 类型，依次测试该类，该类的父类、祖先类，该类所直接或者间接实现的接口。 instanceof 以及方法调用的类型 profile 假设对象的动态类型仅为类型 profile 中的那几个。 针对分支 profile 优化。 对方法调用的条件去虚化内联。 去优化 即从执行即时编译生成的机器码切换回解释执行。 当假设失败的情况下，JVM 将去优化。 生成的机器码中，即时编译器在假设失败的位置上插入一个陷阱（trap）。 陷阱实际上是一条 call 指令，调用至 Java 虚拟机专门负责去优化的方法。 与普通的 call 指令的区别：去优化方法会更改栈上的返回地址，并不再返回即时编译器生成的机器码中。 去优化过程非常复杂。 生成的机器代码和原本的字节码差异非常大。 需要将当前机器码的执行状态转换至某一字节码之前的执行状态，并从该字节码开始执行。 这便要求即时编译器在编译过程中记录好这两种执行状态的映射。 去优化的原因与优化无关 即使重新编译也不会改变生成的机器码。 生成的机器码可以在调用去优化方法时传入 Action_None。 表示保留这一份机器码。 在下一次调用该方法时重新进入这一份机器码。 去优化的原因与静态分析的结果有关 生成的机器码可以在调用去优化方法时传入 Action_Recompile。 表示不保留这一份机器码。 但是可以不经过重新 profile，直接重新编译。 去优化的原因与基于 profile 的激进优化有关 生成的机器码需要在调用去优化方法时传入 Action_Reinterpret。 表示不保留这一份机器码。 而且需要重新收集程序的 profile。 编译路径 1 层和 4 层为终止状态。 一个方法被终止状态编译后，如果编译后的代码没有失效，JVM 不再发出该方法的编译请求。 通常情况 热点方法会被第 3 层的 C1 编译，再被第 4 层的 C2 编译。 琐碎的方法 字节数少，且第 3 层的 profiling 没有可收集的数据的方法。 JVM 断定该方法对于 C1 代码和 C2 代码执行效率相同。 在第 3 层编译后，直接用第 1 层的 C1 编译。 C1 忙碌的情况 解释执行过程中进行 profiling。 然后直接由第 4 层的 C2 编译。 C2 忙碌的情况 方法先被第 2 层的 C1 编译。 再被第 3 层的 C1 编译，减少在第 3 层的执行时间。 Java 8 默认开启分层编译。 不管分层编译是否开启，原本的选择即时编译器的参数都无效（-client 和 -server）。 关闭分层编译情况下，JVM 采用 C2。 只使用 C1：使用参数 -XX:TieredStopAtLevel=1，解释执行后直接由 1 层的 C1 编译。 即时编译的触发 根据方法的调用次数和循环回边的执行次数来触发。 profiling 中包含上述次数。 解释执行和 C1 代码中增加循环回边计数器的位置不同，但不会对程序照成影响。 JVM 不对计数器进行同步，收集的几次为非精确值。 即时编译的触发不需要非常精确的值。 不启用分层编译，超过由参数 -XX:CompileThreshold 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），会触发即时编译。 启用分层编译，JVM 不采用由参数 -XX:CompileThreshold 指定的阈值，使用另一套阈值系统。阈值大小动态调整。 动态调整：比较阈值时，将阈值与某个系数 s 相乘。 该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关。 64 位 JVM中，默认情况下编译线程的总数目根据处理器数量来调整，（对应参数 -XX:+CICompilerCountPerCPU，默认为 true；当通过参数 -XX:+CICompilerCount=N 强制设定总编译线程数目时，CICompilerCountPerCPU 将被设置为 false）。 JVM 将编译线程按照 1:2 的比例分配给 C1 和 C2（至少各为 1 个）。 123对于核及以上的机器，总的编译线程的数目为：n = log2(N) * log2(log2(N)) * 3 / 2其中 N 为 CPU 核心数目。 启用分层编译时的具体触发条件： 1234当方法调用次数大于由参数 -XX:TierXInvocationThreshold 指定的阈值乘以系数，或者当方法调用次数大于由参数 -XX:TierXMINInvocationThreshold 指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数 -XX:TierXCompileThreshold 指定的阈值乘以系数时，便会触发 X 层即时编译。触发条件为：i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s &amp;&amp; i + b &gt; TierXCompileThreshold * s) OSR 编译 JVM 还存在另一种以循环为单位的即时编译（On-Stack-Replacement（OSR）编译）。 循环回边计数器用来触发这种类型的编译的。 不启用分层编译情况，触发 OSR 编译的阈值是由参数 -XX:CompileThreshold 指定的阈值的倍数。 计算方法： 1234(OnStackReplacePercentage - InterpreterProfilePercentage)/100其中 -XX:InterpreterProfilePercentage 的默认值为 33，当使用 C1 时 -XX:OnStackReplacePercentage 为 933，当使用 C2 时为 140。也就是说，默认情况下，C1 的 OSR 编译的阈值为 13500，而 C2 的为 10700。 启用分层编译的情况下，触发 OSR 编译的阈值则由参数 -XX:TierXBackEdgeThreshold 指定的阈值乘以系数。 OSR 编译在正常的应用程序中不多见。它只在基准测试时比较常见。 问题Q：为什么不把所有代码都即时编译一下呢？这样程序的执行效率不是更快吗？ A：即时编译是以方法为单位的。动态编译比较耗时，如果花了大量 CPU 资源编译出来的机器码运行不了几次，就很浪费了。 Q：为什么要用分层编译呢？使用最快的编译代码编译器编译的代码不是更好吗？ A：机器码越快，需要的编译时间就越长。分层编译是一种折衷的方式，既能够满足部分不那么热的代码能够在短时间内编译完成，也能满足很热的代码能够拥有最好的优化。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」一些简单的 Git 命令]]></title>
    <url>%2F2018%2F10%2F21%2F%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84Git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[完整性 Git 以校验和的方式检测数据完整性。 Git 中的 commit id 是校验和。 文件状态和工作区域 工作区域： 工作目录：写代码的区域。 暂存区：代码 add 后 commit 前所在的区域。 本地仓库：代码 commit 后所在的区域。 文件状态： 已修改：工作目录已修改，代码未 add。 已暂存：代码已 add，未 commit。 已提交：代码已 commit。 用户身份 配置个人信息 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;example@email.com&quot; 查看个人信息 1$ git config --list 创建本地仓库 初始化本地仓库 1$ git init 从远程仓库克隆 1$ git clone ssh/https 地址 本地操作 添加文件到暂存区 1$ git add readme.txt 添加所有文件到暂存区 1$ git add . 提交暂存区文件到本地仓库 1$ git commit -m &quot;say something&quot; 加 -m 表示直接用后面的字符串作为说明，否则跳转编辑器 查看本地仓库提交历史 1$ git log 查看文件状态 1$ git status Changes to be committed：已暂存、可提交文件 Untracked files：未暂存文件 查看未暂存文件变更细节 1$ git diff 查看已暂存文件变更细节 1$ git diff --staged 版本回退 回到上一个版本（硬回退） 1$ git reset --hard HEAD^ 回到上一个版本（软回退） 1$ git reset --soft HEAD^ hard 移除仓库中的 commit，暂存区和工作区回到之前的状态。 soft 移除仓库中的 commit，暂存区和工作区不变。 查询版本提交记录 1$ git reflog ① commit id ② 执行的命令 ③ 描述 回退到指定版本 1$ git reset --hard 提交Id commit id 可以不填全部，git 自动查找。 撤销修改 撤销未添加到暂存区的修改 1$ git checkout --文件 撤销已添加到暂存区的修改 1$ git reset HEAD 文件 删除相关操作 删除文件 删除本地文件（文件管理器中删或用 rm 命令） 1$ rm 文件 确认 git 删除工作区文件 1$ git rm 文件 提交 恢复文件 1$ git checkout --文件 - 可以恢复未添加到暂存区的修改了的文件 - 可以恢复自删除的文件 远程仓库 关联远程仓库 1$ git remote add 自定义远程仓库名 ssh/https地址 第一次推送本地仓库到远程仓库 1$ git push -u 远程仓库名 远程仓库分支名 非第一次推送本地仓库到远程仓库 1$ git push 远程仓库名 远程仓库分支 从远程仓库拉取数据到本地 1$ git fetch 远程仓库名 将从远程仓库拉取的数据和本地仓库合并 1$ git merge 本地分支名 从远程仓库拉取数据并合并 1$ git pull 远程仓库名 远程分支名 fetch 只拉取远程仓库数据，不更新本地仓库状态。 pull 拉取远程仓库数据并更新本地仓库状态到远程仓库最新状态。 pull = fetch + merge 分支 创建分支 1$ git branch 分支名 切换分支 1$ git checkout 分支名 创建并切换分支 1$ git checkout -b 分支名 查看分支 1$ git branch 合并分支 1$ git branch 分支名 删除分支 1$ git branch -d 分支名 解决冲突 解决冲突后不能提交某个文件，只能提交全部文件 变基（写的不完整，无参考价值）1$ git rebase 分支名 rebase 失败先解决冲突再执行 1$ git rebase --continue 变基抛弃原有提交，创建新的对应提交。 变基的提交历史是一条直线。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」15 Java 语法糖与 Java 编译器]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8EJava%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/13781 自动装箱（auto-boxing）与自动拆箱（auto-unboxing）123456public int foo() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(0); int result = list.get(0); return result;&#125; 上段代码对应的字节码： 12345678910111213141516171819public int foo(); Code: 0: new java/util/ArrayList 3: dup 4: invokespecial java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: iconst_0 10: invokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z 16: pop 17: aload_1 18: iconst_0 19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object; 22: checkcast java/lang/Integer 25: invokevirtual java/lang/Integer.intValue:()I 28: istore_2 29: iload_2 30: ireturn 向泛型参数为 Integer 的 ArrayList 添加 int 值，字节码中调用了 Integer.valueOf 方法。 从泛型参数为 Integer 的 ArrayList 取出元素，程序期待的是 int 值，字节码中调用了 Integer.intValue 方法。 泛型与类型擦除 在字节码中，ArrayList 的 add 接受的参数类型是 Object，get 方法的返回类型是 Object。 get 方法强制向下转换类型。 泛型信息在 JVM 中会全部擦除，为了兼容引入泛型之前的代码。 为限定继承类的泛型参数擦除为 Object，限定继承类的泛型参数擦除为所限定的类。 12345class GenericTest&lt;T extends Number&gt; &#123; T foo(T t) &#123; return t; &#125;&#125; 上段代码字节码 12345678T foo(T); descriptor: (Ljava/lang/Number;)Ljava/lang/Number; flags: (0x0000) Code: stack=1, locals=2, args_size=2 0: aload_1 1: areturn Signature: (TT;)TT; 方法声明和方法签名（Signature）仍存在泛型参数信息，由 Java 编译器编译其他类时使用。 桥接方法 桥接方法标识符包括 ACC_BRIDGE 和 ACC_SYNTHETIC（对于 Java 源代码不可见）。 不能直接调用桥接方法，但可通过反射调用。 泛型重写生成桥接方法123456789101112class Merchant&lt;T extends Customer&gt; &#123; public double actionPrice(T customer) &#123; return 0.0d; &#125;&#125;class VIPOnlyMerchant extends Merchant&lt;VIP&gt; &#123; @Override public double actionPrice(VIP customer) &#123; return 0.0d; &#125;&#125; actionPrice 方法符合 Java 语言的方法重写。 不符合 JVM 方法重写的定义。 父类方法描述符(LCustomer) 子类方法描述符(LVIP) 为了保证编译的字节码能保留重写的语言，Java 编译器额外添加了桥接方法。 1234567891011121314151617181920212223class VIPOnlyMerchant extends Merchant&lt;VIP&gt;... public double actionPrice(VIP); descriptor: (LVIP;)D flags: (0x0001) ACC_PUBLIC Code: 0: dconst_0 1: dreturn public double actionPrice(Customer); descriptor: (LCustomer;)D flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: 0: aload_0 1: aload_1 2: checkcast class VIP 5: invokevirtual actionPrice:(LVIP;)D 8: dreturn// 这个桥接方法等同于public double actionPrice(Customer customer) &#123; return actionPrice((VIP) customer);&#125; 桥接方法在字节码层面重写父类方法，并通过强制类型转换调用子类方法。 子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法12345678910111213141516171819class NaiveMerchant extends Merchant public java.lang.Double actionPrice(Customer); descriptor: (LCustomer;)Ljava/lang/Double; flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: dconst_0 1: invokestatic Double.valueOf:(D)Ljava/lang/Double; 4: areturn public java.lang.Number actionPrice(Customer); descriptor: (LCustomer;)Ljava/lang/Number; flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokevirtual actionPrice:(LCustomer;)Ljava/lang/Double; 5: areturn JVM 允许两个同名、同参数类型、不同返回类型的方法。 foreach数组循环从 0 到末尾逐一访问数组元素。 Iterable 对象循环调用 hasNext 和 next 方法 遍历元素。 字符串 switch case 比较字符串的哈希值。 哈希值相同的字符串用 equals 比较。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」14 Java 虚拟机是怎么实现 synchronized 的？]]></title>
    <url>%2F2018%2F10%2F17%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0synchronized%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/13530 声明 synchronized 的代码块，字节码包含 monitorenter 和 monitorexit 指令。 这两种指令会消耗操作数栈上的一个引用类型的元素。 这个元素是用来加解锁的锁对象。（synchronized 括号里的引用，实例方法是 this，静态方法是 class 实例）。 用 synchronized 标记方法，字节码中方法的访问标记包括 ACC_SYNCHRONIZED。 monitorenter 和 monitorexit作用可以抽象地理解为每个锁对象有： 一个锁计数器 一个指向持有该锁的线程的指针 执行 monitorenter 计数器为 0 说明没有被其他线程所持有。 锁对象的持有线程设置为当前线程。 计数器加 1。 计数器不为 0 如果锁对象的持有当前线程，计数器加 1。 否则等待，直至锁释放。 执行 monitorexit 锁对象的计数器减 1。 减为 0 时，锁被释放。 为什么采用计数器的方式？ 允许同一个线程重复获取同一把锁。 HotSpot 虚拟机中具体的锁实现。 重量级锁 JVM 中最基础的锁实现。 阻塞加锁失败的线程，锁被释放时唤醒。 阻塞及唤醒依靠操作系统完成，开销大。 自旋状态 为了尽量避免昂贵的线程阻塞、唤醒操作。 在线程进入阻塞状态之前，或被唤醒后竞争不到锁的情况下进入自旋状态。 在处理器上空跑并且轮询锁是否被释放。 与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。 JVM 不能根据等待时间的长短来选择自旋还是阻塞。 JVM 采用自适应自旋，根据以往自旋等待时能否获得锁，动态调整自旋时间（循环数目）。 自旋状态的副作用：不公平的锁机制 阻塞状态的线程，没有办法立刻竞争被释放的锁。 自旋状态的线程，很有可能优先获得锁。 轻量级锁 没有锁竞争的情况。 怎样区分轻量级锁和重量级锁？对象头的标记字段（mark word）最后两位用来表示该对象的锁状态。 值 含义 00 轻量级锁 01 无锁或偏向锁 10 重量级锁 11 垃圾回收标记 加锁操作判断是否是重量级锁 判断为非重量级锁 在当前线程的当前栈桢中划出一块空间作为该锁的锁记录。 将锁对象的标记字段复制到锁记录中。 JVM 尝试用 CAS 操作替换锁对象的标记字段。（不懂） 比较标记字段是否为 X…X01 - 是，替换为锁记录地址，成功获得锁，继续执行。 - 否 - 线程重复获得同一把锁，JVM 将锁记录清理，代表锁被重复获取。 - **其他线程持有锁，JVM 将该锁膨胀为重量级锁**，阻塞该线程。 解锁操作锁记录值为 0重复进入同一把锁，直接返回。（不懂） 锁记录值不为 0JVM 尝试用 CAS 操作比较标记字段是否为当前锁记录地址 是，替换为锁记录的值，锁释放。 否，表示锁已膨胀为重量级锁，进入重量级锁释放过程。 偏向锁加锁操作 锁对象支持偏向锁。 JVM 通过 CAS 操作，将当前线程地址记录在锁对象的标记字段，将标记字段最后三位设为 101。 线程请求锁时判断锁对象标记字段： 最后三位是否为 101 是否包含当前线程的地址 epoch 值是否和锁对象的类的 epoch 值相同 都满足则当前线程持有该偏向锁，直接返回。 2 不满足，epoch 值相等时，JVM 需要撤销该偏向锁。 2 满足，epoch 值不等时，当前线程可以将该锁重偏向至自己。 epoch 值 每个类维护一个 epoch 值。 设置偏向锁时，JVM 要将 epoch 值复制到锁对象标记字段中。 撤销偏向锁要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。 某类锁对象撤销数超过一个阈值，JVM 宣布该类偏向锁失效。 宣布偏向锁失效时，JVM 将该类的 epoch 值加 1。 为了保证当前持有偏向锁并且已加锁的线程不丢锁， JVM 遍历所有线程的 Java 栈，找出该类已加锁实例， 将标记字段的 epoch 值加 1（需要所有线程处于安全点状态）。 总撤销数超过另一个阈值 JVM 认为这个类不再适合偏向锁。 JVM 会撤销该类实例的偏向锁， 之后加锁直接设置轻量级锁。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>看不懂</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」13 Java 内存模型]]></title>
    <url>%2F2018%2F08%2F31%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/13484 编译器优化的重排序 保证遵守 as-if-serial 属性。 操作之间存在数据依赖，不能调整顺序。 Java 内存模型与 happens-before 关系 用来描述两个操作的内存可见性。 操作 X happens-before 操作 Y，X 的结果对于 Y 可见。 happens-before 关系具有传递性。 解决这种数据竞争的关键：构造一个跨线程的 happens-before 关系。 线程间的 happens-before 关系： 解锁操作 happens-before 之后（时钟顺序）对同一把锁的加锁操作。 volatile 字段的写操作 happens-before 之后（时钟顺序）对同一字段的读操作。 线程的启动操作（Thread.starts()） happens-before 该线程的第一个操作。 线程的最后一个操作 happens-before 它的终止事件（Thread.isAlive() 或 Thread.join()）。 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。 构造器中的最后一个操作 happens-before 析构器的第一个操作。 Java 内存模型的底层实现 通过内存屏障（memory barrier）禁止重排序。 开不太懂，之后再看]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>未完成</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」11 12 垃圾回收]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1112%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/13091 如何辨别对象是否死亡引用计数法（reference counting） 为每个对象添加一个引用计数器。 为 0 时死亡。 缺点： 需要额外的空间。 更新操作繁琐。 无法处理循环引用对象（a 与 b 相互引用）。 可达性分析GC Roots（由堆外指向堆内的引用）包括不限于： Java 方法栈桢中的局部变量。 已加载类的静态变量。 JNI handles。不懂 已启动且未停止的 Java 线程。 可达性分析算法： 将一系列 GC Roots 作为初始的存活对象合集（live set）。 标记（mark）：从该合集出发，探索所有能够被该集合引用到的对象，将其加入到该集合中。 未被探索到的对象是死亡的，是可以回收的。 需要解决的问题： 在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。 Stop-the-world 停止其他非垃圾回收线程的工作，直到完成垃圾回收。 暂停时间（GC pause）。 安全点（safepoint） 当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。 本地代码的安全点 Java 程序通过 JNI 执行本地代码时，这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法。 API 入口处进行安全点检测（safepoint poll）。 解释执行字节码的安全点 字节码与字节码之间。 有安全点请求时，执行一条字节码进行一次安全点检测。 执行即时编译器生成的机器码 生成机器码时，即时编译器插入安全点检测。 HotSpot 虚拟机：在生成代码的方法出口、非计数循环的循环回边（back-edge）处插入。 阻塞的线程属于安全点。垃圾回收的三种方式清除（sweep） 把死亡对象所占据的内存标记为空闲内存，记录在一个空闲列表（free list）中。 缺点： 造成内存碎片。 堆中对象必须是连续分布的，可能出现总空闲内存足够，无法分配的极端情况。 分配效率较低。 压缩（compact） 把存活的对象聚集到内存区域的起始位置，留下一段连续的内存空间。 缺点： 压缩算法有性能开销。 复制（copy） 把内存区域分为两等分，分别用两个指针 from 和 to 来维护，只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，把存活的对象复制到 to 指针指向的内存区域中，交换 from 指针和 to 指针的内容。 缺点： 1.堆空间的使用效率极其低下。 12 未更新]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>未完成</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」10 Java 对象的内存分布]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/13081 Java 新建对象的方式 new 语句 反射 Object.clone 方法 反序列化 Unsafe.allocateInstance 方法 压缩指针对象头（object header） 每个 Java 对象都有。 由标记字段、类型指针构成。 标记字段：存储 Java 虚拟机有关该对象的运行数据（如哈希码、GC 信息、锁信息）。 类型指针：指向该对象的类。 64 位 Java 虚拟机中，对象头占 16 个字节。 压缩指针 开启压缩指针：-XX:+UseCompressedOops（默认开启）。 将堆中原本 64 位的 Java 对象指针压缩成 32 位。 类型指针也被压缩成 32 位，对象头的大小从 16 字节降至 12 字节。 还可以作用于引用类型的字段，引用类型数组。 内存对齐 虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8。 默认情况，堆中对象（包括字段之间）起始地址要对齐至 8 的倍数。 浪费掉的空间称之为对象间的填充（padding）。 32 位压缩指针可以寻址到 2 的 35 次方个字节（32GB 地址空间，超过 32GB 会关闭压缩指针）。 压缩指针解引用：左移 3 位，再加上一个固定偏移量。 字段内存对齐的一个原因：让字段只出现在同一 CPU 的缓存行中。不懂 字段重排列 Java 虚拟机重新分配字段的顺序，达到内存对齐]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」08 09 JVM 是怎么实现 invokedynamic 的？]]></title>
    <url>%2F2018%2F08%2F10%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0809JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[invokedynamic Java 7 引入的新指令 调用机制抽象出调用点的概念 允许将调用点链接至任意符合条件的方法上 MethodHandle（方法句柄） Java 7 引入 是一个强类型的，能被直接执行的引用 可以指向静态方法、实例方法、构造器、字段 方法句柄的类型（MethodType） 由参数类型、返回类型组成 确认方法句柄是否适配的唯一关键 不关心方法的类名或方法名 方法句柄的创建通过 MethodHandles.Lookup 类 使用反射的 Method 类查找 Lookup.findStatic 查找调用 invokestatic 的方法 Lookup.findVirtual 查找调用 invokevirtual 和 invokeinterface 的方法 Lookup.findSpecial 查找调用 invokespecial 的方法 方法句柄的权限 权限检查在创建阶段完成 实际调用过程中不检查 取决于 Lookup 对象创建位置（不是方法句柄创建位置） 方法句柄的操作invokeExact 严格匹配参数类型（需要显示向上转型） @PolymorphicSignature 根据传入参数的声明类型来生成方法描述符（而不是目标方法） invoke 自动适配参数类型 会调用 MethodHandle.asType 方法生成一个适配器方法句柄 增删改通过生成另一个充当适配器的方法句柄来实现 捕获类型的 Lambda 表达式用增操作实现 增操作可以实现方法的柯里化 方法句柄的实现HotSpot 虚拟机中方法句柄调用的具体实现，只讨论 DirectMethodHandle invokeExact 调用至一个共享的、与方法句柄类型相关的特殊适配器中 适配器是一个 LambdaForm 方法句柄的缺点 与反射一样是简介调用 无法内联 未更新09]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>未完成</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」07 JVM 是如何实现反射的？]]></title>
    <url>%2F2018%2F08%2F06%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-07JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/12192 反射调用的实现Methond.invoke委派给 MethodAccessor 接口处理。 MethodAccessor 两个具体实现： 本地方法实现反射调用 委派模式 委派实现 每个 Method 实例的第一次反射调用会生成一个委派实现。 委派的具体实现是一个本地实现。 Java 的反射调用机制还设立了另一种动态生成字节码的动态实现。 采用委派实现，是为了能够在本地实现以及动态实现中切换。 动态实现 运行效率比本地实现要快 20 倍。 因为动态实现无需经过 Java 到 C++ 再到 Java 的切换。 由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上3到4倍。 InflationJava 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整）。 当某个反射调用的方法调用次数在 15 之下时，采用本地实现。 当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为 Inflation。 反射调用的 Inflation 机制是可以通过参数（-Dsun.reflect.noInflation=true）关闭。 反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。 反射调用的开销反射api性能开销 Class.getMethod 会遍历该类的公有方法。如果没有匹配到，遍历父类的公有方法。 以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。 避免在热点代码中使用返回 Method 数组的方法，减少不必要的堆空间消耗。 反射本身性能开销Method.invoke 是一个变长参数方法。Java 编译器会在方法调用处生成一个长度为传入参数个数的 Object 数组，并将传入参数一一存储进该数组中。 Java 编译器会对传入的基本类型参数自动装箱。Java 缓存了 [-128, 127] 中所有整数所对应的 Integer 对象。 需要自动装箱的整数在这个范围之内时，返回缓存的 Integer，否则需要新建一个 Integer 对象。 解决方法： 扩大缓存范围（对应参数 -Djava.lang.Integer.IntegerCache.high=128）。 在外部缓存自动装箱得到的 Integer 对象。 上面两条除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。 权限检查带来的开销 关闭权限检查。 setAccessible(true) 方法内联 没有方法内联优化 逃逸分析不起效 具体代码具体分析。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」【工具篇】常用工具介绍]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E3%80%90%E5%B7%A5%E5%85%B7%E7%AF%87%E3%80%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/12423 javap：查阅 Java 字节码 javap 是一个能够将 class 文件反汇编成人类可读格式的工具。 选项 作用 -p 追加打印私有字段和方法 -v 尽可能打印所有信息 -c 只打印方法 -g -v 选项输出基本信息 字段 作用 minor version: 0，major version: 54 class 文件的版本号 flags: (0x0021) ACC_PUBLIC, ACC_SUPER 该类的访问权限 this_class: #7 该类名字 super_class: #8 父类名字 interfaces: 0 实现接口数目 fields: 4 字段数目 methods: 2 方法数目 attributes: 1 属性数目 属性：class 文件所携带的辅助信息（class 文件的源文件的名称）。 这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无须深入了解。 class 文件的版本号：编译生成该 class 文件时所用的 JRE 版本。 由较新的 JRE 版本中的 javac 编译而成的 class 文件，不能在旧版本的 JRE 上跑，否则，会出现异常（java.lang.UnsupportedClassVersionError）。 常量池 每一项都有一个对应的索引（如 #1）。 可能引用其他的常量池项（#1 = Methodref #8.#23）。 字段区域 字段 作用 descriptor: I 字段的类型 flags: (0x0002) ACC_PRIVATE 访问权限 声明为 static final 的基本类型或者字符串字段，字段区域包括它的常量值。 方法区域 方法描述符 访问权限 代码区域 代码区域开头声明 字段 作用 stack=2 操作数栈 locals=3 局部变量数目最大值 args_size=1 接收参数的个数 局部变量指的是字节码中的局部变量。 后面接着的是字节码，每条字节码均标注了对应的偏移量（bytecode index，BCI）。 异常表 使用偏移量定位每个异常处理器所监控的范围（由 from 到 to 的代码区域）。 异常处理器的起始位置（target）。 声明所捕获的异常类型（type）。 any 指代任意异常类型。 行数表 Java 源程序到字节码偏移量的映射。 局部变量表 Java 程序中每个局部变量的名字、类型以及作用域。 注：行数表和局部变量表均属于调试信息。Java 虚拟机不要求 class 文件必备这些信息。 字节码操作数栈映射表 字节码跳转后操作数栈的分布情况。 一般被 Java 虚拟机用于验证所加载的类，和即时编译相关的一些操作，正常情况下，无须深入了解。 OpenJDK 项目 Code Tools：实用小工具集ASMTools反汇编操作命令1$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm 汇编操作命令1$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm JOL查阅 Java 虚拟机中对象的内存分布12$ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap ASM：Java 字节码框架 ASM 既可以生成新的 class 文件，也可以修改已有的 class 文件。 辅助类 ASMifier，接收一个 class 文件，输出一段生成该 class 文件原始字节数组的代码。 附录1234567891011121314151617public class Foo &#123; private int tryBlock; private int catchBlock; private int finallyBlock; private int methodExit; public void test() &#123; try &#123; tryBlock = 0; &#125; catch (Exception e) &#123; catchBlock = 1; &#125; finally &#123; finallyBlock = 2; &#125; methodExit = 3; &#125;&#125; 编译后用 javap 查阅字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128$ javac Foo.java$ javap -p -v FooClassfile ../Foo.class Last modified ..; size 541 bytes MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d Compiled from &quot;Foo.java&quot;public class Foo minor version: 0 major version: 54 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #7 // Foo super_class: #8 // java/lang/Object interfaces: 0, fields: 4, methods: 2, attributes: 1Constant pool: #1 = Methodref #8.#23 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #7.#24 // Foo.tryBlock:I #3 = Fieldref #7.#25 // Foo.finallyBlock:I #4 = Class #26 // java/lang/Exception #5 = Fieldref #7.#27 // Foo.catchBlock:I #6 = Fieldref #7.#28 // Foo.methodExit:I #7 = Class #29 // Foo #8 = Class #30 // java/lang/Object #9 = Utf8 tryBlock #10 = Utf8 I #11 = Utf8 catchBlock #12 = Utf8 finallyBlock #13 = Utf8 methodExit #14 = Utf8 &lt;init&gt; #15 = Utf8 ()V #16 = Utf8 Code #17 = Utf8 LineNumberTable #18 = Utf8 test #19 = Utf8 StackMapTable #20 = Class #31 // java/lang/Throwable #21 = Utf8 SourceFile #22 = Utf8 Foo.java #23 = NameAndType #14:#15 // &quot;&lt;init&gt;&quot;:()V #24 = NameAndType #9:#10 // tryBlock:I #25 = NameAndType #12:#10 // finallyBlock:I #26 = Utf8 java/lang/Exception #27 = NameAndType #11:#10 // catchBlock:I #28 = NameAndType #13:#10 // methodExit:I #29 = Utf8 Foo #30 = Utf8 java/lang/Object #31 = Utf8 java/lang/Throwable&#123; private int tryBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int catchBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int finallyBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int methodExit; descriptor: I flags: (0x0002) ACC_PRIVATE public Foo(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public void test(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: iconst_0 2: putfield #2 // Field tryBlock: 5: aload_0 6: iconst_2 7: putfield #3 // Field finallyBlock:I 10: goto 35 13: astore_1 14: aload_0 15: iconst_1 16: putfield #5 // Field catchBlock:I 19: aload_0 20: iconst_2 21: putfield #3 // Field finallyBlock:I 24: goto 35 27: astore_2 28: aload_0 29: iconst_2 30: putfield #3 // Field finallyBlock:I 33: aload_2 34: athrow 35: aload_0 36: iconst_3 37: putfield #6 // Field methodExit:I 40: return Exception table: from to target type 0 5 13 Class java/lang/Exception 0 5 27 any 13 19 27 any LineNumberTable: line 9: 0 line 13: 5 line 14: 10 line 10: 13 line 11: 14 line 13: 19 line 14: 24 line 13: 27 line 14: 33 line 15: 35 line 16: 40 StackMapTable: number_of_entries = 3 frame_type = 77 /* same_locals_1_stack_item */ stack = [ class java/lang/Exception ] frame_type = 77 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ] frame_type = 7 /* same */&#125;SourceFile: &quot;Foo.java&quot;]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」LayoutInflater 中 inflate 方法各参数作用]]></title>
    <url>%2F2018%2F08%2F03%2FLayoutInflater%E4%B8%ADinflate%E6%96%B9%E6%B3%95%E5%90%84%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文：三个案例带你看懂LayoutInflater中inflate方法两个参数和三个参数的区别 三个参数的方法inflate(@LayoutRes int, @Nullable ViewGroup, boolean):View 第二个参数不为 null 且第三个参数为 true 指定 id 布局根布局节点各个属性有效 添加到父布局 第二个参数不为 null 且第三个参数为 false 指定 id 布局根布局节点各个属性有效 不添加到父布局 第二各参数为 null 指定 id 布局根布局节点宽高属性无效 两个参数的方法inflate(@LayoutRes int, @Nullable ViewGroup):View 第二个参数不为 null等同于第二个参数不为 null 且第三个参数为 true 第二个参数为 null等同于第二各参数为 null]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Java 中进制转换]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E4%B8%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[十进制转二、八、十六进制Integer.toBinaryString():String Integer.toOctalString():String Integer.toHexString():String 返回值为字符串。 任意进制转十进制Integer.valueOf(String,int):Integer Integer.parseInt(String,int):int 第二个参数指定基数，将字符串参数解析为有符号的整数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Android 透明状态栏与沉浸模式总结]]></title>
    <url>%2F2018%2F08%2F02%2FAndroid%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E6%B2%89%E6%B5%B8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原文 Android状态栏微技巧，带你真正理解沉浸式模式 Android全屏，隐藏状态栏和标题栏 Android透明状态栏与沉浸模式全解 Java 实现通过Java 代码实现的思路是通过当前界面 DecorView 设置 UI 可见性实现。 flag 作用 SYSTEM_UI_FLAG_FULLSCREEN 请求进入普通全屏模式 SYSTEM_UI_FLAG_HIDE_NAVIGATION 请求暂时隐藏系统导航栏 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION SYSTEM_UI_FLAG_LAYOUT_STABLE 当使用其他布局标志时，提供内容插入的稳定视图 SYSTEM_UI_FLAG_IMMERSIVE_STICKY 通过组合上面的 6 中 flag 实现各种效果 隐藏状态栏支持 Android 4.1 及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN;getWindow().getDecorView().setSystemUiVisibility(option); 注：下滑顶部会重新显示 透明状态栏支持 Android 5.0 及以上 123int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;getWindow().getDecorView().setSystemUiVisibility(option);getWindow().setStatusBarColor(Color.TRANSPARENT); 隐藏状态栏及导航栏支持 Android 4.1 及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;getWindow().getDecorView().setSystemUiVisibility(option); 注：点击屏幕会退出全屏 透明状态栏及透明导航栏支持 Android 5.0 及以上 1234int option = int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;getWindow().getDecorView().setSystemUiVisibility(option);getWindow().setStatusBarColor(Color.TRANSPARENT);getWindow().setNavigationBarColor(Color.TRANSPARENT); 沉浸模式支持 Android 4.4 及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;getWindow().getDecorView().setSystemUiVisibility(option); 注：滑动状态栏或导航栏的位置显示状态栏和导航栏，一段时间未操作再次隐藏 XML 实现通过设置 activity 的 style 实现 隐藏状态栏1234&lt;style name="AppTheme" parent="@style/Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowFullscreen"&gt;true&lt;/item&gt;&lt;/style&gt; 透明状态栏Android 4.4 1234&lt;style name="fullScreenTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;&lt;/style&gt; 如果添加了 DrawerLayout 需要设置，否则 DrawerLayout 部分状态栏是灰色的。 12mDrawerLayout.setFitsSystemWindows(true);mDrawerLayout.setClipToPadding(false); Android 5.0 12345&lt;style name="fullScreenTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>状态栏</tag>
        <tag>沉静模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」获取 Activity 根布局]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%8E%B7%E5%8F%96Activity%E6%A0%B9%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1findViewById(android.R.id.content).getChildAt(0)；]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」如何修改 ActionBar 的字体颜色？]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9ActionBar%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[123456789101112&lt;style name="AppTheme" parent="@style/Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="actionBarStyle"&gt;@style/ActionBarStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="ActionBarStyle" parent="@style/Widget.AppCompat.ActionBar.Solid"&gt; &lt;item name="titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="TitleTextStyle" parent="@style/TextAppearance.AppCompat.Widget.ActionBar.Title"&gt; &lt;item name="android:textColor"&gt;#000000&lt;/item&gt; &lt;!-- 这里设置ActionBar字体颜色 --&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」06 JVM 是如何处理异常的？]]></title>
    <url>%2F2018%2F08%2F01%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-06JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/12134 异常的基本概念 Error：涵盖程序不应捕获的异常（JVM 抛出）。 程序出发 Error 时，执行状态已经无法恢复，需要终止线程甚至终止虚拟机。 Exception：涵盖程序可能需要捕获且处理的异常。 RuntimeException：表示“程序虽然无法继续执行，但是还能抢救一下”的情况。 RuntimeException 和 Error 非检查异常（unchecked exception）。其他异常属于检查异常（checked exception）。 检查异常需要程序显式地捕获，或者在方法声明中用 throws 关键字再次抛出。 常实例的构造十分昂贵。在构造异常实例时，Java 虚拟机需要生成该异常的栈轨迹（stack trace）。 逐一访问当前线程的 Java 栈帧。 记录下各种调试信息（方法名，方法所在类名，文件名，代码中第几行）。 Java 虚拟机会忽略异常构造器和填充栈帧的Java方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。 Java 虚拟机会忽略标记为不可见的 Java 方法栈帧。 是否可以缓存异常实例，在需要用到的时候直接抛出？ 从语法角度上，是允许的。 对应的栈轨迹并非 throw 语句的位置，而是新建异常的位置。 Java 虚拟机是如何捕获异常的？编译生成的字节码中，每个方法都附带一个异常表。 异常表中每一个条目代表一个异常处理器。 异常处理器的组成： from 指针 to 指针 target 指针 所捕获的异常类型 注：指针的值是字节码索引（bytecode index，bci），用来定位字节码。 from 指针和 to 指针：标示异常处理器所监控的范围（如 try 代码块范围）。 target 指针：指向异常处理器的起始位置（如 catch 代码块起始位置）。 触发异常的处理流程 Java 虚拟机从上至下遍历异常表中的所有条目。 触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机判断所抛出的异常和该条目想要捕获的异常是否匹配。 如果匹配，Java 虚拟机将控制流转移至该条目 target 指针指向的字节码。 如果遍历完所有异常表条目，仍未匹配到异常处理器，弹出当前方法对应的 Java 栈帧，在调用者（caller）中重复上述操作。 finally 代码块的编译，当前版本 Java 编译器，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径和异常执行路径的出口中。 针对异常执行路径，Java 编译器会生成一个或多个异常表条目，监控整个 try-catch 代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。 这些异常表条目的 target 指针将指向另一份复制的 finally 代码块。 在这个 finally 代码块的最后，Java 编译器会重新抛出所捕获的异常。 如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛后者，忽略前者。 Java 7 的 Suppressed 异常以及语法糖Suppressed 异常允许将一个异常附于另一个异常之上。 抛出的异常可以附带多个异常信息。 finally 代码块缺少指向所捕获异常的引用，这个新特性使用起来非常繁琐。 try-with-resources1try ( ); // try-with-resources 在字节码层面自动使用 Suppressed 异常。 自动关闭资源（实现 AutoCloseable 接口）。 同一 catch 代码块捕获多种异常12345try &#123; &#125; catch (SomeException | OtherException e) &#123; &#125;]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」传输层和应用层的协议和作用]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%BD%AC-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转自：五.传输层和应用层的协议和作用 TCP/IP 传输层概述TCP/IP 是指一整套数据通信协议，传输层完成端到端的连接和传输。 TCP/IP 传输层包含的两个协议 传输控制协议 Transmission Control Protocol —— TCP 用户数据报协议 User Dategram Protocol —— UDP 常用的 TCP 端口及应用TCP 在网络中使用的范围很广，下面将列出一些常用的端口号及其功能.以便进一步对 TCP 进行检测和管理。 端口 协议 说明 80 http web服务器所开放的进程端口,用于客户端http访问 21 FTP FTP服务器所开放的控制端口,用于上传下载 23 Telnet 用于远程登录,通过连接目的计算机的这一端口,得到验证后可以远程控制管理目标计算机 25 SMTP SMTP服务器开放的端口,用于发送邮件 53 DNS DNS服务器开放的端口,当用户输入网站的名称后,由DNS负责将它解析成IP地址,这个过程中用到的端口号就是53 常用的 UDP 端口及应用 端口 协议 说明 7 Echo 将收到的数据包回送到发送器 53 Nameserver 域名服务 69 TFTP 简单文件传输协议 111 RPC 远程过程调用 123 NTP 网络时间协议 常用的应用层协议 缩写 全文 http 超文本传送协议 https 基于安全套接字层的http协议 ftp 文件传输协议 dns 域名系统 smtp 邮件传输协议 pop3 邮局协议 ssh 安全外壳协议 HTTP用于传输 Internet 浏览器使用的普通文本,超文本,音频和视频等数据 端口号：TCP 的 80 HTTPS基于 HTTP 开发,提供加密,可以确保消息的私有性和完整性 端口号：443 FTP用于传输文件 端口号：TCP 的 21 和 20 DNS用来完成域名和 IP 地址之间的映射 端口号：TCP 或 UDP 的 53 SMTP用于发送和接收邮件 端口号：25 POP3用于客户端接收邮件 端口号：110 SSH建立在应用层和传输层基础上的安全协议，ssh 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 ssh 协议可以有效防止远程管理过程中的信息泄漏问题。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」04 05 JVM 是如何执行方法调用的？]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0405JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文 https://time.geekbang.org/column/article/11539 https://time.geekbang.org/column/article/12098 重载和重写在 Java 程序里，同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。这个限制可以通过字节码工具绕开。在编译完成之后，可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。 重载的方法在编译过程中即可完成识别Java 编译器根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法： 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing）和可变长参数的情况下选取重载方法。 在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法。 在允许自动装拆箱和可变长参数的情况下选取重载方法。 如果 Java 编译器在同一阶段多种适配方法，会在其中选择一个最贴切的方法。 决定贴切程度的关键之一是形式参数类型的继承关系。 重载可以作用于这个类所继承而来的方法如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。 如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同： 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。 如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法（重写可以扩大访问权限，但不能缩小）。 注：如果子类定义了与父类中私有方法同名的方法，这两个方法之间没有任何关系。 JVM 的静态绑定和动态绑定Java 虚拟机识别方法的关键：类名、方法名和方法描述符（method descriptor）。 方法描述符 = 方法的参数类型+返回类型所构成 在同一个类中， 出现多个名字相同且描述符也相同的方法 Java 虚拟机在类的验证阶段报错。 不限制名字与参数类型相同但返回类型不同的方法出现。 Java虚拟机判定方法重写： 子类定义了与父类中非私有、非静态方法同名的方法。 方法名和方法描述符都相同。 Java 语言中重写而 Java 虚拟机中非重写的情况： 编译器通过生成桥接方法来实现 Java 中的重写语义。 重载方法的区分在编译阶段已经完成，可以认为 Java 虚拟机不存在重载概念。 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。 Java 虚拟机中的静态绑定：在解析时便能够直接识别目标方法。 Java 虚拟机中的动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法。 Java 字节码中与调用相关的指令共有五种： invokestatic：用于调用静态方法。 invokespecial：用于调用私有实例方法、构造器，使用 super 调用父类的实例方法或构造器，和所实现接口的默认方法。 invokevirtual：用于调用非私有实例方法。 invokeinterface：用于调用接口方法。 invokedynamic：用于调用动态方法。 invokestatic 和 invokespecial：Java 虚拟机能够直接识别具体的目标方法（静态绑定）。 invokevirtual 和 invokeinterface：在绝大部分情况下，虚拟机需要在执行过程中根据调用者的动态类型，来确定具体的目标方法（动态绑定）。 例外：如果虚拟机能够确定目标方法有且仅有一个（如目标方法被标记为 final），可以不通过动态类型，直接确定目标方法（虚拟机可以静态绑定该方法）。 调用指令的符号引用符号引用存储在 class 文件的常量池之中。 符号引用分为：接口符号引用和非接口符号引用。 非接口符号引用该符号引用所指向的类为 C，Java 虚拟机查找步骤： 在 C 中查找符合名字及描述符的方法。 在 C 的父类中继续搜索，直至 Object 类。 在 C 所直接实现或间接实现的接口中搜索。 这一步搜索得到的目标方法必须是非私有、非静态的。 如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。（假如C实现了 I，I 继承 I1，I1 继承 I2，那么 C 和 I2 之间就隔着 I 和 I1） 经过上述的解析步骤之后，符号引用会被解析成实际引用。 静态绑定的方法调用：实际引用是一个指向方法的指针。 动态绑定的方法调用，实际引用是一个方法表的索引。 接口符号引用该符号引用所指向的接口为 I，Java 虚拟机查找步骤： 在 I 中查找符合名字及描述符的方法。 在 Object 类中的公有实例方法中搜索。 在 I 的父接口中搜索。 这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。 虚方法调用Java 里： 所有非私有实例方法调用被编译成 invokevirtual 指令 所有接口方法调用都被编译成 invokeinterface 指令。 Java 虚拟机实现动态绑定的策略为每个类生成一张方法表，用以快速定位目标方法（空间换取时间）。 方法表 类加载的准备阶段除了为静态字段分配内存之外，还会构造与该类相关联的方法表。 下面以虚方法表为例（virtual method table，vtable），接口方法（interface method table，itable）表原理类似，但稍复杂。 方法表本质：数组（元素指向一个当前类及其祖先类中非私有的实例方法）。 方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。 方法表满足两个特质： 子类方法表中包含父类方法表中的所有方法。 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。 动态绑定： Java 虚拟机将获取调用者的实际类型。 在该实际类型的虚方法表中根据索引值获得目标方法。 是否可以认为虚方法调用对性能没有太大影响？不能，上述优化实际上仅存在最坏情况中。 即时编译有两种性能更好的优化手段： 内联缓存（inlining cache） 方法内联（method inlining） 内联缓存 缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。 单态（monomorphic）指的是仅有一种状态的情况。 多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。 超多态（megamorphic）指的是更多种状态的情况。通常用一个具体数值来区分多态和超多态。 对于内联缓存: 单态内联缓存 多态内联缓存 超多态内联缓存 在实践中，大部分的虚方法调用均是单态的。 为了节省内存空间，Java 虚拟机只采用单态内联缓存。 内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定，有两种选择： 替换单态内联缓存中的纪录。 劣化为超多态状态（Java 虚拟机的具体实现方式）。 直接访问方法表，牺牲了优化的机会，节省了写缓存的额外开销。 内联缓存并没有内联目标方法。 任何方法调用除非被内联，否则都会有固定开销。 开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。 问题Q：public final 或 public static final 的方法，是不是在虚拟机中解析为静态绑定的。 A：静态方法都是静态绑定。调用的目标方法是 public final 的话，HotSpot 虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」03 Java 虚拟机是如何加载 Java 类的？]]></title>
    <url>%2F2018%2F07%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-03Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/11523 Java 语言的类型：基本类型（primitive types）和引用类型（reference types）。 基本类型由 Java 虚拟机预先定义好。 引用类型：类、接口、数组类和泛型参数。 泛型参数会在编译过程中被擦除，Java 虚拟机上实际只有三种。 数组类是由 Java 虚拟机直接生成，其他两种有对应的字节流。 字节流形式： class 文件。 程序内部直接生成。 从网络中获取。 字节流加载到 Java 虚拟机中，成为类或接口。 加载 查找字节流，并且据此创建类的过程。 对于数组类，它没有对应的字节流，由 Java 虚拟机直接生成。 对于其他类，Java 虚拟机需要借助类加载器完成查找字节流的过程。 java 9 之前启动类加载器（boot class loader）启动类加载器由 C++ 实现，没有对应的 Java 对象，Java 中只能用 null 来指代。 启动类加载器加载最为基础、最为重要的类。如：存放在 jre 的 lib 目录加 jar 包中的类（以及由虚拟机参数-Xbootclasspath 指定的类） 其他类加载器都是 java.lang.ClassLoader 的子类。类加载器需要先由另一个类加载器加载至 Java 虚拟机中，才能执行类加载。 扩展类加载器（extension class loader）父类加载器：启动类加载器。 加载相对次要、但又通用的类。如：存放在 jre 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。 应用类加载器（application class loader）父类加载器：扩展类加载器。 加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 java 9 之后Java 9 引入了模块系统，并且略微更改了上述的类加载器。 扩展类加载器被改名为平台类加载器（platform class loader）。 Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。 双亲委派模型没当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类情况下，该类加载器才会尝试去加载。 注：父类加载器不是继承关系！！！ 其他 可以加入自定义的类加载器，来实现特殊的加载方式。 如：可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。 类加载器还提供了命名空间的作用。 在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。 即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。 链接 将创建成的类合并至 Java 虚拟机中，使之能够只够执行的过程。它可分为验证、准备以及解析三个阶段。 验证 确保被加载类能够满足 Java 虚拟机的约束条件。 通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。 准备 为被加载类的静态字段分配内存。 部分 Java 虚拟机会在此阶段构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表。 解析（非必需）在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类（甚至自己）的方法、字段所对应的具体地址。引用时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。 将这些符号引用解析成为实际引用。 如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。） Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。 初始化如果直接赋值的静态字段： 被 final 所修饰 类型是基本类型或字符串时 该字段便会被 Java 编译器标记成常量值（ConstantValue），初始化直接由 Java 虚拟机完成。 除此之外的直接赋值操作，所有静态代码块中的代码，会被 Java 编译器置于同一方法中，并把它命名为 &lt;clinit>。 &lt;clinit> 方法仅被执行一次。 JVM 规范枚举了下述多种触发类初始化的情况： 当虚拟机启动时，初始化用户指定的主类。 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类。 当遇到调用静态方法的指令时，初始化该静态方法所在的类。 当遇到访问静态字段的指令时，初始化该静态字段所在的类。 子类的初始化会触发父类的初始化。 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化。 使用反射 API 对某个类进行反射调用时，初始化这个类。 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 问题Q：加载阶段都加载哪些类呢，那么多类，全部加载吗？ A：加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。 Q：有一个零值 (0/null) 初始化，针对于类的静态成员变量，如果是 final 修饰的静态成员变量，也就是常量，是初始化为代码中指定的值比如 10。非 final 修饰的静态成员变量，在 clinit 执行过程中赋值为代码中指定的值，是这样的吗？ A：被 final 修饰的静态成员变量，如果不是基本类型或者字符串，也会放在 clinit 来做。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」02 Java 的基本类型]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-02Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[原文：https://time.geekbang.org/column/article/11503 在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。 Java 则不同，它引进了八个基本类型，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。 Java虚拟机的 boolean类型123456789public class Foo &#123; public static void main(String[] args) &#123; boolean 吃过饭没 = 2; // 直接编译的话 javac 会报错 if (吃过饭没) System.out.println(" 吃了 "); if (true == 吃过饭没) System.out.println(" 真吃了 "); &#125;&#125; Java 语言规范中，boolean 类型的值只有两种，用 true 和 false 表示。 Java虚拟机规范中，boolean 类型被映射成 int 类型，true 映射为整数1，false 映射为整数 0。 123456789101112131415# Foo.main 编译后的字节码 0: iconst_2 // 我们用 AsmTools 更改了这一指令 1: istore_1 2: iload_1 3: ifeq 14 // 第一个 if 语句，即操作数栈上数值为 0 时跳转 6: getstatic java.lang.System.out 9: ldc &quot; 吃了 &quot;11: invokevirtual java.io.PrintStream.println14: iload_115: iconst_116: if_icmpne 27 // 第二个 if 语句，即操作数栈上两个数值不相同时跳转19: getstatic java.lang.System.out22: ldc &quot; 真吃了 &quot;24: invokevirtual java.io.PrintStream.println27: return 在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。 而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。 Java的基本类型 默认值在内存中，默认值都是 0。 取值范围 boolean 和 char 是唯二的无符号类型。 boolean 类型的取值范围是 0 或 1。 char 类型的取值范围是 [0, 65535]。 boolean, byte, char, short 的局部变量储存可以超过取值范围。 正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束。 浮点数浮点数类型采用 IEEE 754 浮点数格式。 以 float 为例，浮点类型通常有两个 0，+0.0F 和 -0.0F。 在 Java 里，前者为 0，后者符号位为 1，其他位为 0。 虽然内存数值不同，但 +0.0F == -0.0F 会返回 true。 123float a = +0.0f;float b = -0.0f;float c = Float.intBitsToFloat(0x80000000); 在内存中，正无穷等于 0x7F800000，负无穷等于 0xFF800000。 [0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应 NaN （Not-a-Number）。 一般我们计算得出的NaN（+0.0F/+0.0F），在内存中为 0x7FC00000。 这个数值称为标准的 NaN，其他的称为不标准的 NaN。 NaN 有一个特性：“!=” 始终返回 true，其他比较结果都回返回 false。 Java 基本类型的大小Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧，这里只讨论供解释器使用的解释栈帧（interpreted frame）。 解释栈帧这种栈帧有两个主要组成部分：广义的局部变量区，字节码的操作栈。 广义局部变量包含：普遍意义的局部变量，this 指针，方法参数。 局部变量在 Java 虚拟机规范中，局部变量区等价于一个数组。除了 long、double 的值用两个数组单元存储，其他基本类型以及引用类型的值均占用一个数组单元。 boolean、byte、char、short 在栈上占用的空间和 int、引用类型一样。32 位 HotSpot 中占用 4 字节，64 位 HotSport中，占用 8 字节。这种情况仅存在于局部变量，不会出现在存储于堆中的字段或数组元素。 存储将 int 类型的值存到其他类型的字段或数组时，相当于做了一次隐式的掩码操作。 把 0xFFFFFFFF(-1)储存到一个声明为 char 类型的字段里时，高两位字节被截取掉，存入“\uFFFF”。 HotSpot 在存储 boolean 时显示进行掩码操作，只取最后一位的值存入 boolean 字段或数组中。 HotSpot 中 boolean 字段占用一字节，boolean 数组直接用 byte 数组实现。 加载Java 虚拟机的算数运算几乎全部依赖于操作数栈，堆中的 boolean、byte、char 和 short 加载到操作数栈上，当成 int 类型运算。 对于 boolean、char 这两个无符号类型，加载伴随零扩展。 对于 byte、short 加载伴随符号扩展。 将 boolean 类型的值存入字段中时，Java 虚拟机所做的掩码操作123456789101112public class Foo &#123; static boolean boolValue; public static void main(String[] args) &#123; boolValue = true; // 将这个 true 替换为 2 或者 3，再看看打印结果 if (boolValue) System.out.println("Hello, Java!"); if (boolValue == true) System.out.println("Hello, JVM!"); &#125;&#125; 当替换为 2 的时候无输出 当替换为 3 的时候打印 HelloJava 及 HelloJVM 因为将 boolean 保存在静态域中,指定了其类型为 ‘Z’,当修改为 2 时取低位最后一位为 0,当修改为3时取低位最后一位为 1 则说明 boolean 的掩码处理是取低位的最后一位 问题Q：“也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。” 但是我记得 boolean 在内存中占 1 字节，char 占 2 字节，这里是什么个意思？ A：你说的是在堆里的情况。在解释器栈上是不一样的。至于原因吗，主要是变长数组不好控制，所以就选择浪费一些空间，以便访问时直接通过下标来计算地址。 Q：使用基本类型能够在执行效率以及内存使用两方面提升软件性能。具体是什么原理呢？ A：占的空间更小，不需要类型转换。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深入拆解 Java 虚拟机」01 Java 代码是怎么运行的？]]></title>
    <url>%2F2018%2F07%2F27%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-01Java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文 https://time.geekbang.org/column/article/11289 https://blog.csdn.net/zly921112/article/details/61192747 为什么 Java 要在虚拟机里运行？ Java 作为一门高级程序语言，语法复杂，抽象程度高，直接在硬件上运行这种复杂的程序不现实。 Java 虚拟机既可以硬件实现也可以软件实现，常见平台上都是软件实现，意义：“一次编写，到处运行”。 虚拟机提供了托管环境。能代替我们处理一些代码中冗长而且容易出错的部分。如：自动内存管理，垃圾回收，提供如数组越界、动态类型、安全权限等的动态检测。 Java 虚拟机具体怎样运行 Java 字节码的？下面以标准 JDK 中的 HotSpot 虚拟机为例。 Java 虚拟机会在内存中划分出堆（stack）、栈（heap）和方法区（method） 其中栈细分为： 面向 Java 方法的Java方法栈 面向本地方法的本地方法栈 各个线程执行位置的 PC 寄存器 class 文件加载后存放于方法区，运行时执行方法区内的代码。 堆区 提供所有类实例和数组对象存储区域。 JVM 只有一个堆区（heap）被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。 栈区 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用（不是对象），对象都存放在堆区中。 每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。 方法区 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的 class 和 static 变量。 方法区中包含的都是在整个程序中永远唯一的元素，如 class，static 变量。 运行时常量池都分配在 Java 虚拟机的方法区之中。 Java 方法调用过程 进入一个 Java 方法，在当前线程的 Java 方法栈中生成一个栈帧。 栈帧的大小提前计算好。 存放局部变量和字节码的操作数。 不要求栈帧在内存中连续分布。 退出方法（正常或异常），弹出当前线程的当前栈帧，并舍弃。 Java字节码无法直接执行，要翻译成机器码。 HotSpot 翻译字节码的两种形式解释执行逐条将字节码翻译成机器码并执行。 无需等待编译。 即时编译Just-In-Time compilation, JIT 将方法中包含的所有字节码编译成机器码后再执行。 实际运行速度更快。 HotSpot默认采用混合模式。先解释执行，热点代码以方法为单位即时编译。 Java虚拟机的运行效率究竟是怎样的？即时编译建立再程序符合二八定律的假设上。 HotSpot 内置了多个即时编译器：C1、C2 和 Graal。 GraalJava 10 正式引入的实验性编译器。 C1（Client 编译器） 面向客户端 GUI 程序。 对启动性能有要求。 优化手段相对简单。 编译时间短。 C2（Server 编译器） 面向服务端程序。 对峰值性能有要求。 优化手段相对复杂。 编译时间较长。 生成代码执行效率较高。 Java 7 开始，HotSpot 默认采用分层编译： 热点方法被 C1 编译。 热点方法中的热点进一步被 C2 编译。 HotSpot 的即时编译放在额外的编译线程中。 HotSpot根 据 CPU 数量设置编译线程数目。 1:2 的比例配置 C1 和 C2。 资源充足的情况下，解释执行和即时编译可同行进行。 Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同？1234567891011121314$ echo &apos;public class Foo &#123; public static void main(String[] args) &#123; boolean flag = true; if (flag) System.out.println(&quot;Hello, Java!&quot;); if (flag == true) System.out.println(&quot;Hello, JVM!&quot;); &#125;&#125;&apos; &amp;gt; Foo.java$ javac Foo.java$ java Foo$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &amp;gt; Foo.jasm.1$ awk &apos;NR==1,/iconst_1/&#123;sub(/iconst_1/, &quot;iconst_2&quot;)&#125; 1&apos; Foo.jasm.1 &amp;gt; Foo.jasm$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm$ java Foo JVM 把 boolean 当做 int 来处理 flag = iconst_1 = true awk 把stackframe 中的 flag 改为 iconst_2 if（flag）比较时 ifeq 指令做是否为零判断，常数 2 仍为 true，打印输出 if（true == flag）比较时 if_cmpne 做整数比较，iconst_1 是否等于 flag，比较失败，不再打印输出 问题Q：对于服务端，很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。为什么不把 java 代码全部编译成机器码？如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益。 A：对于这种发布频率不频繁(也就是长时间运行吧？)的程序，其实选择线下编译和即时编译都一样，因为至多一两个小时后该即时编译的都已经编译完成了。另外，即时编译器因为有程序的运行时信息，优化效果更好，也就是说峰值性能更好。 A：解释执行，执行时才翻译成机器指令，无需保存不占内存。但即时编译类似预编译，编译之后的指令需要保存在内存中，这种方式吃内存，按照二八原则这种混合模式最恰当的，热点代码编译之后放入内存避免重复编译，而其他运行次数较少代码则解释执行，避免占用过多内存。 Q：什么时候使用 C1，什么时候使用 C2，他是怎么区分热点方法的呢？ A：JVM 会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)默认的分层编译应该是达到两千调 C1，达到一万五调 C2。]]></content>
      <categories>
        <category>《深入拆解 Java 虚拟机》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Android 的性能优化方法]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[布局优化 LinearLayout 与 RelativeLayout 作用相同时使用 LinearLayout。 LinearLayout 需要嵌套时使用 RelativeLayout。 使用 ConstraintLayout。 &lt;include> 标签 只支持 android:layout_ 开头的属性（android:id 是特例）。 &lt;include> 指定了 id 属性，包含的布局文件根元素也指定了 id 属性，以 &lt;include> 指定的为准。 &lt;merge> 标签 配合 &lt;include> 标签使用可以减少布局的层级。 ViewStub 继承自 View，宽高都是 0 ，本身不参与任何的布局和绘制过程。 按需加载所需的布局文件（如网络异常时的界面），使用的时候再加载，提高初始化性能。 不支持 &lt;merge> 标签。 使用 inflatedId 属性指定加载的布局 id。 123&lt;ViewStub android:id="@+id/stub_import" android:inflatedId="@+id/panel_import" /&gt; 怎样加载？1((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); 或 1View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 加载后 ViewStub 不在属于布局，为 null。 绘制优化onDraw 方法 不要创建新的布局对象。 不要做耗时的任务。 内存泄漏优化静态变量导致的内存泄漏 静态变量引用 Context。 静态变量引用 View（持有 Context）。 单例模式导致的内存泄漏 单例模式保存某个监听器（由 Context 实现）而没有解注册的方法。 属性动画导致的内存泄漏 无限循环的属性动画，Activity 在 onDestroy 中需要停止动画（否则动画会一直播放，动画持有 View，View 持有 Activity，Activity 不能被释放）。 响应速度优化 核心思想：避免在主线程中做耗时操作。 一个进程发生 ANR 之后，系统会在 /data/anr 目录下建一个文件 traces.txt。 ListView 优化 别优化了，直接用 RecyclerView，同理 GridView。 Bitmap 优化未更新 线程优化 采用线程池，避免大量的 Thread。 其他 避免创建过多对象。 不要过多使用枚举，枚举占用的内存空间比整形大。 常量使用 static final 修饰。 Android 特有的数据结构有更好的性能(SparseArray，Pair 等)。 适当使用软引用和弱引用。 采用内存缓存和磁盘缓存。 尽量采用静态内部类。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>未完成</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Android 架构——Clean]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94Clean%2F</url>
    <content type="text"><![CDATA[原文 https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html https://www.jianshu.com/p/c6a1a5c9a49b https://blog.csdn.net/YANGDAHUAN/article/details/80388849 https://www.jianshu.com/p/552c3a1c5fe5 https://www.jianshu.com/p/e0258ce7d392 Clean 架构的主要特点： 框架独立 容易测试 UI 独立 数据库独立 不依赖任何中介 Clean 的主要思想是外层依赖内层，内层完全不依赖外层（或者说内层不知道外层的存在，可以独立开发，复用性强）。 Clean 架构解析 Enterprise Business Rules：业务对象 Application Business Rules：用于处理我们的业务对象，业务逻辑所在，也称为 Interactor Interface Adapters： 接口转换，拿到我们需要的数据，主持者层（Presenters）和控制层（Controllers）就在这一层 Frameworks and Drivers: 这里是所有具体的实现了：比如：UI，工具类，基础框架等等。 Clean 框架不一定只有 4 层，这里以 4 层为例。 上面可能比较抽象，下面是简单的说法： 第一层：实体类 第二层：也叫 UseCase 层，实现具体业务逻辑。 第三层：如果是 MVP 这一层为 Presenter，MVC 这一层为Controller。 第四层：具体实现。 内层均为纯 Java 代码，只需要 jvm 便可以运行。 内层代码不仅可以在 Android 平台，还可以在别的 Java 平台复用。 各层单独测试，各层之间通过接口通信，且独立，方便单元测试。 层与层之间完全隔离，最主要的体现就是各层有自己的数据结构，不同层之间相互转换，完全没有依赖关系。 通过依赖注入的方式导致灵活修改逻辑、实现，这点与 MVP 的思想相似，Clean 与 MVP 和 Dagger 结合使用是天然合适的。 以 mvp-clean 为例，与纯 mvp 最主要的区别就是 Presenter 层剥离出 UserCase 层，一是方便测试，二是方便代码复用，减少 Presenter 层的代码冗余。 Google Demo —— todo-mvp-clean 解析 demo 地址：https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/mvp-clean 基于 mvp，加了 domain layer 介于 presentation 和 repositories。同时也将整个 app 分为三个层次处理。 mvp-clean 层次图 Presentation 层 : MVP 设计准则。 Domain 层 : 处理所有的业务逻辑，注意是所有的业务逻辑。对应 use case（interactors）。 Data 层 : 获取数据，以及数据的存储，分为本地和远程。 基本概念（摘自 mvp-clean GitHub 主页部分原文翻译） mvp-clean 和 基本的 mvp 最大的区别就是在 domain 层和 UseCase 的使用上。从 presenter 层分离出 domain 层好处是可以减少代码的冗余。 UseCase 的好处是在 domain 的代码层上可以复用。CompleteTask 在 TaskDetailPresenter 和 TasksPresenter 做到了很好的复用。 domain layer 是完全解耦与 Android 层和第三方依赖的。是一个纯 java 层的处理。 UseCase 从主线程剥离出来，对于 Android app 是个好的操作。这种操作是尽可能的减少占用 UI 线程。我们决定使用 command pattern 将 use case 在线程池里执行操作。同样的我们可以用 RxJava 或者 Promises 实现同样的功能。 我们使用异步的 repositories 。 但是现在没有必要这么做了。因为 UseCase 已经从主线程里剥离出来了。这是尽量保持 samples 和原来的是一致的。 项目主要关系图 具体用例流程未完待续。。。 思考纯 MVP 架构会使项目变得复杂，Clean 架构则会更复杂，大项目可以使项目的结构清晰，内层复用性强，便于测试。 小项目则会使项目过于复杂，反而使项目结构显得不清晰，就像 MVVM 不适合小型项目一样。MVP 作为万金油可以说适合大部分项目，我个人的思考是小型项目使用 MVP 架构，但在 MVP 的基础上加入部分 Clean 的思想。 从 Presenter 层分离出 UseCase 层，方便代码复用 各层独立，这里有一点需要注意，Clean 中各层有各层的数据结构，在实际项目中各层可能写出类似的实体类，这里可以考虑只写一个通用实体类的作为最内层，虽然违背了 Clean 各层完全独立的思想，但是可以减少部分冗余，这一点根据自己项目来缺点。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
        <tag>Clean</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」5 种写法实现单例模式]]></title>
    <url>%2F2018%2F07%2F22%2F5%E7%A7%8D%E5%86%99%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文： 在java中写出完美的单例模式 设计模式（二）单例模式的七种写法 饿汉式12345678910public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 饿汉式在类加载时初始化。 优点： 简单。 天生线程安全。 缺点： 初始化时机不能由开发者控制，初始化太早造成资源的浪费。 初始化依赖于其他数据，难以控制其他数据是否准备好。 懒汉式12345678910111213141516public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; EventBus 使用的方式。 优点： 第一次使用时加载，避免了资源浪费。 缺点： 复杂。 即使是双重检查有时也会失效（可能性极低）。 静态内部类模式123456789101112public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125; &#125; 《Effective Java》第一版中推荐的写法。 内部类加载时初始化，内部类在第一次被调用时类加载。 优点： 简单。 巧妙的利用内部类实现线程安全。 枚举模式123public enum Singleton &#123; INSTANCE;&#125; 《Effective Java》第二版中推荐的写法。 优点： 极简。 线程安全。 绝对完美单例，可以抵御反序列化、反射。 缺点： 降低可读性。 无法被继承，降低扩展性。 容器模式12345678910111213141516public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125; &#125; public static ObjectgetService(String key) &#123; return objMap.get(key) ; &#125;&#125; 使用单例管理器统一管理所有单例，可以使用统一接口实现操作，这里只是写了简单的实现，没有优化获取操作，没有优化线程。 优点： 方便统一管理。 降低耦合。 缺点： 不能及时找到获取途径，增加开发者的学习成本。 未得到广泛认可。 总结本文一共提供了 5 种单例模式的实现，最推荐使用静态内部类的方式。饿汉式虽然简单但是容易造成资源浪费，懒汉式过于复杂，即便是双重检查版本也有可能 DCL 失效，枚举虽然是完美单例但是扩展性低，容器模式需要大量代码优化线程安全和获取操作并且增加了开发者的学习成本。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Java 反射完全解析]]></title>
    <url>%2F2018%2F07%2F20%2F%E8%BD%AC-Java%E5%8F%8D%E5%B0%84%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转自：Java反射完全解析 本文相关知识点大部分总结自Oracle官方文档，对于英文比较好的朋友，建议直接阅读原文档。 按例，首先描述一下定义： Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。 简而言之，你可以在运行状态中通过反射机制做到： 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。 在我看来我们平时使用 Java 反射主要涉及两个类(接口) Class， Member，如果把这两个类搞清楚了，反射基本就 ok 了。 Class提到反射就不得不提到 Class，Class 可以说是反射能够实现的基础；注意这里说的 Class与 class 关键字不是同一种东西。class 关键字是在声明 java 类时使用的；而 Class 是 java JDK 提供的一个类,完整路径为 java.lang.Class，本质上与 Math, String 或者你自己定义各种类没什么区别。 123public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; ...&#125; 那 Class 到底在反射中起到什么作用呢？ For every type of object, the Java virtual machine instantiates an immutable instance of java.lang.Class which provides methods to examine the runtime properties of the object including its members and type information. Class also provides the ability to create new classes and objects. Most importantly, it is the entry point for all of the Reflection APIs. 对于每一种类，Java 虚拟机都会初始化出一个 Class 类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应 Class 对象，并且这个 Class 对象会被保存在同名 .class 文件里。当我们 new 一个新对象或者引用静态成员变量时，Java 虚拟机(JVM)中的类加载器系统会将对应 Class 对象加载到 JVM 中，然后 JVM 再根据这个类型信息相关的Class 对象创建我们需要实例对象或者提供静态变量的引用值。 比如创建编译一个 Shapes 类，那么，JVM 就会创建一个 Shapes 对应 Class 类的 Class实例，该 Class 实例保存了 Shapes 类相关的类型信息，包括属性，方法，构造方法等等，通过这个 Class 实例可以在运行时访问 Shapes 对象的属性和方法等。另外通过 Class类还可以创建出一个新的 Shapes 对象。这就是反射能够实现的原因，可以说 Class 是反射操作的基础。 需要特别注意的是，每个 class（注意 class 是小写，代表普通类）类，无论创建多少个实例对象，在 JVM 中都对应同一个 Class 对象。 下面就通过一个简单的例子来说明如何通过反射实例化一个对象。 123456789101112131415161718192021222324252627282930313233343536public class Animal &#123; private String name; private int age; public Animal(String name, int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Animal : name = " + name + " age = " + age; &#125;&#125; public class TestReflection&#123; private static final String TAG = "Reflection"; public void testReflection()&#123; //获取Animal类的Class对象 Class c = Animal.class; try &#123; //通过Class对象反射获取Animal类的构造方法 Constructor constructor = c.getConstructor(String.class, int.class); //调用构造方法获取Animal实例 Animal animal = (Animal) constructor.newInstance( "Jack", 3); //将构造出来的Animal对象打印出来 Log.d(TAG, animal.toString()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面我们来看下打印值 103-28 20:12:00.958 2835-2835/? D/Reflection: Animal : name = Jack age = 3 可以看出我们确实成功构造出了 Animal 对象，而且在这过程中 Class 功不可没。有人说你这也太费事了，都知道 Animal 对象了，我分分钟就能给你 new 出来了。 1Animal animal = new Animal("Jack", 3); 没错！但是如果并不能直接导入 Animal 类呢，如果构造方法都是 private 的呢？这个时候反射就能大展身手了。 如何获取Class说 Class 是反射能够实现的基础的另一个原因是：Java 反射包 java.lang.reflect 中的所有类都没有 public 构造方法，要想获得这些类实例，只能通过 Class 类获取。所以说如果想使用反射，必须得获得 Class 对象。下面列举了几种能够获取 Class 对象的方法。 Object.getClass()通过对象实例获取对应 Class 对象，如 1234567891011121314//Returns the Class for StringClass c = "foo".getClass();enum E &#123; A, B &#125;//Returns the Class corresponding to the enumeration type E.Class c = A.getClass();byte[] bytes = new byte[1024];//Returns the Class corresponding to an array with component type byte.Class c = bytes.getClass();Set&lt;String&gt; s = new HashSet&lt;String&gt;();//Returns the Class corresponding to java.util.HashSet.Class c = s.getClass(); 然而对于基本类型无法使用这种方法 12boolean b;Class c = b.getClass(); // compile-time error The .class Syntax通过类的类型获取Class对象,基本类型同样可以使用这种方法，如 12345//The `.class` syntax returns the Class corresponding to the type `boolean`.Class c = boolean.class; //Returns the Class for StringClass c = String.class; Class.forName()通过类的全限定名获取Class对象， 基本类型无法使用此方法 1Class c = Class.forName("java.lang.String"); 对于数组比较特殊 123Class cDoubleArray = Class.forName("[D"); //相当于double[].classClass cStringArray = Class.forName("[[Ljava.lang.String;"); //相当于String[][].class TYPE Field for Primitive Type Wrappers基本类型和 void 类型的包装类可以使用 TYPE 字段获取 12Class c = Double.TYPE; //等价于 double.class.Class c = Void.TYPE; Methods that Return Classes另外还有一些反射方法可以获取 Class 对象，但前提是你已经获取了一个 Class 对象。有点拗口，比如说你已经获取了一个类的 Class 对象，就可以通过反射方法获取这个类的父类的 Class 对象。 Class.getSuperclass()获得给定类的父类 Class 12// javax.swing.JButton的父类是javax.swing.AbstractButtonClass c = javax.swing.JButton.class.getSuperclass(); 类似方法还有： Class.getClasses()Class.getDeclaredClasses()Class.getDeclaringClass()Class.getEnclosingClass()java.lang.reflect.Field.getDeclaringClass()java.lang.reflect.Method.getDeclaringClass()java.lang.reflect.Constructor.getDeclaringClass() 通过Class获取类修饰符和类型我们知道类的声明一般如下表示 下面我们就以 HashMap 为例，通过一个 Demo 来说明如何获取这些信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestReflection &#123; private static final String TAG = "Reflection"; public void testReflection() &#123; Class&lt;?&gt; c = HashMap.class; //获取类名 Log.d(TAG, "Class : " + c.getCanonicalName()); //获取类限定符 Log.d(TAG, "Modifiers : " + Modifier.toString(c.getModifiers())); //获取类泛型信息 TypeVariable[] tv = c.getTypeParameters(); if (tv.length != 0) &#123; StringBuilder parameter = new StringBuilder("Parameters : "); for (TypeVariable t : tv) &#123; parameter.append(t.getName()); parameter.append(" "); &#125; Log.d(TAG, parameter.toString()); &#125; else &#123; Log.d(TAG, " -- No Type Parameters --"); &#125; //获取类实现的所有接口 Type[] intfs = c.getGenericInterfaces(); if (intfs.length != 0) &#123; StringBuilder interfaces = new StringBuilder("Implemented Interfaces : "); for (Type intf : intfs)&#123; interfaces.append(intf.toString()); interfaces.append(" "); &#125; Log.d(TAG, interfaces.toString()); &#125; else &#123; Log.d(TAG, " -- No Implemented Interfaces --"); &#125; //获取类继承数上的所有父类 List&lt;Class&gt; l = new ArrayList&lt;&gt;(); printAncestor(c, l); if (l.size() != 0) &#123; StringBuilder inheritance = new StringBuilder("Inheritance Path : "); for (Class&lt;?&gt; cl : l)&#123; inheritance.append(cl.getCanonicalName()); inheritance.append(" "); &#125; Log.d(TAG, inheritance.toString()); &#125; else &#123; Log.d(TAG, " -- No Super Classes --%n%n"); &#125; //获取类的注解(只能获取到 RUNTIME 类型的注解) Annotation[] ann = c.getAnnotations(); if (ann.length != 0) &#123; StringBuilder annotation = new StringBuilder("Annotations : "); for (Annotation a : ann)&#123; annotation.append(a.toString()); annotation.append(" "); &#125; Log.d(TAG, annotation.toString()); &#125; else &#123; Log.d(TAG, " -- No Annotations --%n%n"); &#125; &#125; private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123; Class&lt;?&gt; ancestor = c.getSuperclass(); if (ancestor != null) &#123; l.add(ancestor); printAncestor(ancestor, l); &#125; &#125;&#125; 打印结果如下 12345603-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Class : java.util.HashMap03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Modifiers : public03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Parameters : K V 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Implemented Interfaces : java.util.Map&lt;K, V&gt; interface java.lang.Cloneable interface java.io.Serializable 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Inheritance Path : java.util.AbstractMap java.lang.Object 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: -- No Annotations -- Member Reflection defines an interface java.lang.reflect.Member which is implemented by java.lang.reflect.Field, java.lang.reflect.Method, and java.lang.reflect.Constructor . 对于 Member 接口可能会有人不清楚是干什么的，但如果提到实现它的三个实现类，估计用过反射的人都能知道。我们知道类成员主要包括构造函数，变量和方法，Java 中的操作基本都和这三者相关，而 Member 的这三个实现类就分别对应他们。 java.lang.reflect.Field ：对应类变量java.lang.reflect.Method ：对应类方法java.lang.reflect.Constructor ：对应类构造函数 反射就是通过这三个类才能在运行时改变对象状态。下面就让我们通过一些例子来说明如何通过反射操作它们。 首先建一个测试类 12345678910111213141516171819202122232425262728293031323334353637public class Cat &#123; public static final String TAG = Cat.class.getSimpleName(); private String name; @Deprecated public int age; public Cat(String name, int age)&#123; this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void eat(String food)&#123; Log.d(TAG, "eat food " + food); &#125; public void eat(String... foods)&#123; StringBuilder s = new StringBuilder(); for(String food : foods)&#123; s.append(food); s.append(" "); &#125; Log.d(TAG, "eat food " + s.toString()); &#125; public void sleep()&#123; Log.d(TAG, "sleep"); &#125; @Override public String toString() &#123; return "name = " + name + " age = " + age; &#125;&#125; Field通过 Field 你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是 private 的。 获取 Field Class 提供了4种方法获得给定类的 Field getDeclaredField(String name) 获取指定的变量（只要是声明的变量都能获得，包括 private） getField(String name) 获取指定的变量（只能获得 public 的） getDeclaredFields() 获取所有声明的变量（包括 private） getFields() 获取所有的 public 变量 获取变量类型、修饰符、注解 一个例子说明问题 12345678910111213141516171819202122232425262728public void testField()&#123; Class c = Cat.class; Field[] fields = c.getDeclaredFields(); for(Field f : fields)&#123; StringBuilder builder = new StringBuilder(); //获取名称 builder.append("filed name = "); builder.append(f.getName()); //获取类型 builder.append(" type = "); builder.append(f.getType()); //获取修饰符 builder.append(" modifiers = "); builder.append(Modifier.toString(f.getModifiers())); //获取注解 Annotation[] ann = f.getAnnotations(); if (ann.length != 0) &#123; builder.append(" annotations = "); for (Annotation a : ann)&#123; builder.append(a.toString()); builder.append(" "); &#125; &#125; else &#123; builder.append(" -- No Annotations --"); &#125; Log.d(TAG, builder.toString()); &#125; &#125; 打印结果： 123filed name = age type = int modifiers = public annotations = @java.lang.Deprecated() filed name = name type = class java.lang.String modifiers = private -- No Annotations --filed name = TAG type = class java.lang.String modifiers = public static final -- No Annotations -- 获取、设置变量值 给定一个对象和它的成员变量名称，就能通过反射获取和改变该变量的值。什么都不说了，没有什么是不能通过一个例子解决的， Easy~ 仍然是上面的测试类，通过反射获取并改变 Cat 的 name 和 age. 123456789101112131415161718192021public void testField()&#123; Cat cat = new Cat("Tom", 2); Class c = cat.getClass(); try &#123; //注意获取private变量时，需要用getDeclaredField Field fieldName = c.getDeclaredField("name"); Field fieldAge = c.getField("age"); //反射获取名字, 年龄 String name = (String) fieldName.get(cat); int age = fieldAge.getInt(cat); Log.d(TAG, "before set, Cat name = " + name + " age = " + age); //反射重新set名字和年龄 fieldName.set(cat, "Timmy"); fieldAge.setInt(cat, 3); Log.d(TAG, "after set, Cat " + cat.toString()); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; 嗯？竟然报错？ 1234System.err: java.lang.IllegalAccessException: Class java.lang.Class&lt;com.example.ming.testnestscrollview.TestReflection&gt; cannot access private field java.lang.String com.example.ming.testnestscrollview.Cat.name of class java.lang.Class&lt;com.example.ming.testnestscrollview.Cat&gt;System.err: at java.lang.reflect.Field.get(Native Method)System.err: at com.example.ming.testnestscrollview.TestReflection.testField(TestReflection.java:22)System.err: at com.example.ming.testnestscrollview.MainActivity.onCreate(MainActivity.java:17) 观察一下异常信息 java.lang.IllegalAccessException，说我们没有权限操作变量 name；回到 Cat 类中查看一下 name 变量。 1private String name; 原来 name 变量是 private，Java 运行时会进行访问权限检查，private 类型的变量无法进行直接访问，刚刚进行的反射操作并没有打破这种封装，所以我们依然没有权限对 private属性进行直接访问。 难道就没有办法打破这种限制吗？必须有！强大的反射早已暗中为我们准备好了一切。反射包里为我们提供了一个强大的类。 java.lang.reflect.AccessibleObject AccessibleObject 为我们提供了一个方法 setAccessible(boolean flag)，该方法的作用就是可以取消 Java 语言访问权限检查。所以任何继承 AccessibleObject 的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final 类型变量也可以通过这种办法访问） 1public final class Field extends AccessibleObject implements Member Field 正是 AccessibleObject 的子类，那么简单了，只要在访问私有变量前调用 filed.setAccessible(true) 就可以了 12345...fieldName.setAccessible(true);//反射获取名字, 年龄String name = (String) fieldName.get(cat);... 打印结果 12TestReflection: before set, Cat name = Tom age = 2TestReflection: after set, Cat name = Timmy age = 3 Bingo! 注意 Method 和 Constructor 也都是继承 AccessibleObject，所以如果遇到私有方法和私有构造函数无法访问，记得处理方法一样。 Method The java.lang.reflect.Method class provides APIs to access information about a method’s modifiers, return type, parameters, annotations, and thrown exceptions. It also be used to invoke methods. 这节主要介绍如何通过反射访问对象的方法。 获取 Method Class 依然提供了4种方法获取 Method: getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 根据方法名获得指定的方法， 参数 name 为方法名，参数 parameterTypes 为方法的参数类型，如 getDeclaredMethod(“eat”, String.class) getMethod(String name, Class&lt;?&gt;… parameterTypes) 根据方法名获取指定的 public 方法，其它同上 getDeclaredMethods() 获取所有声明的方法 getMethods() 获取所有的 public 方法 注意：获取带参数方法时，如果参数类型错误会报 NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class） 获取方法返回类型 getReturnType() 获取目标方法返回类型对应的 Class 对象 getGenericReturnType() 获取目标方法返回类型对应的 Type 对象 这两个方法有啥区别呢？ getReturnType()返回类型为 Class，getGenericReturnType() 返回类型为 Type; Class 实现 Type。 返回值为普通简单类型如 Object, int, String 等，getGenericReturnType() 返回值和 getReturnType() 一样 例如 public String function1()，那么各自返回值为： getReturnType() : class java.lang.String getGenericReturnType() : class java.lang.String 返回值为泛型 例如 public T function2()，那么各自返回值为： getReturnType() : class java.lang.Object getGenericReturnType() : T 返回值为参数化类型 例如public Class function3()，那么各自返回值为： getReturnType() : class java.lang.Class getGenericReturnType() : java.lang.Class&lt;java.lang.String&gt; 其实反射中所有形如 getGenericXXX()的方法规则都与上面所述类似。 获取方法参数类型getParameterTypes() 获取目标方法各参数类型对应的 Class 对象getGenericParameterTypes() 获取目标方法各参数类型对应的 Type 对象返回值为数组，它俩区别同上 “方法返回类型的区别” 。 获取方法声明抛出的异常的类型getExceptionTypes() 获取目标方法抛出的异常类型对应的 Class 对象getGenericExceptionTypes() 获取目标方法抛出的异常类型对应的 Type 对象返回值为数组，区别同上 获取方法参数名称.class 文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上 -parameters 参数。(构造方法的参数获取方法同样) 12345678910//这里的m可以是普通方法Method，也可以是构造方法Constructor//获取方法所有参数Parameter[] params = m.getParameters();for (int i = 0; i &lt; params.length; i++) &#123; Parameter p = params[i]; p.getType(); //获取参数类型 p.getName(); //获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`, X为参数在方法声明中的位置，从0开始 p.getModifiers(); //获取参数修饰符 p.isNamePresent(); //.class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase&#125; 获取方法参数名称的详细信息请参考 oracle 的官方例子 MethodParameterSpy 获取方法修饰符 方法与 Filed 等类似 1method.getModifiers(); Ps：顺便多介绍几个Method方法 method.isVarArgs() //判断方法参数是否是可变参数 12public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) //返回truepublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; [] parameterTypes) //返回flase method.isSynthetic() //判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法 method.isBridge() //判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。可以参考：https://www.jianshu.com/u/ceba5da6bd7a 通过反射调用方法 反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。 12public native Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 还是以上面测试类 Cat 为例 注意：如果方法是private的，可以使用 method.setAccessible(true) 方法绕过权限检查 12345678910111213141516171819202122Class&lt;?&gt; c = Cat.class; try &#123; //构造Cat实例 Constructor constructor = c.getConstructor(String.class, int.class); Object cat = constructor.newInstance( "Jack", 3); //调用无参方法 Method sleep = c.getDeclaredMethod("sleep"); sleep.invoke(cat); //调用定项参数方法 Method eat = c.getDeclaredMethod("eat", String.class); eat.invoke(cat, "grass"); //调用不定项参数方法 //不定项参数可以当成数组来处理 Class[] argTypes = new Class[] &#123; String[].class &#125;; Method varargsEat = c.getDeclaredMethod("eat", argTypes); String[] foods = new String[]&#123; "grass", "meat" &#125;; varargsEat.invoke(cat, (Object)foods); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; 被调用的方法本身所抛出的异常在反射中都会以 InvocationTargetException 抛出。换句话说，反射调用过程中如果异常 InvocationTargetException 抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。 Constructor这节主要介绍如何通过反射访问构造方法并通过构造方法构建新的对象。 获取构造方法 和 Method 一样，Class 也为 Constructor 提供了4种方法获取 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 获取指定构造函数，参数 parameterTypes 为构造方法的参数类型 getConstructor(Class&lt;?&gt;… parameterTypes) 获取指定 public 构造函数，参数 parameterTypes 为构造方法的参数类型 getDeclaredConstructors() 获取所有声明的构造方法 getConstructors() 获取所有的 public 构造方法 构造方法的名称、限定符、参数、声明的异常等获取方法都与 Method 类似，请参照Method。 创建对象 通过反射有两种方法可以创建对象： java.lang.reflect.Constructor.newInstance() Class.newInstance() 一般来讲，我们优先使用第一种方法；那么这两种方法有何异同呢？ Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法。 Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出; Constructor.newInstance()会将构造方法中抛出的异常都包装成 InvocationTargetException 抛出。 Class.newInstance()需要拥有构造方法的访问权限; Constructor.newInstance()可以通过 setAccessible(true) 方法绕过访问权限访问 private 构造方法。 例子在 Method 一节已经写过，这里直接截取过来 1234567Class&lt;?&gt; c = Cat.class;try &#123; Constructor constructor = c.getConstructor(String.class, int.class); Cat cat = (Cat) constructor.newInstance( "Jack", 3);&#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace();&#125; 注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间） 数组和枚举数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以 Java 反射为数组和枚举提供了一些特定的 API 接口。 数组 数组类型 数组类型：数组本质是一个对象，所以它也有自己的类型。 例如对于int[] intArray，数组类型为class [I。数组类型中的[个数代表数组的维度，例如[代表一维数组，[[ 代表二维数组；[ 后面的字母代表数组元素类型，I 代表 int，一般为类型的首字母大写(long 类型例外，为 J)。 123456789class [B //byte类型一维数组class [S //short类型一维数组class [I //int类型一维数组class [C //char类型一维数组class [J //long类型一维数组，J代表long类型，因为L被引用对象类型占用了class [F //float类型一维数组class [D //double类型一维数组class [Lcom.dada.Season //引用类型一维数组class [[Ljava.lang.String //引用类型二维数组 1234567//获取一个变量的类型Class&lt;?&gt; c = field.getType();//判断该变量是否为数组if (c.isArray()) &#123; //获取数组的元素类型 c.getComponentType()&#125; 创建和初始化数组 Java 反射为我们提供了 java.lang.reflect.Array 类用来创建和初始化数组。 12345678//创建数组， 参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值Array.set(Object array, int index, int value)//获取数组的值，array为数组对象，index为数组的下标Array.get(Object array, int index) 例子,用反射创建 int[] array = new int[]{1, 2} 123Object array = Array.newInstance(int.class, 2);Array.setInt(array , 0, 1);Array.setInt(array , 1, 2); 注意：反射支持对数据自动加宽，但不允许数据 narrowing(变窄?真难翻译)。意思是对于上述 set 方法，你可以在 int 类型数组中 set short 类型数据，但不可以 set long 类型数据，否则会报 IllegalArgumentException。 多维数组 Java 反射没有提供能够直接访问多维数组元素的 API，但你可以把多维数组当成数组的数组处理。 12345678Object matrix = Array.newInstance(int.class, 2, 2);Object row0 = Array.get(matrix, 0);Object row1 = Array.get(matrix, 1);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4); 或者 1234567891011Object matrix = Array.newInstance(int.class, 2);Object row0 = Array.newInstance(int.class, 2);Object row1 = Array.newInstance(int.class, 2);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4);Array.set(matrix, 0, row0);Array.set(matrix, 1, row1); 枚举枚举隐式继承自 java.lang.Enum，Enum 继承自 Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外 java 反射额外提供了几个方法为枚举服务。 Class.isEnum() Indicates whether this class represents an enum type Class.getEnumConstants() Retrieves the list of enum constants defined by the enum in the order they’re declared java.lang.reflect.Field.isEnumConstant() Indicates whether this field represents an element of an enumerated type 反射的缺点没有任何一项技术是十全十美的，Java 反射拥有强大功能的同时也带来了一些副作用。 性能开销 反射涉及类型动态解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部曝光 由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 使用反射的一个原则：如果使用常规方法能够实现，那么就不要用反射。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」010 阅读笔记]]></title>
    <url>%2F2018%2F06%2F13%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B010%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[名词解释 缩写 英文全称 中文 AS Autonomous System 自治系统 IGP Interior Gateway Protocol 内部网关协议/域内选路协议 EGP Exterier Gateway Protocol 外部网关协议/域内选路协议的分隔选路协议 BGP Border Gateway Protocol 边界网关协议 RIP Routing Infomation Protocol 选路信息协议 OSPF Open Shortest Path First 开放最短路径优先协议 CIDR Classless Inter-Domain Routing 无类别域间路由 IGP 用于自治系统内。 EGP 用于自治系统之间。 BGP 意在取代 EGP。 动态选路 相邻路由器之间进行通信，告知对方每个路由器当前所连接的网络。 路由守护程序根据从相邻路由器收到的信息更新内核中的路由表。 随时间变化时，路由是由路由守护程序动态地增加或删除。 如果路由守护程序发现前往同一信宿存在多条路由，选择最佳路由加入内核路由表。 如果路由守护程序发现一条链路已经断开，删除受影响的路由或增加一条路由绕过。 每个自治系统由单个实体管理。==什么是实体？== RIP：选路信息协议 正式描述文件 RFC 1058 [Hedrick 1988a]。 RIP 报文包含在 UDP 数据报中。 RIP 的度量是以跳计数的。 最多携带 25 个路由。 度量 直接连接接口的跳数为 1。 一个路由器到一个网络有多条路由，路由器选择跳数最小的路由。 度量为 16 表示无路由到达该 IP 地址。 问题 RIP 没有子网地址的概念。 路由器或链路发生故障后在稳定下来这段时间可能发生路由环路。 度量最大值限制了可以使用 RIP 的网络的大小。 RIP 版本 2 RFC 1388 [Malkin 1993a] 对 RIP 定义进行了扩充。 路由域字段：数据报的所有者。 选路标记字段：携带一个 EGP 和 BGP 的自治系统号。 子网掩码字段：应用于相应的 IP 地址。 下一站 IP 地址字段：指明发往目的 IP 地址的报文应该发往哪里。 除了支持广播，还支持多播。 OSPF：开放最短路径优先 RFC 1247 [Moy 1991] 对第 2 版 OSPF 进行了描述。 OSPF 克服了 RIP 所有限制。 路由器不与临站交换距离信息，主动测试与临站相连的链路状态。 信息发给其他临站，临站将这些信息在自治系统中传播出去。 路由器接收这些链路状态信息，建立完整的路由表。 链路状态协议总是比距离向量协议稳定更快。 OSPF 直接使用 IP，不使用 UDP 或 TCP。 优于 RIP 的特点： 可以对每个 IP 服务类型计算各自的路由集。 给每个接口指派一个无维数的费用。 同一个目的地址存在多个相同费用的路由时，平均分配流量。 支持子网，子网掩码与每个通告相连。 无编号网络。 简单鉴别机制。 采用多播而不是广播形式，减少系统负载。 BGP：边界网关协议 RFC 1267 [Lougheed and Rekhter 1991] 对第 3 版 BGP 进行描述。 BGP 系统之间交换网络可到达信息，包括所必须经过的自治系统的所有路径。 使用 BGP 的一个目的是减少通过流量。 允许使用基于策略的选路。 使用 TCP 作为其传输层协议。 BGP 是一个距离测量协议，列举了到每个目的地址的路由，排除了一些距离向量协议的问题。 定期发送 keepalive 报文给临站来监测 TCP 连接对端的链路或主机失败。 应用层的 keepalive 报文与 TCP 的 keepalive 报文选项相互独立。 CIDR：无类型域间选路 RFC 1518 [Rekher and Li 1993], RFC 1519 [Fuller et al. 1993] 对它描述。 [Ford, Rekhter, and Braun 1993] 综述。 一个防止路由表膨胀的方法，也成为超网。 采用分配多个 IP 地址的方式，使许多表项总和成更少的数目 必须满足 3 种特性： IP地址必须具有相同的高位地址比特。 路由表和选路算法必须扩展成根据 32 bit IP 地址和 32 bit 掩码做出选路决策。 选路协议要有 32 bit 掩码。]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」007、008、009 阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B007%E3%80%81008%E3%80%81009%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[007，Ping 的工作原理Unix 系统的实现 把 ICMP 报文中标识符字段设置成发送进程的 ID 号（识别多个 Ping 程序实例）。 序列号从 0 开始，每发送一次新的回显请求就 + 1。 Ping 程序允许我们查看是否有分组丢失、失序或重复。 旧版本 Ping 程序 每秒发送一个回显请求。 打印返回的每个分组的每个回显应答。 新版本 Ping 程序 需要加上 - s 选项以旧版本模式运行。 Ping 程序只发送一个回显请求。 收到回显应答输出 “host is alive”，20 秒内没收到输出 “no answer”。 008，Traceroute 的工作原理 每个处理数据报的路由器都要把 TTL 的值减 1 或停留的秒数。 大多数路由器转发数据报的时延都小于 1 秒，TTL 最终成为一个跳站计数器。 如果 TTL 字段是 1，路由器将该数据报丢弃，并向信源机放一份 ICMP “超时”信息。 Traceroute 程序发送一份 TTL 字段为 1 的 IP 数据报为目的主机，第一个路由器丢弃并发回超时 ICMP 报文，然后 Traceroute 程序发送一份 TTL 字段为 2 的数据报，得到第二个路由器的地址，以此类推。 目的主机收到 TTL 值为 1 的 IP 数据报，不会丢弃并产生 ICMP 超时报文。 Traceroute 程序发送一份不可能值作为 UDP 端口号（大于 30000）的 UDP 数据报给目的主机，目的主机产生一份“端口不可达”错误的 ICMP 报文。 Traceroute 程序区分收到的 ICMP 报文是超时还是端口不可达判断是否结束。 009，IP 包选路的工作原理选路的原理 IP 搜索路由表的步骤： 搜索匹配的主机地址。 搜索比配的网络地址。 搜索默认表项。 IP 层进行的选路是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。 选路策略决定把哪些路由放入路由表的规则，路由守护程序提供选路策略。 初始化路由表 在系统引导时显示地的在初始化文件中运行 route 命令。 没有到达目的地的路由路由表中没有默认项，又没有找到匹配项。 数据报由本地主机产生：向应用程序返回一个“主机不可达差错”或“网络不可达差错”。 被转发的数据报：向原始发送端发送一份 ICMP 主机不可达差错报文。 ICMP 重定向差错 当数据报应该被发送到另一个路由器时，收到数据报的路由器要发送 ICMP 重定向差错报文给 IP 数据报的发送端。 重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。 ICMP 重定向报文 重定向报文只能由路由器生成。 重定向报文是为主机使用的。 ICMP 路由器发现报文 一份报文可以通告多个地址。 路由器启动时定期在所有广播或多播传送接口上发送通告报文。 某个接口被关闭时，该接口上发送一份通告报文，生命周期值设为 0。 监听来自主机的请求报文，并发送通告报文以响应。 主机在引导期间发送请求报文。 监听来自相邻路由器的请求报文。]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」006 阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B006%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ICMP 的正式规范参见 RFC 792 ICMP 是 IP 层的一个组成部分，传递差错报文和其他需要注意的信息。 通常被 IP 层或更高层协议使用。 校验和覆盖整个 ICMP 报文，算法与 IP 首部相同 不同类型和代码有不同的内容 ICMP 报文的类型 类型字段和代码字段共同决定。 ICMP 差错报文始终包含 IP 首部和产生差错的 IP 数据报的前 8 个字节。 接收 ICMP 差错报文的模块可以与某个协议和用户进程联系起来。 下面情况不产生差错报文： ICMP 差错报文 目的地址是广播或多播地址 作为链路层广播的数据报 不是 IP 分片的第一片 源地址不是单个主机的数据报 ICMP 地址掩码请求与应答 用于无盘系统在引导过程中获取自己的子网掩码。 系统广播他的 ICMP 请求报文（类似 RARP 获取 IP 地址）。 标识符和序列号由发送端任意设定，在应答中返回进行匹配。 ICMP 时间戳请求与应答 请求允许系统向另一个系统查询当前时间。 返回的建议值是自午夜计算的毫秒数，协调的统一时间。 缺陷：必须通过其他方法获知当时的日期。 请求端填写发起时间戳，应答系统收到时填写接收时间戳，发送时填写传送时间戳。 调整值是 difference - RTT / 2。 ICMP 端口不可达差错以 UDP 端口不可达为例。 IP 首部后面前 8 个字节是 UDP 首部（源端口号和目的端口号）。]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」004 阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B004%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[RFC 826 [Plummer 1982] 是 ARP 规范描述文档。 ARP（地址解析协议） RARP（逆地址解析协议） ARP 为 IP 地址到对应硬件地址之间提供动态映射，因为是自动完成的。 RARP 被没有磁盘驱动器的系统使用，需要系统管理员手工设置。 ARP 发送一份称作 ARP 请求的以太网数据帧给以太网上的每个主机。称作广播。 点对点链路不使用 ARP。设置这些链路时，必须告知内核链路每一端的 IP 地址，而不需要硬件地址。 ARP 高效运行因为每个主机上都有一个 ARP 高速缓存 ARP的分组格式 以太网目的地址 以太网源地址 帧类型 硬件类型 协议类型 硬件地址长度 协议地址长度 op 发送端以太网地址 发送端IP地址 目的以太网地址 目的IP地址 6 6 2 2 2 1 1 2 6 4 6 4 全1 0x0806 1 0x0800 6 bytes 4 bytes 广播地址 ARP 请求或应答 表示以太网地址 表示 IP 地址 MAC 地址长度 IP 地址长度 目的地址：全1的特殊地址是广播地址，电缆上的所有以太网接口都要接收广播的数据帧。 操作字段（OP）：ARP 请求（1）、ARP 应答（2）、RARP 请求（3）、RARP 应答（4），必须字段，因为 ARP 请求和应答的帧类型字段相同。 ARP 高速缓存超时设置 BSD 演变来的系统一般设置完整表项超时 20 分钟，不完整表项超时 3 分钟。 表项再次使用时，超时值重设为 20 分钟。 ARP 代理 路由器相当于目的主机的代理，把分组从其他主机转发给它。 免费 ARP 是指发送 ARP 查找自己的 IP 地址。 两方面作用： 验证 IP 是否冲突，一个主机能够通过它来确定是否还有一个主机设置了相同的 IP 地址。 更换物理网卡，假设发送ARP的主机正好改变了物理地址，能够使用此方法通知网络中其他主机及时更新 ARP 缓存。 ARP 命令 arp -a 显示 ARP 高速缓存。 arp -d 删除 ARP 高速缓存中某一项。 arp -s 增加高速缓存中的内容，是永久性的，除非末尾加上关键字 temp。]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」003 阅读笔记]]></title>
    <url>%2F2018%2F06%2F02%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B003%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[IP 的正式规范文件：RFC 791 所有 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。 不可靠：不能保证 IP 数据报能够成功到达目的地。可靠性必须由上层提供。 无连接：IP 不维护后续数据报的状态信息。每个数据报的处理相互独立。IP 数据报可以不按发送顺序接收。 传输次序：网络字节序 /big endian（大端）字节序 IP首部字段 字段名 长度 版本 4 位 4 首部长度 4 位 首部占 32 bit 字的数目，没有任何选项，值为 5，首部最长 60 字节 服务类型（TOS） 8 位 3 bit 优先权子字段（已忽略），4 bit TOS 子字段，1 bit 未用位（置为 0） 总长度 16 位 字节为单位，最长 65535 字节。必要内容 位标识 16 位 唯一标识主机发送的每一份数据报 位标志 3 位 位片偏移 13 位 生存时间（TTL） 8 位 经过的最多路由器数，初始值通常为 64 或 32，源主机设置。 协议 8 位 首部校验和 16 位 根据 IP 首部计算校验和码。 选项 可选，可变长。32 bit 为界限，不够时插入值为 0 的填充字节。 首部长度：从包头格式图看出，是以 32 bit 为一行的，一行包括若干字段。首部长度的数值是以 32 bit 为单位来描述的，比如四位全为 1，十六进制本来是 0X0F，也就是十进制的 15 但是，这个字段的 1 不是数值 1，而是指 1 个单位即一个 32 bit。所以如果该字段是 1111 的话。就是 15 * 32 bit = 60 Byte 了。 4 bit 的 TOS 代表：最小时延、最大吞吐量、最高可靠性、最小费用。 首部长度、总长度计算数据内容的起始位置和长度。 TTL 为 0 时丢弃数据报，发送 ICMP 报文通知源主机。 首部校验和：如果校验和错误，丢弃数据报，但不生成差错报文，由上层发现并重传。 IP路由选择目的主机与源主机直接相连，或都在一个共享网络上，IP 数据报直接送到目的主机。 否则发往默认路由，由路由器转发。 IP 层可以配置成路由器或主机主机：不转发 路由器：转发 内含路由器的主机：不转发 收到数据报来自网络接口时（即非本地生成的数据报） 检查 IP 地址 是本机 IP 地址之一或 IP 广播地址：发送到指定协议模块 IP 层设置为路由器：转发 否则：丢弃 路由表 项 含义 目的 IP 地址 表中标志字段指定类型。完整的主机地址：非 0 主机号。网络地址：主机号为 0。 下一跳路由器 IP 地址 或者有直接连接的网络 IP 地址。 标志 一个指明目的 IP 地址类型，==一个标志下一站路由器时真下一站路由器还是直接相连的接口。看不懂这句== 指定网络接口 IP 不知道目的的完整路径 IP 路由选择主要功能搜索路由表 寻找与目的 IP 完全匹配（网络号和主机号）的条目 寻找与目的网络号相匹配的条目（必须考虑子网掩码） 寻找“默认”的条目 如果找到，报文发送指定的下一站路由器或直接相连的网络接口。 如果都未成功，则不能被传送，向应用返回错误 子网寻址==看不懂图== 所有主机都要求支持子网寻址。 IP 地址 = 网络号 + 子网号 + 主机号 B 类 IP 地址 = 网络号（16 位）+ 子网号（8 位）+ 主机号（8 位） 子网对外部路由器来说隐藏了内部网络组织。 子网划分缩减了路由表的规模。 子网对于子网内部的路由器不透明。==不懂== 子网掩码 标识多少 bit 用于子网号，多少bit用于主机号。 掩码是 32 bit 的值，值为1留给网络号和子网号，值为 0 留给主机号。 给定 IP 地址和子网掩码后可以确定： 本子网上的主机。 本网络中其他子网中的主机。 其他网络上的主机。]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
        <tag>看不懂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TCP/IP详解 卷1」002 阅读笔记]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B002%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[名词解释 LLC：逻辑链路控制（Logic Link Control） SNAPL：自网络访问协议（SubNetwork Access Protocol） IEEE：电子电气工程师协会 CRC：循环冗余校验（Cyclic Redundancy Check ） pad字节：padding byte，填充字节 RS-232：异步传输标准接口 BSD：Berkeley Software Distribution，Unix 的衍生系统 链路层主要三个目的 为 IP 模块发送接受 IP 数据报。 为 ARP 模块发送 ARP 请求和接受 ARP 应答。 为 RARP 发送 RARP 请求和接受 RARP 应答。 以太网与 IEEE 802 封装对比 以太网 IEEE 802 备注 数据报封装 RFC 894 中定义 RFC 1042 中定义 长度字段 后续数据的长度字段（不包括 CRC） 类型字段 后续数据的类型 由后续子网接入协议的首部给出 格式相同 最小长度 46 字节 38 字节 不足空间填充 pad 字节 有效类型值都不相同，可以对两种帧格式进行区分。 以太网：类型字段后是数据。 IEEE 802：长度字段后是 802.2LLC、802.2SNAP。 CRC 字段（FCS/帧校验序列）：后续字节差错的循环冗余码校验。 尾部封装 在 RFC 89C 被描述。 通过调整 IP 数据报中字段次序提高性能。 将 IP 首部和 TCP 首部移到尾部 CRC 之前。 ==当把数据复制到内核是，可以绑数据帧中的数据部分映射到一个硬件页面，节省到内存的复制过程。看不懂？？？== 尾部封装已遭到反对。 SLIP：串行线路 IP 串行线路上对 IP 数据报封装的简单形式。 适用于 RS-232 串行端口、高速调制解调器接入网络。 以 END(0XC0) 的特殊字符结束。 如果有线路噪声，开始也传一个 END(0XC0) 字符。 IP 报文中 END 用 0XDB 和 0XDC 取代（称为 ESC 字符）。 IP 报文中 ESC 用 0XDB 和 0XDD 取代。 缺陷： 每一端必须知道对方的IP地址。 没有类型字段，不能和其他协议同时使用。 没有校验和。 压缩的 SLIP（CSLIP） 在 RFC 1144 中被描述。 为了在 SLIP 上传输 1 个字节总共需要 40 字节，CSLIP 能把它们压缩到 3 或 5 个字节。 每一端维持多达 16 个 TCP 连接。 知道每个连接的首部哪些字段一般不会发生变化。 被压缩的首部大大缩短了交互响应时间。 PPP 点对点协议修改了 SLIP 协议中的所有缺陷，最终应该取代 SLIP。 PPP 包括三个部分： 在串行链路上封装 IP 数据报的方法。 建立、配置及测试数据链路的链路控制协议。 针对不同网络层协议的网络控制协议体系。 数据报帧的格式： 以 0X7E 开始和结束。 地址字节值始终为 0XFF。 协议字段（类似以太网类型字段）： 协议字段的值 标识信息字段的类型 0X0021 IP数据报 0XC021 链路控制数据 0X8021 网络控制数据 信息字段出现 0X7E 时需要转义。 利用链路控制协议，大多数可以省略标识符和地址字段。 使用 IP 网络控制协议，大多数可以采用 Van Jacobson 报文首部压缩方法。不懂？？？ 对比 SLIP 具有的优点 PPP 支持在单根串行线路上运行多种协议。 每一帧都有循环冗余校验。 通信双方可以进行 IP 地址的动态协商。 与 CSLIP 类似，对 TCP 和 IP 报文首部压缩。 链路控制协议可以对多个数据链路选项进行设置。 环回接口（localhost） 大多数系统把 IP 地址 127.0.0.1 分配给这个接口。 一个传给环回接口的 IP 数据报不能在任何网络上出现。 最大传输单元 MTU 如果 IP 层有一个长度大于链路层的 MTU 的数据报要传，需要进行分片。 MTU 不是物理特性，它是一个逻辑限制。 目的：为交互使用提供足够快的响应时间。 路径 MTU==两台主机路径中的最小 MTU 被称作路径 MTU（不一定是个常数）。看不懂这句话== 串行线路吞吐量计算 如果线路速率是 9600b/s，而一个字节有 8bit，加上一个起始比特和一个停止比特，那么线路的速率就是 960B/s（字节/秒）。 这句话是指每个 bit 加一个起始一个停止，所有 9600 / (8 + 2) = 960 B/s。 如果把 SLIP 的 MTU 降到 256 以下，将降低传输大块数据的最大吞吐量。 平均等待时间的计算（传输大数据帧所需时间的一半）只适用于 SLIP 或 PPP 链路。 ==为什么要等一半的时间？？==]]></content>
      <categories>
        <category>《TCP/IP详解 卷1》</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
        <tag>看不懂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」Toolbar 的 setTitle 问题]]></title>
    <url>%2F2018%2F04%2F09%2FToolbar%E7%9A%84setTitle%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在 setSupportActionBar(toolbar) 之后调用 toolbar.setTitle() 在 onCreate() 中调用无效 在 onStart() 中调用无效 解决方案： 在 onResume() 中调用有效。 getSupportActionBar.setTitle() 有效]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转载」Android 生成验证码]]></title>
    <url>%2F2018%2F02%2F22%2F%E8%BD%AC-Android%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class Code &#123; //随机数数组 private static final char[] CHARS = &#123; '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; private static Code bmpCode; public static Code getInstance() &#123; if(bmpCode == null) bmpCode = new Code(); return bmpCode; &#125; //default settings //验证码默认随机数的个数 private static final int DEFAULT_CODE_LENGTH = 4; //默认字体大小 private static final int DEFAULT_FONT_SIZE = 25; //默认线条的条数 private static final int DEFAULT_LINE_NUMBER = 5; //padding值 private static final int BASE_PADDING_LEFT = 10, RANGE_PADDING_LEFT = 15, BASE_PADDING_TOP = 15, RANGE_PADDING_TOP = 20; //验证码的默认宽高 private static final int DEFAULT_WIDTH = 100, DEFAULT_HEIGHT = 40; //settings decided by the layout xml //canvas width and height private int width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT; //random word space and pading_top private int base_padding_left = BASE_PADDING_LEFT, range_padding_left = RANGE_PADDING_LEFT, base_padding_top = BASE_PADDING_TOP, range_padding_top = RANGE_PADDING_TOP; //number of chars, lines; font size private int codeLength = DEFAULT_CODE_LENGTH, line_number = DEFAULT_LINE_NUMBER, font_size = DEFAULT_FONT_SIZE; //variables private String code; private int padding_left, padding_top; private Random random = new Random(); //验证码图片 public Bitmap createBitmap() &#123; padding_left = 0; Bitmap bp = Bitmap.createBitmap(width, height, Config.ARGB_8888); Canvas c = new Canvas(bp); code = createCode(); c.drawColor(Color.WHITE); Paint paint = new Paint(); paint.setAntiAlias(true); paint.setTextSize(font_size); //画验证码 for (int i = 0; i &lt; code.length(); i++) &#123; randomTextStyle(paint); randomPadding(); c.drawText(code.charAt(i) + "", padding_left, padding_top, paint); &#125; //画线条 for (int i = 0; i &lt; line_number; i++) &#123; drawLine(c, paint); &#125; c.save( Canvas.ALL_SAVE_FLAG );//保存 c.restore();// return bp; &#125; public String getCode() &#123; return code; &#125; //生成验证码 private String createCode() &#123; StringBuilder buffer = new StringBuilder(); for (int i = 0; i &lt; codeLength; i++) &#123; buffer.append(CHARS[random.nextInt(CHARS.length)]); &#125; return buffer.toString(); &#125; //画干扰线 private void drawLine(Canvas canvas, Paint paint) &#123; int color = randomColor(); int startX = random.nextInt(width); int startY = random.nextInt(height); int stopX = random.nextInt(width); int stopY = random.nextInt(height); paint.setStrokeWidth(1); paint.setColor(color); canvas.drawLine(startX, startY, stopX, stopY, paint); &#125; //生成随机颜色 private int randomColor() &#123; return randomColor(1); &#125; private int randomColor(int rate) &#123; int red = random.nextInt(256) / rate; int green = random.nextInt(256) / rate; int blue = random.nextInt(256) / rate; return Color.rgb(red, green, blue); &#125; //随机生成文字样式，颜色，粗细，倾斜度 private void randomTextStyle(Paint paint) &#123; int color = randomColor(); paint.setColor(color); paint.setFakeBoldText(random.nextBoolean()); //true为粗体，false为非粗体 float skewX = random.nextInt(11) / 10; skewX = random.nextBoolean() ? skewX : -skewX; paint.setTextSkewX(skewX); //float类型参数，负数表示右斜，整数左斜 //paint.setUnderlineText(true); //true为下划线，false为非下划线 //paint.setStrikeThruText(true); //true为删除线，false为非删除线 &#125; //随机生成padding值 private void randomPadding() &#123; padding_left += base_padding_left + random.nextInt(range_padding_left); padding_top = base_padding_top + random.nextInt(range_padding_top); &#125; &#125; 调用方法： 12ivCode.setImageBitmap(Code.getInstance().createBitmap());//将验证码图片显示到ImageView String code = Code.getInstance().getCode().toLowerCase();//用一个变量保存验证码，并转为小写，获取输入的验证也转为小写，这样就实现了不区分大小写]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
</search>
