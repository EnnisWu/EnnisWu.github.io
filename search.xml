<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-26向量化]]></title>
    <url>%2F2018%2F12%2F03%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-26%E5%90%91%E9%87%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SIMD 寄存器名称 所属指令集 位数 备注 XMM 寄存器 SSE（Streaming SIMD Extensions）指令集 128 位 YMM 寄存器 AVX（Advanced Vector Extensions）指令集 256 位 XMM升级版 ZMM 寄存器 AVX512 指令集 512 位 YMM升级版 原本使用 XMM 寄存器的指令，使用 YMM 寄存器的低 128 位。 支持 AVX512 指令集的 CPU 都比较贵，目前在生产环境中很少见到。 HotSpot 虚拟机更新了不少基于 AVX512 指令集以及 ZMM 寄存器的优化。 单指令流多数据流（Single Instruction Multiple Data，SIMD）：即通过单条指令操控多组数据的计算操作。这些指令称之为 SIMD 指令。 SIMD 指令将上述寄存器中的值看成多个整数或者浮点数组成的向量，进行批量计算。 128 位 XMM 寄存器里的值可以看成 16 个 byte 值组成的向量，或者 8 个 short 值组成的向量，4 个 int 值组成的向量，两个 long 值组成的向量。 SIMD 指令PADDB、PADDW、PADDD以及PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。 SIMD 指令也被看成 CPU 指令级别的并行。 使用 SIMD 指令的 HotSpot Intrinsic SIMD 指令虽然非常高效，但是使用很麻烦。 不同的 CPU 所支持的 SIMD 指令可能不同。 Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的，将被替换为具体 SIMD 指令的 intrinsic 方法。 HotSpot 虚拟机提供 Java 层面的 intrinsic 方法，这些 intrinsic 方法的语义要比单个 SIMD 指令复杂得多。 使用 SIMD 指令的 HotSpot intrinsic 是虚拟机开发人员根据其语义定制的，因而性能相当优越。 由于开发及维护成本较高，这种类型的 intrinsic 屈指可数。 intrinsic 方法只能做到点覆盖，在多数情况下，应用程序不会用到这些 intrinsic 的语义，却又存在向量化优化的机会（借助自动向量化）。 自动向量化（auto vectorization） 即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。 计数循环的判定 自动向量化的条件较为苛刻。 C2 支持的整数向量化操作不多（加法，减法，按位与、或、异或，以及批量移位和批量乘法）。 C2 支持向量点积的自动向量化，需要多条 SIMD 指令完成，并不是十分高效。 自动向量化的条件 循环变量的增量为 1（能够遍历整个数组）。 循环变量不能为 long 类型（ C2 无法将循环识别为计数循环）。 循环迭代之间最好不要有数据依赖（循环展开之后，循环体内存在数据依赖，C2 无法进行自动向量化）。 循环体内不要有分支跳转。 不要手工进行循环展开（如果 C2 无法自动展开，也无法进行自动向量化）。 引用 https://time.geekbang.org/column/article/39838]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-25循环优化]]></title>
    <url>%2F2018%2F11%2F24%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-25%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[循环无关代码外提 所谓的循环无关代码（Loop-invariant Code），指的是循环中值不变的表达式。 在不改变程序语义的情况下，将循环无关代码提出循环之外。 外提循环中值不变的表达式 通过 Sea-of-Nodes IR 以及节点调度共同完成。 外提循环无关检测 通过循环预测（Loop Prediction）完成。 比如 null 检测（null check），数组下标范围检测（range check）。 null 检测涉及控制流依赖，无法通过 Sea-of-Nodes IR 转换以及节点调度外提。 循环展开（Loop Unrolling） 指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。 在 C2 中，只有计数循环（Counted Loop）才能被展开。 随着循环体的增大，优化机会不断增加。 如果循环展开能够触发进一步优化，总体的代码复杂度将降低。 缺点：可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。 循环完全展开（Full Unroll） 当循环数目是固定值而且非常小时，会将循环全部展开（Full Unroll）。 仅迭代三次（或以下）的循环，即时编译器将进行完全展开。 循环体 IR 节点数目超过阈值的循环，即时编译器不会进行任何循环展开。 计数循环需满足的 4 个条件 维护一个循环计数器，并且基于计数器的循环出口只有一个（但可以有基于其他判断条件的出口）。 循环计数器的类型为 int、short 或者 char（即不能是 byte、long，更不能是 float 或者 double）。 每个迭代循环计数器的增量为常数。 循环计数器的上限（增量为正数）或下限（增量为负数）是循环无关的数值。 循环判断外提（loop unswitching） 指的是将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。 与循环无关检测外提所针对的代码模式比较类似。 循环剥离（loop peeling） 指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。 一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。 剥离出去后，可以使原本的循环体的规律性更加明显，触发进一步的优化。 问题Q： 如果有这样一段代码： 123for ( ... ) &#123; sum += x + y + a[i];&#125; 借助 Sea-of-Nodes IR 能把 x + y 表达式外提出去。但，如果表达式变成如下： 1sum += x + a[i] + y; 也能借助 IR 外提 x + y 吗？ A：能。 引用 https://time.geekbang.org/column/article/39814]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-24字段访问相关优化]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-24%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[字段读取优化 即时编译器会优化实例字段和静态字段访问，以减少总的内存访问数目。 沿控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。 遇到对同一字段的读取节点时，如果缓存值还没有失效，将读取节点替换为该缓存值。 遇到对同一字段的存储节点时，更新所缓存的值。 遇到可能更新字段的节点时，采取保守策略，舍弃所有缓存值。 如果字段读取节点被替换成一个常量，将进一步触发更多优化。 删除不可达条件分支代码，死循环后的代码。 即时编译器将在 volatile 字段访问前后插入内存屏障节点。 内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。 加锁、解锁操作会阻止即时编译器的字段读取优化。 字段存储优化 即时编译器会消除冗余的存储节点。 如果字段被标记为 volatile，即时编译器不能将冗余的存储操作消除掉。 死代码消除（dead code eliminiation） 消除局部变量的死存储（dead store）（涉及冗余存储）。 消除不可达分支。 问题Q：思考即时编译器会怎么优化下面代码中的除法操作？ 12345int bar(int x, int y) &#123; int t = x/y; t = x+y; return t;&#125; A：除法无法优化，因为可能存在除零异常。s即时编译器需要判断除数是否为 0。 引用 https://time.geekbang.org/column/article/39683]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-23逃逸分析]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-23%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[逃逸分析 一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。 在 JVM 的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。 判断对象是否逃逸的依据 对象是否被存入堆中（静态字段或者堆中对象的实例字段）。 对象是否被传入未知代码中（对象是否作为方法调用的调用者或者参数）。 方法中未被内联的方法调用当成未知代码。 可以认为方法调用的调用者以及参数是逃逸的。 通常逃逸分析放在方法内联之后。 基于逃逸分析的优化锁消除 如果能证明锁对象不逃逸，对该锁对象的加锁、解锁操作没有意义。 因为其他线程不能获得该所对象，即时编译器可以消除加锁、解锁操作。 传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。 由于即时编译的限制，条件被强化为证明锁对象不逃逸出当前编译的方法。 基于逃逸分析的锁消除实际上不多见。 栈上分配（HotSpot 虚拟机未采用） 如果逃逸分析能证明某些新建的对象不逃逸，可以将其分配至栈上。 new 语句所在的方法退出时，弹出当前方法的栈桢自动回收内存空间。 无须借助垃圾回收器处理。 实现需要更改大量假设“对象只能堆分配”的代码。 标量替换 标量：就是仅能存储一个值的变量，如局部变量。聚合量：可能同时存储多个值，如 Java 对象。 可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。 对象没有被实际分配，和栈上分配一样。 可以减轻垃圾回收的压力。 与栈上分配相比，对字段的内存连续性不做要求。 字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。 部分逃逸分析（partial escape analysis） C2 的逃逸分析与控制流无关。 Graal 引入一个与控制流有关的逃逸分析，即部分逃逸分析。 部分逃逸分析能够优化更多的情况，编译时间更长。 解决所新建的实例仅在部分程序路径中逃逸的情况。 根据控制流信息，判断出新建对象仅在部分分支中逃逸，将对象的新建操作推延至对象逃逸的分支中。 使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行 if-else 分支的程序路径之中。（不懂） 引用 https://time.geekbang.org/column/article/18048]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-22HotSpot虚拟机的intrinsic]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-22HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84intrinsic%2F</url>
    <content type="text"><![CDATA[HotSpot 虚拟机中，所有被标注 @HotSpotIntrinsicCandidate 注解的方法都是 HotSpot intrinsic。 这些方法的调用，会被 HotSpot 虚拟机替换成高效的指令序列。原本的方法实现则会被忽略掉。 如果 Java 核心类库的开发者更改了原本的实现，虚拟机中的高效实现也需要进行相应的修改。 其他虚拟机不一定维护了这些 intrinsic 的高效实现。 这些高效实现通常依赖于具体的 CPU 指令，而这些 CPU 指令不好在 Java 源程序中表达。 如果换了一个体系架构，可能没有对应的 CPU 指令，无法进行 intrinsic 优化。 intrinsic 与方法内联独立的桩程序 可以被解释执行器利用，直接替换对原方法的调用。 可以被即时编译器所利用，把代表对原方法的调用的 IR 节点，替换为对这些桩程序的调用的 IR 节点。 这种形式实现的比较少，主要包括 Math 类的一些方法。 特殊的编译器 IR 节点 只能被即时编译器所用。 将对原方法的调用的 IR 节点，替换成特殊的 IR 节点，并参与接下来的优化过程。 替换过程是在方法内联时进行。 native 方法被标记为 intrinsic 也能够 “ 内联 “ 进来，并插入特殊的 IR 节点。 即时编译器的后端根据这些特殊的 IR 节点，生成指定的 CPU 指令。-native 方法经过 intrinsic 优化之后，JNI 开销直接消失不见，最终的结果十分高效。 大部分实现通过这种形式。 已有 intrinsic 简介 最新版本的 HotSpot 虚拟机定义了三百多个 intrinsic（Java 10.0.2）。 有三成以上是Unsafe类的方法。 引用 https://time.geekbang.org/column/article/18046]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-Android学习路线指南]]></title>
    <url>%2F2018%2F11%2F14%2F%E8%BD%AC-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[转自《Android 开发艺术探索》作者 —— 任玉刚转载请注明出处：https://blog.csdn.net/singwhatiwanna/article/details/49560409 前言看到一篇文章中提到“最近几年国内的初级Android程序员已经很多了，但是中高级的 Android 技术人才仍然稀缺“，这的确不假，从我在百度所进行的一些面试来看，找一个适合的高级 Android 工程师的确不容易，一般需要进行大量的面试才能挑选出一个比较满意的。为什么中高级 Android 程序员不多呢？这是一个问题，我不好回答，但是我想写一篇文章来描述下 Android 的学习路线，期望可以帮助更多的 Android 程序员提升自己。由于我也是从一个菜鸟过来的，所以我会结合我的个人经历以及我对 Android 学习过程的认识来写这篇文章，这会让这篇文章更加真实，而并非纸上谈兵。 我的工作经历前面说到，我也是从一个 Android 菜鸟过来的。其实这句话放在任何人的身上都是适用的，即大家都是一步步过来的，因此作为初学者也不必因为技术差而郁闷，同理，高手也不要看不起一些所谓的菜鸟，因为这不公平，技术只有在同等的工作年限上才具有一定的可比性，也许你眼中的菜鸟只是个工作半年的新手，而你已经工作 5 年，可想而知，这根本不具有可比性，搞不好别人 5 年后可以达到比你更高的技术高度。 我有若干个技术 QQ 群，群里（481798332）的小伙伴对我的工作经历比较感兴趣，刚好在这里我就做下介绍。我是硕士研究生毕业，我已经工作 3 年零 3 个月了，职位上从最开始的腾讯初级工程师变成了现在的百度 Android 资深工程师。最开始我并不是做 Android 的，先是做了半年的 C++，接着做了 3 个月的 Web 前端，然后公司内部转岗做 Android 到至今，纯 Android 工作年限的话其实是 2.5 年。但是我认为我的 Android 工作经验（注：工作年限不等同于工作经验）不止 2.5 年，我投入大量的业余时间在 Android 开发上，并且我习惯去思考问题、总结问题并将其融会贯通，因此我的 Android 技术在短时间内有了很大的提升。 在 Android 学习过程中，初学者踩过的坑我也都踩过，我也深深地知道大家在学习过程中最棘手的问题是什么。举个例子，在 3 年前，我想在 SlidingMenu 中放入一个 ListView，发现二者总是不能很好地一起工作，这肯定是由于滑动冲突的问题，我也知道，但是不知道怎么解决。我就去学校图书馆翻遍了所有的 Android 书籍，无果。大家肯定都知道原因，为什么我无法从书中查找到问题的答案，因为入门书不讲滑动冲突，所谓的高级编程书也不讲。还有一个问题，我曾经以为 view.post(runnable) 可以让 runnable 的 run 方法在线程中执行，所以我就在 run 方法里面去做耗时的操作，现在想想我当时是多菜啊，因此我曾经也是菜鸟。 直到若干年后的某一天，我终于琢磨透了滑动冲突的事，然后我就把解决问题的思想写在了 CSDN 博客上，但是好像看得人并不多，很多人并不能体会我的用心，后来我博客的访问量越来越大，这才慢慢地得到了一些人的关注。后来有一天我有了写书的契机，我想到了我最开始学习 Android 时所踩过的坑，想到滑动冲突对我的困扰，为了更好地传播我的技术经验，为了让更多的人少踩一些坑，为了让更多地人成为 Android 高级工程师，我毅然决定将 Android 开发中最重要的、最疑难的、最容易困扰大家的、成为高级工程师所必备的知识点和盘托出，这就是《Android 开发艺术探索》存在的原因以及意义。书的反响怎么样呢？从目前读者的评价来看，内容基本无差评，我收到了很多读者的肯定以及感谢，这说明很多人能够理解我的用心。 说了那么多，言归正传，下面说下 Android 学习路线的话题，本文打算从 4 个阶段来对 Android 的学习过程做一个全面的分析，分别为 Android 初级、中级、高级以及资深工程师，具体请看下面的分析。同理，本篇学习路线仍然只针对 Android 应用开发，不针对 Rom 开发和逆向工程等。这里虚拟一位“小明”的角色，在这里小明就是 Android 初学者的代表。 初级工程师小明之前完全没接触过 Android 开发，是个应届生，他的待遇是 13k，然后小明以校招的身份进入了百度，然后小明需要怎么学习才能成为初级工程师呢？这个时候，小明对编程基础、数据结构、C 语言都有一定基础，Java 语法什么的也都掌握的比较好，Android 才有 java 语言，无奈的是小明并不会搞 Android。 小明首先需要购买一本 Android 入门的书籍，为了更快地学习 Android，小明业余时间也都用来一边看书一边照着书中的例子敲代码，结果 2 周时间小明就把这本书学了一遍。看完这本书后，小明对 Android 的历史、结构、代码规范等都有了一个大概的了解，并且，小明已经可以写出一些简单的 Activity 了。这个时候在小明眼里，Android 开发很简单很好玩，通过在 xml 中摆放一些按钮文本框什么的就可以做一些界面了。 小明开始跟着他的技术导师做需求，一些简单的小需求小明自然是不在话下了。突然有一天来了一个需求，该需求要求小明在 Activity 中为一个 button 加一个动画效果，小明慌了：“完全没接触过，书上也没有讲，怎么办呢？”小明冷静了下，打开了百度搜索，输入“Android 动画”，打开前几个链接，小明恍然大悟，照着网上的例子把需求给实现了。后来导师告诉他：“学好 Android，官方文档是必须看的，既全面又权威”。然后小明如获至宝，花了一年时间把上面的 guide 和 training 都看了一遍，并且他还动手抄了几个小例子。 有一天，小明又需要做一个动画相关的需求，这可难不倒小明，它熟练地打开了 www.baidu.com，输入“Android 动画”，突然他楞了一下：”总不能每次写动画都要百度一下吧！“，于是他在 CSDN 开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用百度去搜了，事实如何呢？后面再写动画相关的代码，小明的确不用再去百度搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小明还学会了把一些琐碎的不方便放在博客上的东西写到了印象笔记上面，什么时候忘了 10 秒钟以内都可以快速找回来，而不是花 10 分钟去再次搜索一遍。 这里总结一下，Android 入门的时候，需要有一本入门书，好好学习书中的内容，同时花一年时间把 Android 官方文档中的 training 和 guide 看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。 技术要求： 基本知识点 比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐 《第一行代码 Android》、《疯狂 Android》 中级工程师小明经过一年的努力学习终于成为 Android 中级工程师了，月薪变成了 17k。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小明还不能一个人承担起来，这个时候小明需要学习的内容就很多了，如下所示： AIDL：熟悉 AIDL，理解其工作原理，懂 transact 和 onTransact 的区别； Binder：从 Java 层大概理解 Binder 的工作原理，懂 Parcel 对象的使用； 多进程：熟练掌握多进程的运行机制，懂 Messenger、Socket 等； 事件分发：弹性滑动、滑动冲突等； 玩转 View：View 的绘制原理、各种自定义 View； 动画系列：熟悉 View 动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉 mat 等工具 懂点常见的设计模式 学习方法阅读进阶书籍，阅读 Android 源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有 2 个点是比较困扰大家的，一个是阅读源码，另一个是自定义 View 以及滑动冲突。 如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。 如何玩转自定义 View 呢？我的建议是不要通过学习自定义 view 而学习自定义 view。为什么这么说呢？因为自定义 view 的种类太多了，各式各样的绚丽的自定义效果，如何学的玩呢！我们要透过现象看本质，更多地去关注自定义 view 所需的知识点，这里做如下总结： 搞懂 view 的滑动原理 搞懂如何实现弹性滑动 搞懂 view 的滑动冲突 搞懂 view 的 measure、layout 和 draw 然后再学习几个已有的自定义 view 的例子 最后就可以搞定自定义 view 了，所谓万变不离其宗 大概再需要 1-2 年时间，即可达到高级工程师的技术水平。我个人认为通过《Android 开发艺术探索》和《Android 群英传》可以缩短这个过程为 0.5-1 年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。 技术要求： 稍微深入的知识点 AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义 View、消息队列等 书籍推荐 《Android 开发艺术探索》、《Android 群英传》 高级工程师小明成为了梦寐以求的高级工程师，月薪达到了 20k，还拿到了一丢丢股票。这个时候小明的 Android 水平已经不错了，但是小明的目标是资深工程师，小明听说资深工程师月薪可以达到 30k+。 为了成为 Android 资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解 SystemServer 的启动过程 了解主线程的消息循环模型 了解 AMS 和 PMS 的工作原理 能够回答问题”一个应用存在多少个 Window ？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity 的启动模式以及异常情况下不同 Activity 的表现 Service 的 onBind 和 onReBind 的关联 onServiceDisconnected(ComponentName className) 和 binderDied() 的区别 AsyncTask 在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识 学习方法这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，最近一本新书推荐给大家《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到 Android 源码中的设计思想，我最近也在阅读此书。 技术要求： 稍微深入的知识点 系统核心机制 基本知识点的细节 设计模式和架构 书籍推荐 《Android 开发艺术探索》、《Android 源码设计模式解析与实战》、《Android 内核剖析》 资深工程师这个阶段的程序员也许并没有太具体的学习路线了。]]></content>
      <categories>
        <category>学习指南</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-2021方法内联]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-2021%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%2F</url>
    <content type="text"><![CDATA[在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。 可以消除调用本身带来的性能开销。 可以进一步触发更多的优化。 可以算是编译优化里最为重要的一环。 机器码的生成即时编译器首先解析字节码，并生成 IR 图，然后在该 IR 图上进行优化。优化是由一个个独立的优化阶段（optimization phase）串联起来的。每个优化阶段都会对 IR 图进行转换。最后即时编译器根据 IR 图的节点以及调度顺序生成机器码。 C2 方法内联在解析字节码的过程中完成。 每当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用。如果需要内联，则开始解析目标方法的字节码。 Graal 方法内联在解析字节码的过程中完成。 拥有一个独立的优化阶段，寻找指代方法调用的 IR 节点，替换为目标方法的 IR 图。 独立优化阶段 将被调用方法的 IR 图节点复制到调用者方法的 IR 图中。 被调用方法的传入参数节点，将被替换为调用者方法进行方法调用时所传入参数对应的节点。 在调用者方法的 IR 图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。 如果被调用方法存在多个返回节点，则生成一个 Phi 节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。 在接下来的编译过程中对新的 IR 图进行进一步优化。 方法内联的条件 内联越多➡生成代码的执行效率越高。 内联越多➡编译时间也就越长➡程序达到峰值性能的时刻将被推迟。 内联越多➡生成的机器码越长。 JVM 中编译生成的机器码会被部署到 Code Cache 之中。Code Cache 有大小限制。Code Cache 已满时，出现即时编译已被关闭的警告信息。 即时编译器根据这些规则决定方法调用能否被内联。 方法调用指令所在的程序路径的热度 目标方法的调用次数及大小 当前 IR 图的大小 内联算法更青睐于小方法。 特殊规则 自动拆箱总会被内联。 Throwable 类的方法不能被其他类中的方法所内联。 强制内联 由 -XX:CompileCommand 中的 inline 指令指定的方法。 由 @ForceInline 注解的方法（仅限于 JDK 内部方法）。 不被内联 由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法。 由 @DontInline 注解的方法（仅限于 JDK 内部方法）。 无法内联 调用字节码对应的符号引用未被解析。 目标方法所在的类未被初始化。 目标方法是 native 方法。 不支持内联 C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整）。 1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。 静态方法调用 即时编译器可以轻易地确定唯一的目标方法。 虚方法调用 非 static、非 private 、非 final 方法都是虚方法。 换句话说可以被重写的方法都是虚方法。 即时编译器需要先对虚方法调用进行去虚化（devirtualize），即转换为一个或多个直接调用，然后才能进行方法内联。 完全去虚化 通过类型推导或者类层次分析（class hierarchy analysis），识别虚方法调用的唯一目标方法，将其转换为直接调用。 关键在于证明虚方法调用的目标方法是唯一的。 基于类型推导的完全去虚化 类型推导属于全局优化，比较浪费时间。 通过数据流分析推导出调用者的动态类型。 如果生成 Sea-of-Nodes IR 后，调用者的动态类型已能够直接确定，就进行去虚化。 如果需要额外的数据流分析才能确定，不做，节省编译时间，依赖接下来的去虚化手段优化。 基于类层次分析的完全去虚化 分析所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。如果是，调用这些方法只能调用至该具体实现中。 无法保证之后的执行过程只有一个具体实现。 JVM 为当前编译结果注册若干个假设（assumption）。 假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。 当新的类被加载，JVM 会重新验证假设。 如果某个假设不再成立，对其所属的编译结果去优化。 如果使用了 final 修饰符，即时编译器可以不用生成对应的假设，直接去虚化和内联。 接口方法调用（不懂） 去虚化不能移除动态类型检测。 执行 invokeinterface 指令时，JVM 必须对调用者的动态类型进行测试，是否实现了目标接口方法所在的接口。 Java 类验证器将接口类型直接看成 Object 类型，有可能出现声明类型为接口，实际类型没有继承该接口的情况。 条件去虚化（guarded devirtualization） 将虚方法调用转换为若干个类型测试以及直接调用。 关键在于找出需要进行比较的类型。 将调用者的动态类型，依次与类型 Profile 记录的类型比较。 如果匹配，直接调用该记录类型所对应的目标方法。 不匹配 如果类型 Profile 是完整的，去优化，重新收集类型 Profile。 如果类型 Profile 是不完整的，进行原本的虚调用，通过内联缓存进行调用，或者通过方法表进行动态绑定。（Graal） 在 C2 中，如果类型 Profile 是不完整的，不会进行条件去虚化，直接使用内联缓存或者方法表。 引用 https://time.geekbang.org/column/article/14575]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-19Java字节码（基础篇）]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-19Java%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[操作数栈 解释执行过程中，为 Java 方法分配栈桢时，JVM 需要开辟一块额外的空间作为操作数栈，存放计算的操作数和返回结果。 执行每一条指令之前，JVM 要求该指令的操作数已被压入操作数栈中。 在执行指令时，JVM 会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。 直接作用在操作数栈上的指令dup 指令 复制栈顶元素。 常用于复制 new 指令所生成的未经初始化的引用。 pop 指令 舍弃栈顶元素。 常用于舍弃调用指令的返回结果。 dup2 指令和 pop2 指令 long 类型或 double 类型的值占据两个栈单元。 dup 指令和 pop 指令只能处理非 long 或非 double 类型的值。 dup2 指令复制栈顶两个单元。 pop2 指令弹出栈顶两个单元。 swap 指令 交换栈顶两个元素的值。 直接将常量加载在操作数栈上的指令 常量类型包括 int 类型 long 类型 float 类型 double 类型 String 类型 Class 类型 正常情况下，操作数栈的压入弹出是一条条指令完成。 例外：抛异常时会清除操作数栈上的所有内容，然后将异常实例压入操作数栈。 int 类型为例 可以通过 iconst 指令加载 -1 至 5 之间的 int 值。 可以通过 bipush、sipush 加载一个字节、两个字节所能代表的 int 值。 可以通过 ldc 加载常量池中的常量值（如 ldc #18 将加载常量池中的第 18 项）。 局部变量区 方法栈帧的重要组成部分。 可以缓存计算的结果。 JVM 将其当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，字节码中的局部变量。 long 类型和 double 类型的值占据两个单元，其余类型占据一个单元。 生命周期没有重合的局部变量可以编排至同一单元。 存储在局部变量区的值，需要加载至操作数栈中，才能进行计算。 计算得到的结果再存储至局部变量区中。 局部变量数组的加载、存储指令需要指明所加载单元的下标。 iinc M N 指令 Java 字节码唯一能够作用于局部变量的指令。 M 为非负整数，N 为整数。 将局部变量数组的第 M 个单元中的 int 值增加 N。 常用于更新 for 循环的自增量。 Java 字节码简介Java 相关指令 new：后跟目标类，生成该类的未初始化的对象。 instanceof：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（是则压入 1，否则压入 0）。 checkcast：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例（如果不是便抛出异常）。 athrow：将栈顶异常抛出。 monitorenter：为栈顶对象加锁。 monitorexit：为栈顶对象解锁。 字段访问指令 静态字段访问指令：getstatic、putstatic。 实例字段访问指令：getfield、putfield。 这四条指令均附带用以定位目标字段的信息。 这四条指令所消耗的操作数栈元素皆不同。 方法调用指令 包括 invokestatic，invokespecial，invokevirtual，invokeinterface 和 invokedynamic。 除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素由调用类型和目标方法描述符确定。 数组相关指令 newarray：新建基本类型数组。 anewarray：新建引用类型数组。 mutianewarray：新建多维数组。 arraylength：求数组长度。 数组加载指令。 数组存储指令。 控制流指令 goto：无条件跳转指令。 tableswitch：条件跳转指令（针对密集的 cases）。 lookupswtich：条件跳转指令（针对稀疏的 cases）。 被废弃的 jsr，ret 指令。 返回指令。 除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。 问题Q：JVM 为什么使用基于栈的计算模型？ A：实现起来容易一些，但并不高效，因为没有使用底层体系架构的寄存器。在JVM中，只有解释器完整地模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。 Q：为什么局部变量要初始化？ A：①如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。②从代码规范来看，使用未经初始化的局部变量意义不明。 Q：C/C++ 的汇编指令会有大量寄存器的操作，Java 的指令会用到寄存器吗？ A：Java 字节码不会，但是底下的实现（比如解释执行器，即时编译器）是会的。 参考 https://time.geekbang.org/column/article/14794]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-18即时编译器的中间表达形式]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-18%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[目测太难看不懂。。。 待更新 https://time.geekbang.org/column/article/14270]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的视图优化方法]]></title>
    <url>%2F2018%2F11%2F07%2FAndroid%E7%9A%84%E8%A7%86%E5%9B%BE%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[过度绘制（Overdraw） 过度绘制（Overdraw）指的是屏幕上的某个像素在同一帧的时间内被绘制了多次。 检测过度绘制Android 中打开过度绘制检测工具的方式： 开发者选项 ➡ 调试GPU过度绘制 ➡ 显示过度绘制区域 界面中会出现不同颜色的区域，各颜色代表的意思： 过度绘制优化移除布局中不需要的背景移除 Window 默认的 Background通常使用的 theme 会包含一个 windowBackground。 1&lt;item name="android:windowBackground"&gt;@color/background_material_light&lt;/item&gt; 然后又给跟布局添加了一个背景，这会导致整个页面被多绘制一次。 移掉 windowBackground 即可解决，有两种方法。 在 theme 中设置 1&lt;item name="android:windowBackground"&gt;@null&lt;/item&gt; 在 onCreate() 方法中添加 1getWindow().setBackgroundDrawable(null); 移除控件中不需要的背景 父布局和子布局设置了相同的 background，选择其一设置即可。 减少透明度的使用View 设置了 alpha 值至少渲染两次。 布局优化 LinearLayout 与 RelativeLayout 作用相同时使用 LinearLayout。 LinearLayout 需要嵌套时使用 RelativeLayout。 使用 ConstraintLayout。 使用 Layout Inspector 查看 layout 层次结构 Tools &gt; Android &gt; Layout Inspector 使用 lint 优化布局的层次结构 Analyze&gt; Inspect Code Android&gt; Lint&gt; Performance &lt;include> 标签 只支持 android:layout_ 开头的属性（android:id 是特例）。 &lt;include> 指定了 id 属性，包含的布局文件根元素也指定了 id 属性，以 &lt;include> 指定的为准。 &lt;merge> 标签 配合 &lt;include> 标签使用可以减少布局的层级。 ViewStub 继承自 View，宽高都是 0，本身不参与任何的布局和绘制过程。 按需加载所需的布局文件（如网络异常时的界面），使用的时候再加载，提高初始化性能。 不支持 &lt;merge> 标签。 使用 inflateedId 属性指定加载的布局 id。 123&lt;ViewStub android:id="@+id/stub_import" android:inflatedId="@+id/panel_import" /&gt; 怎样加载？1((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); 或 1View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 加载后 ViewStub 不在属于布局，为 null。 绘制优化onDraw 方法 不要创建新的布局对象。 不要做耗时的任务。 减少自定义 View 的过度绘制 假如有多张图片叠层显示时，可以使用 Canvas 的 clipRect() 等方法将图片裁剪。 使用 GPU 呈现模式分析工具Android 中打开 GPU 呈现模式分析工具的方式： 开发者模式 ➡ 监控 ➡ GPU呈现模式]]></content>
      <categories>
        <category>Android优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
        <tag>视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-1617即时编译]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1617%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[分层编译模式HotSpot 包含的即时编译器： C1 C2 Graal（实验性质的即时编译器） Java 7 以前需要根据程序特性选择对应的即使编译器C1 执行时间较短的程序。 对启动性能有要求的程序。 C1 编译效率较快。 对应参数 -client C2 执行时间较长的程序。 对峰值性能有要求的程序。 C2 生成代码的执行效率较快。 对应参数 -server Java 7 引入分层编译 综合 C1 的启动性能优势和 C2 的峰值性能优势。 分层编译将 Java 虚拟机的执行状态分为 5 个层次。 0.解释执行 1.执行不带 profiling 的 C1 代码 2.执行仅带方法调用次数和循环回边执行次数 profiling 的C1 代码 3.执行带所有 profiling 的 C1 代码 4.执行 C2 代码 C2 代码的执行效率比 C1 代码高 30% 以上。 C1 执行效率 1 层 &gt; 2 层 &gt; 3 层。（1 层比 2 层稍高，2 层比 3 层高 30% 以上）。 profile profiling：在程序执行过程中，收集能够反映程序执行状态的数据。 这里所收集的数据我们称之为程序的 profile。 例如 JDK 附带的 hprof。 profiler 大多通过注入或 JVMTI 事件来实现。 第 0 层和第 3 层还会收集用于第 4 层 C2 编译的数据。 如：分支跳转字节码的分支 profile（branch profile）（跳转次数和不跳转次数），非私有实例方法调用指令，强制类型转换 checkcast 指令，类型测试 instanceof 指令，引用类型的数组存储 aastore 指令的 profile（receiver type profile）。 分支 profile 和类型 profile 的收集会给应用程序带来不少性能开销。 通常情况，不会在解释执行中收集分支 profile 和类型 profile。 只有触发 C1 编译后，JVM 认为可能被 C2 编译，才收集这些 profile。 比较极端情况下，JVM 才会在解释执行时收集 profile（如等待 C1 编译的方法过多时）。 C2 可以根据收集到的数据进行猜测，作出比较激进的优化。 基于分支 profile 的优化 根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉。 节省编译时间和部署代码要消耗的内存空间。 将精简程序的数据流，触发更多的优化。 根据分支 profile，计算每一条程序执行路径的概率，优化优先处理概率较高的路径。 基于类型 profile 的优化instanceof 测试 目标类型是 final 类型，只比较测试对象的动态类型是否为该类型。 目标类型是非 final 类型，依次测试该类，该类的父类、祖先类，该类所直接或者间接实现的接口。 instanceof 以及方法调用的类型 profile 假设对象的动态类型仅为类型 profile 中的那几个。 针对分支 profile 优化。 对方法调用的条件去虚化内联。 去优化 即从执行即时编译生成的机器码切换回解释执行。 当假设失败的情况下，JVM 将去优化。 生成的机器码中，即时编译器在假设失败的位置上插入一个陷阱（trap）。 陷阱实际上是一条 call 指令，调用至 Java 虚拟机专门负责去优化的方法。 与普通的 call 指令的区别：去优化方法会更改栈上的返回地址，并不再返回即时编译器生成的机器码中。 去优化过程非常复杂。 生成的机器代码和原本的字节码差异非常大。 需要将当前机器码的执行状态转换至某一字节码之前的执行状态，并从该字节码开始执行。 这便要求即时编译器在编译过程中记录好这两种执行状态的映射。 去优化的原因与优化无关 即使重新编译也不会改变生成的机器码。 生成的机器码可以在调用去优化方法时传入 Action_None。 表示保留这一份机器码。 在下一次调用该方法时重新进入这一份机器码。 去优化的原因与静态分析的结果有关 生成的机器码可以在调用去优化方法时传入 Action_Recompile。 表示不保留这一份机器码。 但是可以不经过重新 profile，直接重新编译。 去优化的原因与基于 profile 的激进优化有关 生成的机器码需要在调用去优化方法时传入 Action_Reinterpret。 表示不保留这一份机器码。 而且需要重新收集程序的 profile。 编译路径 1 层和 4 层为终止状态。 一个方法被终止状态编译后，如果编译后的代码没有失效，JVM 不再发出该方法的编译请求。 通常情况 热点方法会被第 3 层的 C1 编译，再被第 4 层的 C2 编译。 琐碎的方法 字节数少，且第 3 层的 profiling 没有可收集的数据的方法。 JVM 断定该方法对于 C1 代码和 C2 代码执行效率相同。 在第 3 层编译后，直接用第 1 层的 C1 编译。 C1 忙碌的情况 解释执行过程中进行 profiling。 然后直接由第 4 层的 C2 编译。 C2 忙碌的情况 方法先被第 2 层的 C1 编译。 再被第 3 层的 C1 编译，减少在第 3 层的执行时间。 Java 8 默认开启分层编译。 不管分层编译是否开启，原本的选择即时编译器的参数都无效（-client 和 -server）。 关闭分层编译情况下，JVM 采用 C2。 只使用 C1：使用参数 -XX:TieredStopAtLevel=1，解释执行后直接由 1 层的 C1 编译。 即时编译的触发 根据方法的调用次数和循环回边的执行次数来触发。 profiling 中包含上述次数。 解释执行和 C1 代码中增加循环回边计数器的位置不同，但不会对程序照成影响。 JVM 不对计数器进行同步，收集的几次为非精确值。 即时编译的触发不需要非常精确的值。 不启用分层编译，超过由参数 -XX:CompileThreshold 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），会触发即时编译。 启用分层编译，JVM 不采用由参数 -XX:CompileThreshold 指定的阈值，使用另一套阈值系统。阈值大小动态调整。 动态调整：比较阈值时，将阈值与某个系数 s 相乘。 该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关。 64 位 JVM中，默认情况下编译线程的总数目根据处理器数量来调整，（对应参数 -XX:+CICompilerCountPerCPU，默认为 true；当通过参数 -XX:+CICompilerCount=N 强制设定总编译线程数目时，CICompilerCountPerCPU 将被设置为 false）。 JVM 将编译线程按照 1:2 的比例分配给 C1 和 C2（至少各为 1 个）。 123对于核及以上的机器，总的编译线程的数目为：n = log2(N) * log2(log2(N)) * 3 / 2其中 N 为 CPU 核心数目。 启用分层编译时的具体触发条件： 1234当方法调用次数大于由参数 -XX:TierXInvocationThreshold 指定的阈值乘以系数，或者当方法调用次数大于由参数 -XX:TierXMINInvocationThreshold 指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数 -XX:TierXCompileThreshold 指定的阈值乘以系数时，便会触发 X 层即时编译。触发条件为：i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s &amp;&amp; i + b &gt; TierXCompileThreshold * s) OSR 编译 JVM 还存在另一种以循环为单位的即时编译（On-Stack-Replacement（OSR）编译）。 循环回边计数器用来触发这种类型的编译的。 不启用分层编译情况，触发 OSR 编译的阈值是由参数 -XX:CompileThreshold 指定的阈值的倍数。 计算方法： 1234(OnStackReplacePercentage - InterpreterProfilePercentage)/100其中 -XX:InterpreterProfilePercentage 的默认值为 33，当使用 C1 时 -XX:OnStackReplacePercentage 为 933，当使用 C2 时为 140。也就是说，默认情况下，C1 的 OSR 编译的阈值为 13500，而 C2 的为 10700。 启用分层编译的情况下，触发 OSR 编译的阈值则由参数 -XX:TierXBackEdgeThreshold 指定的阈值乘以系数。 OSR 编译在正常的应用程序中不多见。它只在基准测试时比较常见。 问题Q：为什么不把所有代码都即时编译一下呢？这样程序的执行效率不是更快吗？ A：即时编译是以方法为单位的。动态编译比较耗时，如果花了大量CPU资源编译出来的机器码运行不了几次，就很浪费了。 Q：为什么要用分层编译呢？使用最快的编译代码编译器编译的代码不是更好吗？ A：机器码越快，需要的编译时间就越长。分层编译是一种折衷的方式，既能够满足部分不那么热的代码能够在短时间内编译完成，也能满足很热的代码能够拥有最好的优化。 参考 https://time.geekbang.org/column/article/14061https://time.geekbang.org/column/article/14070]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些简单的Git命令]]></title>
    <url>%2F2018%2F10%2F21%2F%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84Git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[完整性 Git 以校验和的方式检测数据完整性。 Git 中的 commit id 是校验和。 文件状态和工作区域 工作区域： 工作目录：写代码的区域。 暂存区：代码 add 后 commit 前所在的区域。 本地仓库：代码 commit 后所在的区域。 文件状态： 已修改：工作目录已修改，代码未 add。 已暂存：代码已 add，未 commit。 已提交：代码已 commit。 用户身份 配置个人信息 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;example@email.com&quot; 查看个人信息 1$ git config --list 创建本地仓库 初始化本地仓库 1$ git init 从远程仓库克隆 1$ git clone ssh/https地址 本地操作 添加文件到暂存区 1$ git add readme.txt 添加所有文件到暂存区 1$ git add . 提交暂存区文件到本地仓库 1$ git commit -m &quot;say something&quot; 加 -m 表示直接用后面的字符串作为说明，否则跳转编辑器 查看本地仓库提交历史 1$ git log 查看文件状态 1$ git status Changes to be committed：已暂存、可提交文件 Untracked files：未暂存文件 查看未暂存文件变更细节 1$ git diff 查看已暂存文件变更细节 1$ git diff --staged 版本回退 回到上一个版本（硬回退） 1$ git reset --hard HEAD^ 回到上一个版本（软回退） 1$ git reset --soft HEAD^ hard 移除仓库中的 commit，暂存区和工作区回到之前的状态。 soft 移除仓库中的 commit，暂存区和工作区不变。 查询版本提交记录1$ git reflog ①commit id ②执行的命令 ③描述 回退到指定版本1$ git reset --hard 提交Id commit id 可以不填全部，git 自动查找。 撤销修改 撤销未添加到暂存区的修改 1$ git checkout --文件 撤销已添加到暂存区的修改 1$ git reset HEAD 文件 删除相关操作 删除文件 删除本地文件（文件管理器中删或用 rm 命令） 1$ rm 文件 确认 git 删除工作区文件 1$ git rm 文件 提交 恢复文件 1$ git checkout --文件 可以恢复未添加到暂存区的修改了的文件 可以恢复自删除的文件 远程仓库 关联远程仓库 1$ git remote add 自定义远程仓库名 ssh/https地址 第一次推送本地仓库到远程仓库 1$ git push -u 远程仓库名 远程仓库分支名 非第一次推送本地仓库到远程仓库 1$ git push 远程仓库名 远程仓库分支 从远程仓库拉取数据到本地 1$ git fetch 远程仓库名 将从远程仓库拉取的数据和本地仓库合并 1$ git merge 本地分支名 从远程仓库拉取数据并合并 1$ git pull 远程仓库名 远程分支名 fetch 只拉取远程仓库数据，不更新本地仓库状态。 pull 拉取远程仓库数据并更新本地仓库状态到远程仓库最新状态。 pull = fetch + merge 分支 创建分支 1$ git branch 分支名 切换分支 1$ git checkout 分支名 创建并切换分支 1$ git checkout -b 分支名 查看分支 1$ git branch 合并分支 1$ git branch 分支名 删除分支 1$ git branch -d 分支名 解决冲突 解决冲突后不能提交某个文件，只能提交全部文件 变基（写的不完整，无参考价值）1$ git rebase 分支名 rebase 失败先解决冲突再执行1$ git rebase --continue 变基抛弃原有提交，创建新的对应提交。 变基的提交历史是一条直线。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-15Java语法糖与Java编译器]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8EJava%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[自动装箱（auto-boxing）与自动拆箱（auto-unboxing）123456public int foo() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(0); int result = list.get(0); return result;&#125; 上段代码对应的字节码： 12345678910111213141516171819public int foo(); Code: 0: new java/util/ArrayList 3: dup 4: invokespecial java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: iconst_0 10: invokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z 16: pop 17: aload_1 18: iconst_0 19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object; 22: checkcast java/lang/Integer 25: invokevirtual java/lang/Integer.intValue:()I 28: istore_2 29: iload_2 30: ireturn 向泛型参数为 Integer 的 ArrayList 添加 int 值，字节码中调用了 Integer.valueOf 方法。 从泛型参数为 Integer 的 ArrayList 取出元素，程序期待的是 int 值，字节码中调用了 Integer.intValue 方法。 泛型与类型擦除 在字节码中，ArrayList 的 add 接受的参数类型是 Object，get 方法的返回类型是 Object。 get 方法强制向下转换类型。 泛型信息在 JVM 中会全部擦除，为了兼容引入泛型之前的代码。 为限定继承类的泛型参数擦除为 Object，限定继承类的泛型参数擦除为所限定的类。 12345class GenericTest&lt;T extends Number&gt; &#123; T foo(T t) &#123; return t; &#125;&#125; 上段代码字节码 12345678T foo(T); descriptor: (Ljava/lang/Number;)Ljava/lang/Number; flags: (0x0000) Code: stack=1, locals=2, args_size=2 0: aload_1 1: areturn Signature: (TT;)TT; 方法声明和方法签名（Signature）仍存在泛型参数信息，由 Java 编译器编译其他类时使用。 桥接方法 桥接方法标识符包括 ACC_BRIDGE 和 ACC_SYNTHETIC（对于 Java 源代码不可见）。 不能直接调用桥接方法，但可通过反射调用。 泛型重写生成桥接方法123456789101112class Merchant&lt;T extends Customer&gt; &#123; public double actionPrice(T customer) &#123; return 0.0d; &#125;&#125;class VIPOnlyMerchant extends Merchant&lt;VIP&gt; &#123; @Override public double actionPrice(VIP customer) &#123; return 0.0d; &#125;&#125; actionPrice 方法符合 Java 语言的方法重写。 不符合 JVM 方法重写的定义。父类方法描述符(LCustomer)子类方法描述符(LVIP) 为了保证编译的字节码能保留重写的语言，Java 编译器额外添加了桥接方法。 1234567891011121314151617181920212223class VIPOnlyMerchant extends Merchant&lt;VIP&gt;... public double actionPrice(VIP); descriptor: (LVIP;)D flags: (0x0001) ACC_PUBLIC Code: 0: dconst_0 1: dreturn public double actionPrice(Customer); descriptor: (LCustomer;)D flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: 0: aload_0 1: aload_1 2: checkcast class VIP 5: invokevirtual actionPrice:(LVIP;)D 8: dreturn// 这个桥接方法等同于public double actionPrice(Customer customer) &#123; return actionPrice((VIP) customer);&#125; 桥接方法在字节码层面重写父类方法，并通过强制类型转换调用子类方法。 子类定义与父类参数相同，返回类型为父类方法返回类型的子类生成桥接方法12345678910111213141516171819class NaiveMerchant extends Merchant public java.lang.Double actionPrice(Customer); descriptor: (LCustomer;)Ljava/lang/Double; flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: dconst_0 1: invokestatic Double.valueOf:(D)Ljava/lang/Double; 4: areturn public java.lang.Number actionPrice(Customer); descriptor: (LCustomer;)Ljava/lang/Number; flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokevirtual actionPrice:(LCustomer;)Ljava/lang/Double; 5: areturn JVM 允许两个同名、同参数类型、不同返回类型的方法。 foreach数组循环从 0 到末尾逐一访问数组元素。 Iterable 对象循环调用 hasNext 和 next 方法 遍历元素。 字符串 switch case 比较字符串的哈希值。 哈希值相同的字符串用 equals 比较。 参考 https://time.geekbang.org/column/article/13781]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-14Java虚拟机是怎么实现synchronized的？]]></title>
    <url>%2F2018%2F10%2F17%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0synchronized%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[声明 synchronized 的代码块，字节码包含 monitorenter 和 monitorexit 指令。 这两种指令会消耗操作数栈上的一个引用类型的元素。 这个元素是用来加解锁的锁对象。（synchronized 括号里的引用，实例方法是 this，静态方法是 class实例）。 用 synchronized 标记方法，字节码中方法的访问标记包括 ACC_SYNCHRONIZED。 monitorenter 和 monitorexit作用可以抽象地理解为每个锁对象有： 一个锁计数器 一个指向持有该锁的线程的指针 执行 monitorenter 计数器为0 说明没有被其他线程所持有。 锁对象的持有线程设置为当前线程。 计数器加 1。 计数器不为0 如果锁对象的持有当前线程，计数器加 1。 否则等待，直至锁释放。 执行 monitorexit 锁对象的计数器减 1。 减为 0 时，锁被释放。 为什么采用计数器的方式？ 允许同一个线程重复获取同一把锁。 HotSpot 虚拟机中具体的锁实现。 重量级锁 JVM中最基础的锁实现。 阻塞加锁失败的线程，锁被释放时唤醒。 阻塞及唤醒依靠操作系统完成，开销大。 自旋状态 为了尽量避免昂贵的线程阻塞、唤醒操作。 在线程进入阻塞状态之前，或被唤醒后竞争不到锁的情况下进入自旋状态。 在处理器上空跑并且轮询锁是否被释放。 与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。 JVM 不能根据等待时间的长短来选择自旋还是阻塞。 JVM 采用自适应自旋，根据以往自旋等待时能否获得锁，动态调整自旋时间（循环数目）。 自旋状态的副作用：不公平的锁机制 阻塞状态的线程，没有办法立刻竞争被释放的锁。 自旋状态的线程，很有可能优先获得锁。 轻量级锁 没有锁竞争的情况。 怎样区分轻量级锁和重量级锁？对象头的标记字段（mark word）最后两位用来表示该对象的锁状态。 值 含义 00 轻量级锁 01 无锁或偏向锁 10 重量级锁 11 垃圾回收标记 加锁操作判断是否是重量级锁 判断为非重量级锁 在当前线程的当前栈桢中划出一块空间作为该锁的锁记录。 将锁对象的标记字段复制到锁记录中。 JVM 尝试用 CAS 操作替换锁对象的标记字段。（不懂）比较标记字段是否为X…X01 是，替换为锁记录地址，成功获得锁，继续执行。 否 线程重复获得同一把锁，JVM 将锁记录清理，代表锁被重复获取。 其他线程持有锁，JVM 将该锁膨胀为重量级锁，阻塞该线程。 解锁操作锁记录值为 0重复进入同一把锁，直接返回。（不懂） 锁记录值不为 0JVM 尝试用 CAS 操作比较标记字段是否为当前锁记录地址 是，替换为锁记录的值，锁释放。 否，表示锁已膨胀为重量级锁，进入重量级锁释放过程。 偏向锁加锁操作 锁对象支持偏向锁。 JVM 通过 CAS 操作，将当前线程地址记录在锁对象的标记字段，将标记字段最后三位设为 101。 线程请求锁时判断锁对象标记字段： 最后三位是否为 101 是否包含当前线程的地址 epoch 值是否和锁对象的类的 epoch 值相同 都满足则当前线程持有该偏向锁，直接返回。 2 不满足，epoch 值相等时，JVM 需要撤销该偏向锁。 2 满足，epoch 值不等时，当前线程可以将该锁重偏向至自己。 epoch 值 每个类维护一个 epoch 值。 设置偏向锁时，JVM 要将 epoch 值复制到锁对象标记字段中。 撤销偏向锁要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。 某类锁对象撤销数超过一个阈值，JVM 宣布该类偏向锁失效。 宣布偏向锁失效时，JVM 将该类的 epoch 值加 1。 为了保证当前持有偏向锁并且已加锁的线程不丢锁， JVM 遍历所有线程的 Java 栈，找出该类已加锁实例， 将标记字段的 epoch 值加 1（需要所有线程处于安全点状态）。 总撤销数超过另一个阈值 JVM 认为这个类不再适合偏向锁。 JVM 会撤销该类实例的偏向锁， 之后加锁直接设置轻量级锁。 参考 https://time.geekbang.org/column/article/13530]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-13Java内存模型]]></title>
    <url>%2F2018%2F08%2F31%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[编译器优化的重排序 保证遵守 as-if-serial 属性。 操作之间存在数据依赖，不能调整顺序。 Java 内存模型与 happens-before 关系 用来描述两个操作的内存可见性。 操作 X happens-before 操作 Y，X 的结果对于 Y 可见。 happens-before 关系具有传递性。 解决这种数据竞争的关键：构造一个跨线程的 happens-before 关系。 线程间的 happens-before 关系： 解锁操作 happens-before 之后（时钟顺序）对同一把锁的加锁操作。 volatile 字段的写操作 happens-before 之后（时钟顺序）对同一字段的读操作。 线程的启动操作（Thread.starts()） happens-before 该线程的第一个操作。 线程的最后一个操作 happens-before 它的终止事件（Thread.isAlive() 或 Thread.join()）。 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。 构造器中的最后一个操作 happens-before 析构器的第一个操作。 Java 内存模型的底层实现 通过内存屏障（memory barrier）禁止重排序。 开不太懂，之后再看 参考 https://time.geekbang.org/column/article/13484]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-1112垃圾回收]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-1112%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[如何辨别对象是否死亡引用计数法（reference counting） 为每个对象添加一个引用计数器。 为 0 时死亡。 缺点： 需要额外的空间。 更新操作繁琐。 无法处理循环引用对象（a 与 b 相互引用）。 可达性分析GC Roots（由堆外指向堆内的引用）包括不限于： Java 方法栈桢中的局部变量。 已加载类的静态变量。 JNI handles。不懂 已启动且未停止的 Java 线程。 可达性分析算法： 将一系列 GC Roots 作为初始的存活对象合集（live set）。 标记（mark）：从该合集出发，探索所有能够被该集合引用到的对象，将其加入到该集合中。 未被探索到的对象是死亡的，是可以回收的。 需要解决的问题： 在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。 Stop-the-world 停止其他非垃圾回收线程的工作，直到完成垃圾回收。 暂停时间（GC pause）。 安全点（safepoint） 当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。 本地代码的安全点 Java 程序通过 JNI 执行本地代码时，这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法。 API 入口处进行安全点检测（safepoint poll）。 解释执行字节码的安全点 字节码与字节码之间。 有安全点请求时，执行一条字节码进行一次安全点检测。 执行即时编译器生成的机器码 生成机器码时，即时编译器插入安全点检测。 HotSpot 虚拟机：在生成代码的方法出口、非计数循环的循环回边（back-edge）处插入。 阻塞的线程属于安全点。垃圾回收的三种方式清除（sweep） 把死亡对象所占据的内存标记为空闲内存，记录在一个空闲列表（free list）中。 缺点： 造成内存碎片。 堆中对象必须是连续分布的，可能出现总空闲内存足够，无法分配的极端情况。 分配效率较低。 压缩（compact） 把存活的对象聚集到内存区域的起始位置，留下一段连续的内存空间。 缺点： 压缩算法有性能开销。 复制（copy） 把内存区域分为两等分，分别用两个指针 from 和 to 来维护，只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，把存活的对象复制到 to 指针指向的内存区域中，交换 from 指针和 to 指针的内容。 缺点： 1.堆空间的使用效率极其低下。 12未更新 参考 https://time.geekbang.org/column/article/13091]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-10Java对象的内存分布]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Java 新建对象的方式 new 语句 反射 Object.clone方法 反序列化 Unsafe.allocateInstance方法 压缩指针对象头（object header） 每个 Java 对象都有。 由标记字段、类型指针构成。 标记字段：存储 Java 虚拟机有关该对象的运行数据（如哈希码、GC 信息、锁信息）。 类型指针：指向该对象的类。 64 位Java虚拟机中，对象头占 16 个字节。 压缩指针 开启压缩指针：-XX:+UseCompressedOops（默认开启）。 将堆中原本 64 位的 Java 对象指针压缩成 32 位。 类型指针也被压缩成 32 位，对象头的大小从 16 字节降至 12 字节。 还可以作用于引用类型的字段，引用类型数组。 内存对齐 虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8。 默认情况，堆中对象（包括字段之间）起始地址要对齐至 8 的倍数。 浪费掉的空间称之为对象间的填充（padding）。 32 位压缩指针可以寻址到 2 的 35 次方个字节（32GB 地址空间，超过 32GB 会关闭压缩指针）。 压缩指针解引用：左移 3 位，再加上一个固定偏移量。 字段内存对齐的一个原因：让字段只出现在同一 CPU 的缓存行中。不懂 字段重排列 Java 虚拟机重新分配字段的顺序，达到内存对齐 参考 https://time.geekbang.org/column/article/13081]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-0809JVM是怎么实现invokedynamic的？]]></title>
    <url>%2F2018%2F08%2F10%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0809JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[invokedynamic Java 7 引入的新指令 调用机制抽象出调用点的概念 允许将调用点链接至任意符合条件的方法上 MethodHandle（方法句柄） Java 7 引入 是一个强类型的，能被直接执行的引用 可以指向静态方法、实例方法、构造器、字段 方法句柄的类型（MethodType） 由参数类型、返回类型组成 确认方法句柄是否适配的唯一关键 不关心方法的类名或方法名 方法句柄的创建通过 MethodHandles.Lookup 类 使用反射的 Method 类查找 Lookup.findStatic 查找调用 invokestatic 的方法 Lookup.findVirtual 查找调用 invokevirtual 和 invokeinterface 的方法 Lookup.findSpecial 查找调用 invokespecial 的方法 方法句柄的权限 权限检查在创建阶段完成 实际调用过程中不检查 取决于 Lookup 对象创建位置（不是方法句柄创建位置） 方法句柄的操作invokeExact 严格匹配参数类型（需要显示向上转型） @PolymorphicSignature 根据传入参数的声明类型来生成方法描述符（而不是目标方法） invoke 自动适配参数类型 会调用 MethodHandle.asType 方法生成一个适配器方法句柄 增删改通过生成另一个充当适配器的方法句柄来实现 捕获类型的 Lambda 表达式用增操作实现 增操作可以实现方法的柯里化 方法句柄的实现HotSpot 虚拟机中方法句柄调用的具体实现，只讨论DirectMethodHandle invokeExact 调用至一个共享的、与方法句柄类型相关的特殊适配器中 适配器是一个 LambdaForm 方法句柄的缺点 与反射一样是简介调用 无法内联 未更新09]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-07JVM是如何实现反射的？]]></title>
    <url>%2F2018%2F08%2F06%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-07JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[反射调用的实现Methond.invoke委派给MethodAccessor接口处理。 MethodAccessor两个具体实现： 本地方法实现反射调用 委派模式 委派实现 每个Method实例的第一次反射调用会生成一个委派实现。 委派的具体实现是一个本地实现。 Java的反射调用机制还设立了另一种动态生成字节码的动态实现。 采用委派实现，是为了能够在本地实现以及动态实现中切换。 动态实现 运行效率比本地实现要快20倍。因为动态实现无需经过Java到C++再到Java的切换。 由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上3到4倍。 InflationJava虚拟机设置了一个阈值15（可以通过 -Dsun.reflect.inflationThreshold= 来调整）。当某个反射调用的方法调用次数在 15 之下时，采用本地实现。当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为Inflation。 反射调用的Inflation机制是可以通过参数（-Dsun.reflect.noInflation=true）关闭。反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。 反射调用的开销反射api性能开销 Class.getMethod会遍历该类的公有方法。如果没有匹配到，遍历父类的公有方法。 以getMethod为代表的查找方法操作，会返回查找得到结果的一份拷贝。避免在热点代码中使用返回Method数组的方法，减少不必要的堆空间消耗。 反射本身性能开销Method.invoke是一个变长参数方法。Java编译器会在方法调用处生成一个长度为传入参数个数的Object数组，并将传入参数一一存储进该数组中。 Java编译器会对传入的基本类型参数自动装箱。Java 缓存了 [-128, 127] 中所有整数所对应的 Integer 对象。需要自动装箱的整数在这个范围之内时，返回缓存的 Integer，否则需要新建一个Integer对象。 解决方法： 扩大缓存范围（对应参数-Djava.lang.Integer.IntegerCache.high=128）。 在外部缓存自动装箱得到的Integer对象。 上面两条除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。 权限检查带来的开销 关闭权限检查。setAccessible(true) 方法内联 没有方法内联优化 逃逸分析不起效 具体代码具体分析。 参考 https://time.geekbang.org/column/article/12192]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-【工具篇】常用工具介绍]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E3%80%90%E5%B7%A5%E5%85%B7%E7%AF%87%E3%80%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[javap：查阅Java字节码 javap是一个能够将class文件反汇编成人类可读格式的工具。 选项 作用 -p 追加打印私有字段和方法 -v 尽可能打印所有信息 -c 只打印方法 -g -v选项输出基本信息 字段 作用 minor version: 0，major version: 54 class文件的版本号 flags: (0x0021) ACC_PUBLIC, ACC_SUPER 该类的访问权限 this_class: #7 该类名字 super_class: #8 父类名字 interfaces: 0 实现接口数目 fields: 4 字段数目 methods: 2 方法数目 attributes: 1 属性数目 属性：class文件所携带的辅助信息（class文件的源文件的名称）。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无须深入了解。 class文件的版本号：编译生成该class文件时所用的JRE版本。由较新的JRE版本中的javac编译而成的class文件，不能在旧版本的JRE上跑，否则，会出现异常（java.lang.UnsupportedClassVersionError）。 常量池 每一项都有一个对应的索引（如 #1）。 可能引用其他的常量池项（#1 = Methodref #8.#23）。 字段区域 字段 作用 descriptor: I 字段的类型 flags: (0x0002) ACC_PRIVATE 访问权限 声明为static final的基本类型或者字符串字段，字段区域包括它的常量值。 方法区域 方法描述符 访问权限 代码区域 代码区域开头声明 字段 作用 stack=2 操作数栈 locals=3 局部变量数目最大值 args_size=1 接收参数的个数 局部变量指的是字节码中的局部变量。 后面接着的是字节码，每条字节码均标注了对应的偏移量（bytecode index，BCI）。 异常表 使用偏移量定位每个异常处理器所监控的范围（由 from 到 to 的代码区域）。 异常处理器的起始位置（target）。 声明所捕获的异常类型（type）。any指代任意异常类型。 行数表 Java源程序到字节码偏移量的映射。 局部变量表 Java程序中每个局部变量的名字、类型以及作用域。 注：行数表和局部变量表均属于调试信息。Java虚拟机不要求class文件必备这些信息。 字节码操作数栈映射表 字节码跳转后操作数栈的分布情况。一般被Java虚拟机用于验证所加载的类，和即时编译相关的一些操作，正常情况下，无须深入了解。 OpenJDK项目Code Tools：实用小工具集ASMTools反汇编操作命令1$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm 汇编操作命令1$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm JOL查阅Java虚拟机中对象的内存分布12$ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap ASM：Java字节码框架 ASM既可以生成新的class文件，也可以修改已有的class文件。 辅助类ASMifier，接收一个 class文件，输出一段生成该class文件原始字节数组的代码。 附录1234567891011121314151617public class Foo &#123; private int tryBlock; private int catchBlock; private int finallyBlock; private int methodExit; public void test() &#123; try &#123; tryBlock = 0; &#125; catch (Exception e) &#123; catchBlock = 1; &#125; finally &#123; finallyBlock = 2; &#125; methodExit = 3; &#125;&#125; 编译后用javap查阅字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128$ javac Foo.java$ javap -p -v FooClassfile ../Foo.class Last modified ..; size 541 bytes MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d Compiled from &quot;Foo.java&quot;public class Foo minor version: 0 major version: 54 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #7 // Foo super_class: #8 // java/lang/Object interfaces: 0, fields: 4, methods: 2, attributes: 1Constant pool: #1 = Methodref #8.#23 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #7.#24 // Foo.tryBlock:I #3 = Fieldref #7.#25 // Foo.finallyBlock:I #4 = Class #26 // java/lang/Exception #5 = Fieldref #7.#27 // Foo.catchBlock:I #6 = Fieldref #7.#28 // Foo.methodExit:I #7 = Class #29 // Foo #8 = Class #30 // java/lang/Object #9 = Utf8 tryBlock #10 = Utf8 I #11 = Utf8 catchBlock #12 = Utf8 finallyBlock #13 = Utf8 methodExit #14 = Utf8 &lt;init&gt; #15 = Utf8 ()V #16 = Utf8 Code #17 = Utf8 LineNumberTable #18 = Utf8 test #19 = Utf8 StackMapTable #20 = Class #31 // java/lang/Throwable #21 = Utf8 SourceFile #22 = Utf8 Foo.java #23 = NameAndType #14:#15 // &quot;&lt;init&gt;&quot;:()V #24 = NameAndType #9:#10 // tryBlock:I #25 = NameAndType #12:#10 // finallyBlock:I #26 = Utf8 java/lang/Exception #27 = NameAndType #11:#10 // catchBlock:I #28 = NameAndType #13:#10 // methodExit:I #29 = Utf8 Foo #30 = Utf8 java/lang/Object #31 = Utf8 java/lang/Throwable&#123; private int tryBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int catchBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int finallyBlock; descriptor: I flags: (0x0002) ACC_PRIVATE private int methodExit; descriptor: I flags: (0x0002) ACC_PRIVATE public Foo(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public void test(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: iconst_0 2: putfield #2 // Field tryBlock: 5: aload_0 6: iconst_2 7: putfield #3 // Field finallyBlock:I 10: goto 35 13: astore_1 14: aload_0 15: iconst_1 16: putfield #5 // Field catchBlock:I 19: aload_0 20: iconst_2 21: putfield #3 // Field finallyBlock:I 24: goto 35 27: astore_2 28: aload_0 29: iconst_2 30: putfield #3 // Field finallyBlock:I 33: aload_2 34: athrow 35: aload_0 36: iconst_3 37: putfield #6 // Field methodExit:I 40: return Exception table: from to target type 0 5 13 Class java/lang/Exception 0 5 27 any 13 19 27 any LineNumberTable: line 9: 0 line 13: 5 line 14: 10 line 10: 13 line 11: 14 line 13: 19 line 14: 24 line 13: 27 line 14: 33 line 15: 35 line 16: 40 StackMapTable: number_of_entries = 3 frame_type = 77 /* same_locals_1_stack_item */ stack = [ class java/lang/Exception ] frame_type = 77 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ] frame_type = 7 /* same */&#125;SourceFile: &quot;Foo.java&quot; 参考 https://time.geekbang.org/column/article/12423]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater中inflate方法各参数作用]]></title>
    <url>%2F2018%2F08%2F03%2FLayoutInflater%E4%B8%ADinflate%E6%96%B9%E6%B3%95%E5%90%84%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、三个参数的方法inflate(@LayoutRes int, @Nullable ViewGroup, boolean):View 1.1第二个参数不为null且第三个参数为true 指定id布局根布局节点各个属性有效 添加到父布局 1.2第二个参数不为null且第三个参数为false 指定id布局根布局节点各个属性有效 不添加到父布局 1.3第二各参数为null 指定id布局根布局节点宽高属性无效 2、两个参数的方法inflate(@LayoutRes int, @Nullable ViewGroup):View 2.1第二个参数不为null等同于1.1 2.2第二个参数为null等同于1.3 参考 https://blog.csdn.net/u012702547/article/details/52628453]]></content>
      <categories>
        <category>Android视图</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中进制转换]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E4%B8%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[十进制转二、八、十六进制Integer.toBinaryString():StringInteger.toOctalString():StringInteger.toHexString():String 返回值为字符串。 任意进制转十进制Integer.valueOf(String,int):IntegerInteger.parseInt(String,int):int 第二个参数指定基数，将字符串参数解析为有符号的整数。]]></content>
      <categories>
        <category>进制转换</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android透明状态栏与沉浸模式总结]]></title>
    <url>%2F2018%2F08%2F02%2FAndroid%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E6%B2%89%E6%B5%B8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java实现通过Java代码实现的思路是通过当前界面DecorView设置UI可见性实现。 flag 作用 SYSTEM_UI_FLAG_FULLSCREEN 请求进入普通全屏模式 SYSTEM_UI_FLAG_HIDE_NAVIGATION 请求暂时隐藏系统导航栏 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION SYSTEM_UI_FLAG_LAYOUT_STABLE 当使用其他布局标志时，提供内容插入的稳定视图 SYSTEM_UI_FLAG_IMMERSIVE_STICKY 通过组合上面的6中flag实现各种效果 隐藏状态栏支持Android4.1及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN;getWindow().getDecorView().setSystemUiVisibility(option); 注：下滑顶部会重新显示 透明状态栏支持Android5.0及以上 123int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;getWindow().getDecorView().setSystemUiVisibility(option);getWindow().setStatusBarColor(Color.TRANSPARENT); 隐藏状态栏及导航栏支持Android4.1及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;getWindow().getDecorView().setSystemUiVisibility(option); 注：点击屏幕会退出全屏 透明状态栏及透明导航栏支持Android5.0及以上 1234int option = int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;getWindow().getDecorView().setSystemUiVisibility(option);getWindow().setStatusBarColor(Color.TRANSPARENT);getWindow().setNavigationBarColor(Color.TRANSPARENT); 沉浸模式支持Android4.4及以上 12int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;getWindow().getDecorView().setSystemUiVisibility(option); 注：滑动状态栏或导航栏的位置显示状态栏和导航栏，一段时间未操作再次隐藏 XML实现通过设置activity的style实现 隐藏状态栏1234&lt;style name="AppTheme" parent="@style/Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowFullscreen"&gt;true&lt;/item&gt;&lt;/style&gt; 透明状态栏Android4.4 1234&lt;style name="fullScreenTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;&lt;/style&gt; 如果添加了DrawerLayout需要设置，否则DrawerLayout部分状态栏是灰色的。 12mDrawerLayout.setFitsSystemWindows(true);mDrawerLayout.setClipToPadding(false); Android5.0 12345&lt;style name="fullScreenTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 参考 https://blog.csdn.net/guolin_blog/article/details/51763825 https://blog.csdn.net/do168/article/details/51587935 https://blog.csdn.net/tc_xingdechen/article/details/68958337]]></content>
      <categories>
        <category>Android视图</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>状态栏</tag>
        <tag>沉静模式</tag>
        <tag>透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取Activity根布局]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%8E%B7%E5%8F%96Activity%E6%A0%B9%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1findViewById(android.R.id.content).getChildAt(0)；]]></content>
      <categories>
        <category>Android布局</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何修改ActionBar的字体颜色？]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9ActionBar%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[123456789101112&lt;style name="AppTheme" parent="@style/Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="actionBarStyle"&gt;@style/ActionBarStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="ActionBarStyle" parent="@style/Widget.AppCompat.ActionBar.Solid"&gt; &lt;item name="titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="TitleTextStyle" parent="@style/TextAppearance.AppCompat.Widget.ActionBar.Title"&gt; &lt;item name="android:textColor"&gt;#000000&lt;/item&gt; &lt;!-- 这里设置ActionBar字体颜色 --&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android视图</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-06JVM是如何处理异常的？]]></title>
    <url>%2F2018%2F08%2F01%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-06JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[异常的基本概念 Error：涵盖程序不应捕获的异常（JVM抛出）。程序出发Error时，执行状态已经无法恢复，需要终止线程甚至终止虚拟机。 Exception：涵盖程序可能需要捕获且处理的异常。 RuntimeException：表示“程序虽然无法继续执行，但是还能抢救一下”的情况。 RuntimeException和Error非检查异常（unchecked exception）。其他异常属于检查异常（checked exception）。 检查异常需要程序显式地捕获，或者在方法声明中用throws关键字再次抛出。 常实例的构造十分昂贵。在构造异常实例时，Java虚拟机需要生成该异常的栈轨迹（stack trace）。 逐一访问当前线程的Java栈帧。 记录下各种调试信息（方法名，方法所在类名，文件名，代码中第几行）。 Java虚拟机会忽略异常构造器和填充栈帧的Java方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。 Java虚拟机会忽略标记为不可见的Java方法栈帧。 是否可以缓存异常实例，在需要用到的时候直接抛出？ 从语法角度上，是允许的。 对应的栈轨迹并非throw语句的位置，而是新建异常的位置。 Java虚拟机是如何捕获异常的？编译生成的字节码中，每个方法都附带一个异常表。 异常表中每一个条目代表一个异常处理器。 异常处理器的组成： from指针 to指针 target指针 所捕获的异常类型 注：指针的值是字节码索引（bytecode index，bci），用来定位字节码。 from指针和to指针：标示异常处理器所监控的范围（如try代码块范围）。 target指针：指向异常处理器的起始位置（如catch代码块起始位置）。 触发异常的处理流程 Java虚拟机从上至下遍历异常表中的所有条目。 触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机判断所抛出的异常和该条目想要捕获的异常是否匹配。 如果匹配，Java 虚拟机将控制流转移至该条目target指针指向的字节码。 如果遍历完所有异常表条目，仍未匹配到异常处理器，弹出当前方法对应的Java栈帧，在调用者（caller）中重复上述操作。 finally代码块的编译，当前版本Java编译器，是复制finally代码块的内容，分别放在try-catch代码块所有正常执行路径和异常执行路径的出口中。 针对异常执行路径，Java编译器会生成一个或多个异常表条目，监控整个try-catch代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。 这些异常表条目的 target 指针将指向另一份复制的finally代码块。 在这个finally代码块的最后，Java编译器会重新抛出所捕获的异常。 如果catch代码块捕获了异常，并且触发了另一个异常，那么finally捕获并且重抛后者，忽略前者。 Java7的Suppressed异常以及语法糖Suppressed异常允许将一个异常附于另一个异常之上。 抛出的异常可以附带多个异常信息。 finally代码块缺少指向所捕获异常的引用，这个新特性使用起来非常繁琐。 try-with-resources1try ( ); // try-with-resources 在字节码层面自动使用Suppressed异常。 自动关闭资源（实现AutoCloseable接口）。 同一catch代码块捕获多种异常12345try &#123; &#125; catch (SomeException | OtherException e) &#123; &#125; 参考 https://time.geekbang.org/column/article/12134]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]传输层和应用层的协议和作用]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%BD%AC-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转载请注明出处：https://blog.csdn.net/DarkAngel1228/article/details/78581019 TCP/IP传输层概述TCP/IP是指一整套数据通信协议，传输层完成端到端的连接和传输。 TCP/IP传输层包含的两个协议 传输控制协议Transmission Control Protocol —— TCP 用户数据报协议User Dategram Protocol —— UDP 常用的TCP端口及应用TCP在网络中使用的范围很广，下面将列出一些常用的端口号及其功能.以便进一步对TCP进行检测和管理。 端口 协议 说明 80 http web服务器所开放的进程端口,用于客户端http访问 21 FTP FTP服务器所开放的控制端口,用于上传下载 23 Telnet 用于远程登录,通过连接目的计算机的这一端口,得到验证后可以远程控制管理目标计算机 25 SMTP SMTP服务器开放的端口,用于发送邮件 53 DNS DNS服务器开放的端口,当用户输入网站的名称后,由DNS负责将它解析成IP地址,这个过程中用到的端口号就是53 常用的UDP端口及应用 端口 协议 说明 7 Echo 将收到的数据包回送到发送器 53 Nameserver 域名服务 69 TFTP 简单文件传输协议 111 RPC 远程过程调用 123 NTP 网络时间协议 常用的应用层协议 缩写 全文 http 超文本传送协议 https 基于安全套接字层的http协议 ftp 文件传输协议 dns 域名系统 smtp 邮件传输协议 pop3 邮局协议 ssh 安全外壳协议 HTTP用于传输Internet浏览器使用的普通文本,超文本,音频和视频等数据端口号：TCP的80 HTTPS基于HTTP开发,提供加密,可以确保消息的私有性和完整性端口号：443 FTP用于传输文件端口号：TCP的21和20 DNS用来完成域名和IP地址之间的映射端口号：TCP或UDP的53 SMTP用于发送和接收邮件端口号：25 POP3用于客户端接收邮件端口号：110 SSH建立在应用层和传输层基础上的安全协议，ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用ssh协议可以有效防止远程管理过程中的信息泄漏问题。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-0405JVM是如何执行方法调用的？]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-0405JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[重载和重写在Java程序里，同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。这个限制可以通过字节码工具绕开。在编译完成之后，可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。 重载的方法在编译过程中即可完成识别Java编译器根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法： 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing）和可变长参数的情况下选取重载方法。 在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法。 在允许自动装拆箱和可变长参数的情况下选取重载方法。 如果Java编译器在同一阶段多种适配方法，会在其中选择一个最贴切的方法。 决定贴切程度的关键之一是形式参数类型的继承关系。 重载可以作用于这个类所继承而来的方法如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。 如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同： 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。 如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法（重写可以扩大访问权限，但不能缩小）。 注：如果子类定义了与父类中私有方法同名的方法，这两个方法之间没有任何关系。 JVM的静态绑定和动态绑定Java虚拟机识别方法的关键：类名、方法名和方法描述符（method descriptor）。 方法描述符 = 方法的参数类型+返回类型所构成 在同一个类中， 出现多个名字相同且描述符也相同的方法Java虚拟机在类的验证阶段报错。 不限制名字与参数类型相同但返回类型不同的方法出现。 Java虚拟机判定方法重写： 子类定义了与父类中非私有、非静态方法同名的方法。 方法名和方法描述符都相同。 Java语言中重写而Java虚拟机中非重写的情况： 编译器通过生成桥接方法来实现Java中的重写语义。 重载方法的区分在编译阶段已经完成，可以认为Java虚拟机不存在重载概念。 Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。 Java虚拟机中的静态绑定：在解析时便能够直接识别目标方法。 Java虚拟机中的动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法。 Java字节码中与调用相关的指令共有五种： invokestatic：用于调用静态方法。 invokespecial：用于调用私有实例方法、构造器，使用super调用父类的实例方法或构造器，和所实现接口的默认方法。 invokevirtual：用于调用非私有实例方法。 invokeinterface：用于调用接口方法。 invokedynamic：用于调用动态方法。 invokestatic和invokespecial：Java虚拟机能够直接识别具体的目标方法（静态绑定）。 invokevirtual和invokeinterface：在绝大部分情况下，虚拟机需要在执行过程中根据调用者的动态类型，来确定具体的目标方法（动态绑定）。 例外：如果虚拟机能够确定目标方法有且仅有一个（如目标方法被标记为final），可以不通过动态类型，直接确定目标方法（虚拟机可以静态绑定该方法）。 调用指令的符号引用符号引用存储在 class 文件的常量池之中。 符号引用分为：接口符号引用和非接口符号引用。 非接口符号引用该符号引用所指向的类为C，Java虚拟机查找步骤： 在C中查找符合名字及描述符的方法。 在C的父类中继续搜索，直至 Object 类。 在C所直接实现或间接实现的接口中搜索。这一步搜索得到的目标方法必须是非私有、非静态的。如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。（假如C实现了I，I继承I1，I1继承I2，那么C和I2之间就隔着I和I1） 经过上述的解析步骤之后，符号引用会被解析成实际引用。 静态绑定的方法调用：实际引用是一个指向方法的指针。 动态绑定的方法调用，实际引用是一个方法表的索引。 接口符号引用该符号引用所指向的接口为I，Java虚拟机查找步骤： 在I中查找符合名字及描述符的方法。 在Object类中的公有实例方法中搜索。 在I的父接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。 虚方法调用Java里： 所有非私有实例方法调用被编译成invokevirtual指令 所有接口方法调用都被编译成invokeinterface指令。 Java虚拟机实现动态绑定的策略为每个类生成一张方法表，用以快速定位目标方法（空间换取时间）。 方法表 类加载的准备阶段除了为静态字段分配内存之外，还会构造与该类相关联的方法表。 下面以虚方法表为例（virtual method table，vtable），接口方法（interface method table，itable）表原理类似，但稍复杂。 方法表本质：数组（元素指向一个当前类及其祖先类中非私有的实例方法）。 方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。 方法表满足两个特质： 子类方法表中包含父类方法表中的所有方法。 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。 动态绑定： Java 虚拟机将获取调用者的实际类型。 在该实际类型的虚方法表中根据索引值获得目标方法。 是否可以认为虚方法调用对性能没有太大影响？不能，上述优化实际上仅存在最坏情况中。 即时编译有两种性能更好的优化手段： 内联缓存（inlining cache） 方法内联（method inlining） 内联缓存 缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。 单态（monomorphic）指的是仅有一种状态的情况。多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。超多态（megamorphic）指的是更多种状态的情况。通常用一个具体数值来区分多态和超多态。 对于内联缓存: 单态内联缓存 多态内联缓存 超多态内联缓存 在实践中，大部分的虚方法调用均是单态的。 为了节省内存空间，Java 虚拟机只采用单态内联缓存。 内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定，有两种选择： 替换单态内联缓存中的纪录。 劣化为超多态状态（Java 虚拟机的具体实现方式）。直接访问方法表，牺牲了优化的机会，节省了写缓存的额外开销。 内联缓存并没有内联目标方法。 任何方法调用除非被内联，否则都会有固定开销。 开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。 问题Q：public final 或 public static final 的方法，是不是在虚拟机中解析为静态绑定的。 A：静态方法都是静态绑定。调用的目标方法是public final的话，HotSpot虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。 参考 https://time.geekbang.org/column/article/11539https://time.geekbang.org/column/article/12098]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-03Java虚拟机是如何加载Java类的？]]></title>
    <url>%2F2018%2F07%2F29%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-03Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Java语言的类型：基本类型（primitive types）和引用类型（reference types）。 基本类型由Java虚拟机预先定义好。 引用类型：类、接口、数组类和泛型参数。 泛型参数会在编译过程中被擦除，Java虚拟机上实际只有三种。 数组类是由Java虚拟机直接生成，其他两种有对应的字节流。 字节流形式： class文件。 程序内部直接生成。 从网络中获取。 字节流加载到Java虚拟机中，成为类或接口。 加载 查找字节流，并且据此创建类的过程。 对于数组类，它没有对应的字节流，由Java虚拟机直接生成。 对于其他类，Java虚拟机需要借助类加载器完成查找字节流的过程。 java9之前启动类加载器（boot class loader）启动类加载器由C++实现，没有对应的Java对象，Java中只能用null来指代。 启动类加载器加载最为基础、最为重要的类。如：存放在jre的lib目录加jar包中的类（以及由虚拟机参数-Xbootclasspath指定的类） 其他类加载器都是java.lang.ClassLoader的子类。类加载器需要先由另一个类加载器加载至Java虚拟机中，才能执行类加载。 扩展类加载器（extension class loader）父类加载器：启动类加载器。 加载相对次要、但又通用的类。如：存放在jre的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。 应用类加载器（application class loader）父类加载器：扩展类加载器。 加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 java9之后Java9引入了模块系统，并且略微更改了上述的类加载器。 扩展类加载器被改名为平台类加载器（platform class loader）。 Java SE中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。 双亲委派模型没当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类情况下，该类加载器才会尝试去加载。 注：父类加载器不是继承关系！！！ 其他 可以加入自定义的类加载器，来实现特殊的加载方式。如：可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。 类加载器还提供了命名空间的作用。 在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。 链接 将创建成的类合并至Java虚拟机中，使之能够只够执行的过程。它可分为验证、准备以及解析三个阶段。 验证 确保被加载类能够满足Java虚拟机的约束条件。 通常而言，Java编译器生成的类文件必然满足Java虚拟机的约束条件。 准备 为被加载类的静态字段分配内存。 部分Java虚拟机会在此阶段构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表。 解析（非必需）在class文件被加载至Java虚拟机之前，这个类无法知道其他类（甚至自己）的方法、字段所对应的具体地址。引用时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能无歧义地定位到具体目标上。 将这些符号引用解析成为实际引用。 如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。） Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。 初始化如果直接赋值的静态字段： 被 final 所修饰 类型是基本类型或字符串时 该字段便会被 Java 编译器标记成常量值（ConstantValue），初始化直接由 Java 虚拟机完成。 除此之外的直接赋值操作，所有静态代码块中的代码，会被 Java 编译器置于同一方法中，并把它命名为&lt;clinit>。 &lt;clinit>方法仅被执行一次。 JVM 规范枚举了下述多种触发类初始化的情况： 当虚拟机启动时，初始化用户指定的主类。 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类。 当遇到调用静态方法的指令时，初始化该静态方法所在的类。 当遇到访问静态字段的指令时，初始化该静态字段所在的类。 子类的初始化会触发父类的初始化。 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化。 使用反射 API 对某个类进行反射调用时，初始化这个类。 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 问题Q：加载阶段都加载哪些类呢，那么多类，全部加载吗？ A：加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。 Q：有一个零值(0/null)初始化，针对于类的静态成员变量，如果是final修饰的静态成员变量，也就是常量，是初始化为代码中指定的值比如10。非final修饰的静态成员变量，在clinit执行过程中赋值为代码中指定的值，是这样的吗？ A：被final修饰的静态成员变量，如果不是基本类型或者字符串，也会放在clinit 来做。 参考 https://time.geekbang.org/column/article/11523]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-02Java的基本类型]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-02Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。 Java 则不同，它引进了八个基本类型，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。 Java虚拟机的 boolean类型123456789public class Foo &#123; public static void main(String[] args) &#123; boolean 吃过饭没 = 2; // 直接编译的话 javac 会报错 if (吃过饭没) System.out.println(" 吃了 "); if (true == 吃过饭没) System.out.println(" 真吃了 "); &#125;&#125; Java语言规范中，boolean类型的值只有两种，用“true”和“false”表示。 Java虚拟机规范中，boolean类型被映射成int类型，“true”映射为整数1，“false”映射为整数0。 123456789101112131415# Foo.main 编译后的字节码 0: iconst_2 // 我们用 AsmTools 更改了这一指令 1: istore_1 2: iload_1 3: ifeq 14 // 第一个 if 语句，即操作数栈上数值为 0 时跳转 6: getstatic java.lang.System.out 9: ldc &quot; 吃了 &quot;11: invokevirtual java.io.PrintStream.println14: iload_115: iconst_116: if_icmpne 27 // 第二个 if 语句，即操作数栈上两个数值不相同时跳转19: getstatic java.lang.System.out22: ldc &quot; 真吃了 &quot;24: invokevirtual java.io.PrintStream.println27: return 在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。 而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。 Java的基本类型 默认值在内存中，默认值都是0。 取值范围 boolean和char是唯二的无符号类型。 boolean类型的取值范围是0或1。 char类型的取值范围是[0, 65535]。 boolean, byte, char, short的局部变量储存可以超过取值范围。 正常使用Java编译器的情况下，生成的字节码会遵守Java虚拟机规范对编译器的约束。 浮点数浮点数类型采用IEEE 754 浮点数格式。 以float为例，浮点类型通常有两个0，+0.0F 和 -0.0F。 在Java里，前者为0，后者符号位为1，其他位为0。 虽然内存数值不同，但 +0.0F == -0.0F 会返回true。 123float a = +0.0f;float b = -0.0f;float c = Float.intBitsToFloat(0x80000000); 在内存中，正无穷等于0x7F800000，负无穷等于0xFF800000。 [0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应NaN （Not-a-Number）。 一般我们计算得出的NaN（+0.0F/+0.0F），在内存中为0x7FC00000。 这个数值称为标准的NaN，其他的称为不标准的NaN。 NaN有一个特性：“!=” 始终返回true，其他比较结果都回返回false。 Java基本类型的大小Java虚拟机没调用一个Java方法，便会创建一个栈帧，这里只讨论供解释器使用的解释栈帧（interpreted frame）。 解释栈帧这种栈帧有两个主要组成部分：广义的局部变量区，字节码的操作栈。 广义局部变量包含：普遍意义的局部变量，this指针，方法参数。 局部变量在Java虚拟机规范中，局部变量区等价于一个数组。除了long、double的值用两个数组单元存储，其他基本类型以及引用类型的值均占用一个数组单元。 boolean、byte、char、short在栈上占用的空间和int、引用类型一样。32位HotSpot中占用4字节，64位HotSport中，占用8字节。这种情况仅存在于局部变量，不会出现在存储于堆中的字段或数组元素。 存储将int类型的值存到其他类型的字段或数组时，相当于做了一次隐式的掩码操作。 把0xFFFFFFFF(-1)储存到一个声明为char类型的字段里时，高两位字节被截取掉，存入“\uFFFF”。 HotSpot在存储boolean时显示进行掩码操作，只取最后一位的值存入boolean字段或数组中。 HotSpot中boolean字段占用一字节，boolean数组直接用byte数组实现。 加载Java虚拟机的算数运算几乎全部依赖于操作数栈，堆中的boolean、byte、char和short加载到操作数栈上，当成int类型运算。 对于boolean、char这两个无符号类型，加载伴随零扩展。 对于byte、short加载伴随符号扩展。 将boolean类型的值存入字段中时，Java 虚拟机所做的掩码操作123456789101112public class Foo &#123; static boolean boolValue; public static void main(String[] args) &#123; boolValue = true; // 将这个 true 替换为 2 或者 3，再看看打印结果 if (boolValue) System.out.println("Hello, Java!"); if (boolValue == true) System.out.println("Hello, JVM!"); &#125;&#125; 当替换为2的时候无输出当替换为3的时候打印HelloJava及HelloJVM因为将boolean 保存在静态域中,指定了其类型为’Z’,当修改为2时取低位最后一位为0,当修改为3时取低位最后一位为1则说明boolean的掩码处理是取低位的最后一位 问题Q：“也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。” 但是我记得boolean在内存中占1字节，char占2字节，这里是什么个意思？ A：你说的是在堆里的情况。在解释器栈上是不一样的。至于原因吗，主要是变长数组不好控制，所以就选择浪费一些空间，以便访问时直接通过下标来计算地址。 Q：使用基本类型能够在执行效率以及内存使用两方面提升软件性能。具体是什么原理呢？ A：占的空间更小，不需要类型转换。 参考 https://time.geekbang.org/column/article/11503]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-深入拆解Java虚拟机-01Java代码是怎么运行的？]]></title>
    <url>%2F2018%2F07%2F27%2F%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-01Java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[为什么Java要在虚拟机里运行？ Java作为一门高级程序语言，语法复杂，抽象程度高，直接在硬件上运行这种复杂的程序不现实。 Java虚拟机既可以硬件实现也可以软件实现，常见平台上都是软件实现，意义：“一次编写，到处运行”。 虚拟机提供了托管环境。能代替我们处理一些代码中冗长而且容易出错的部分。如：自动内存管理，垃圾回收，提供如数组越界、动态类型、安全权限等的动态检测。 Java虚拟机具体怎样运行Java字节码的？下面以标准JDK中的HotSpot虚拟机为例。 Java虚拟机会在内存中划分出堆（stack）、栈（heap）和方法区（method） 其中栈细分为： 面向Java方法的Java方法栈 面向本地方法的本地方法栈 各个线程执行位置的PC寄存器 class文件加载后存放于方法区，运行时执行方法区内的代码。 堆区 提供所有类实例和数组对象存储区域。 JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。 栈区 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中。 每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。 方法区 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 运行时常量池都分配在 Java 虚拟机的方法区之中。 Java方法调用过程 进入一个Java方法，在当前线程的Java方法栈中生成一个栈帧。栈帧的大小提前计算好。存放局部变量和字节码的操作数。不要求栈帧在内存中连续分布。 退出方法（正常或异常），弹出当前线程的当前栈帧，并舍弃。 Java字节码无法直接执行，要翻译成机器码。 HotSpot翻译字节码的两种形式解释执行逐条将字节码翻译成机器码并执行。无需等待编译。 即时编译Just-In-Time compilation, JIT将方法中包含的所有字节码编译成机器码后再执行。实际运行速度更快。 HotSpot默认采用混合模式。先解释执行，热点代码以方法为单位即时编译。 Java虚拟机的运行效率究竟是怎样的？即时编译建立再程序符合二八定律的假设上。 HotSpot内置了多个即时编译器：C1、C2和Graal。 GraalJava 10正式引入的实验性编译器。 C1（Client编译器） 面向客户端GUI程序。 对启动性能有要求。 优化手段相对简单。 编译时间短。 C2（Server编译器） 面向服务端程序。 对峰值性能有要求。 优化手段相对复杂。 编译时间较长。 生成代码执行效率较高。 Java 7 开始，HotSpot默认采用分层编译： 热点方法被C1编译。 热点方法中的热点进一步被C2编译。 HotSpot的即时编译放在额外的编译线程中。HotSpot根据CPU数量设置编译线程数目。1:2的比例配置C1和C2。 资源充足的情况下，解释执行和即时编译可同行进行。 Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同？$ echo ‘public class Foo { public static void main(String[] args) { boolean flag = true; if (flag) System.out.println(“Hello, Java!”); if (flag == true) System.out.println(“Hello, JVM!”); }}’ &gt; Foo.java$ javac Foo.java$ java Foo$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1$ awk ‘NR==1,/iconst_1/{sub(/iconst_1/, “iconst_2”)} 1’ Foo.jasm.1 &gt; Foo.jasm$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm$ java Foo JVM把boolean当做int来处理flag = iconst_1 = trueawk把stackframe中的flag改为iconst_2if（flag）比较时ifeq指令做是否为零判断，常数2仍为true，打印输出if（true == flag）比较时if_cmpne做整数比较，iconst_1是否等于flag，比较失败，不再打印输出 问题Q：对于服务端，很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。为什么不把java代码全部编译成机器码？如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益。 A：对于这种发布频率不频繁(也就是长时间运行吧？)的程序，其实选择线下编译和即时编译都一样，因为至多一两个小时后该即时编译的都已经编译完成了。另外，即时编译器因为有程序的运行时信息，优化效果更好，也就是说峰值性能更好。 A：解释执行，执行时才翻译成机器指令，无需保存不占内存。但即时编译类似预编译，编译之后的指令需要保存在内存中，这种方式吃内存，按照二八原则这种混合模式最恰当的，热点代码编译之后放入内存避免重复编译，而其他运行次数较少代码则解释执行，避免占用过多内存。 Q：什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？ A：JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)默认的分层编译应该是达到两千调C1，达到一万五调C2。 参考 https://time.geekbang.org/column/article/11289https://blog.csdn.net/zly921112/article/details/61192747]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的性能优化方法]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[布局优化 LinearLayout与RelativeLayout作用相同时使用LinearLayout。 LinearLayout需要嵌套时使用RelativeLayout。 使用ConstraintLayout。 &lt;include>标签 只支持android:layout_开头的属性（android:id是特例）。 &lt;include>指定了id属性，包含的布局文件根元素也指定了id属性，以&lt;include>指定的为准。 &lt;merge>标签 配合&lt;include>标签使用可以减少布局的层级。 ViewStub 继承自View，宽高都是0，本身不参与任何的布局和绘制过程。 按需加载所需的布局文件（如网络异常时的界面），使用的时候再加载，提高初始化性能。 不支持&lt;merge>标签。 使用inflateedId属性指定加载的布局id。 123&lt;ViewStub android:id="@+id/stub_import" android:inflatedId="@+id/panel_import" /&gt; 怎样加载？1((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); 或 1View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 加载后ViewStub不在属于布局，为null。 绘制优化onDraw方法 不要创建新的布局对象。 不要做耗时的任务。 内存泄漏优化静态变量导致的内存泄漏 静态变量引用Context。 静态变量引用View（持有Context）。 单例模式导致的内存泄漏 单例模式保存某个监听器（由Context实现）而没有解注册的方法。 属性动画导致的内存泄漏 无限循环的属性动画，Activity在onDestroy中需要停止动画（否则动画会一直播放，动画持有View，View持有Activity，Activity不能被释放）。 响应速度优化 核心思想：避免在主线程中做耗时操作。 一个进程发生ANR之后，系统会在/data/anr目录下建一个文件traces.txt。 ListView优化 别优化了，直接用RecyclerView，同理GridView。 Bitmap优化未更新 线程优化 采用线程池，避免大量的Thread。 其他 避免创建过多对象。 不要过多使用枚举，枚举占用的内存空间比整形大。 常量使用static final修饰。 Android特有的数据结构有更好的性能(SparseArray，Pair等)。 适当使用软引用和弱引用。 采用内存缓存和磁盘缓存。 尽量采用静态内部类。]]></content>
      <categories>
        <category>Android优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android架构——Clean]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94Clean%2F</url>
    <content type="text"><![CDATA[Clean架构的主要特点： 框架独立 容易测试 UI独立 数据库独立 不依赖任何中介 Clean的主要思想是外层依赖内层，内层完全不依赖外层（或者说内层不知道外层的存在，可以独立开发，复用性强）。 Clean架构解析 Enterprise Business Rules：业务对象 Application Business Rules：用于处理我们的业务对象，业务逻辑所在，也称为Interactor Interface Adapters： 接口转换，拿到我们需要的数据，主持者层（Presenters）和控制层（Controllers）就在这一层 Frameworks and Drivers: 这里是所有具体的实现了：比如：UI，工具类，基础框架等等。 Clean框架不一定只有4层，这里以4层为例。上面可能比较抽象，下面是简单的说法： 第一层：实体类 第二层：也叫UseCase层，实现具体业务逻辑。 第三层：如果是MVP这一层为Presenter，MVC这一层为Controller。 第四层：具体实现。 内层均为纯Java代码，只需要jvm便可以运行。 内层代码不仅可以在Android平台，还可以在别的Java平台复用。 各层单独测试，各层之间通过接口通信，且独立，方便单元测试。 层与层之间完全隔离，最主要的体现就是各层有自己的数据结构，不同层之间相互转换，完全没有依赖关系。 通过依赖注入的方式导致灵活修改逻辑、实现，这点与MVP的思想相似，Clean与MVP和Dagger结合使用是天然合适的。 以mvp-clean为例，与纯mvp最主要的区别就是Presenter层剥离出UserCase层，一是方便测试，二是方便代码复用，减少Presenter层的代码冗余。 Google Demo —— todo-mvp-clean 解析 demo地址：https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/mvp-clean基于mvp，加了 domain layer 介于 presentation 和 repositories。同时也将整个app 分为三个层次处理。 mvp-clean层次图 Presentation层 : MVP 设计准则。 Domain层 : 处理所有的业务逻辑，注意是所有的业务逻辑。对应use case（interactors）。 Data层 : 获取数据，以及数据的存储，分为本地和远程。 基本概念（摘自mvp-clean GitHub主页部分原文翻译） mvp-clean 和 基本的mvp 最大的区别就是在domain层和UseCase 的使用上。从 presenter 层分离出domain 层好处是可以减少代码的冗余。 UseCase 的好处是在domain的代码层上可以复用。CompleteTask在TaskDetailPresenter和TasksPresenter做到了很好的复用。 domain layer 是完全解耦与Android 层和第三方依赖的。是一个纯java层的处理。 UseCase 从主线程剥离出来，对于Android app是个好的操作。这种操作是尽可能的减少占用UI 线程。我们决定使用 command pattern 将use case 在线程池里执行操作。同样的我们可以用RxJava 或者 Promises实现同样的功能。 我们使用异步的repositories 。 但是现在没有必要这么做了。因为UseCase 已经从主线程里剥离出来了。这是尽量保持 samples 和原来的是一致的。 项目主要关系图 具体用例流程未完待续。。。 思考纯MVP架构会使项目变得复杂，Clean架构则会更复杂，大项目可以使项目的结构清晰，内层复用性强，便于测试。小项目则会使项目过于复杂，反而使项目结构显得不清晰，就像MVVM不适合小型项目一样。MVP作为万金油可以说适合大部分项目，我个人的思考是小型项目使用MVP架构，但在MVP的基础上加入部分Clean的思想。 从Presenter层分离出UseCase层，方便代码复用 各层独立，这里有一点需要注意，Clean中各层有各层的数据结构，在实际项目中各层可能写出类似的实体类，这里可以考虑只写一个通用实体类的作为最内层，虽然违背了Clean各层完全独立的思想，但是可以减少部分冗余，这一点根据自己项目来缺点。 参考资料 https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html https://www.jianshu.com/p/c6a1a5c9a49b https://blog.csdn.net/YANGDAHUAN/article/details/80388849 https://www.jianshu.com/p/552c3a1c5fe5 https://www.jianshu.com/p/e0258ce7d392]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
        <tag>Clean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种写法实现单例模式]]></title>
    <url>%2F2018%2F07%2F22%2F5%E7%A7%8D%E5%86%99%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[饿汉式12345678910public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 饿汉式在类加载时初始化。 优点： 简单。 天生线程安全。 缺点： 初始化时机不能由开发者控制，初始化太早造成资源的浪费。 初始化依赖于其他数据，难以控制其他数据是否准备好。 懒汉式12345678910111213141516public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; EventBus使用的方式。 优点： 第一次使用时加载，避免了资源浪费。 缺点： 复杂。 即使是双重检查有时也会失效（可能性极低）。 静态内部类模式123456789101112public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125; &#125; 《Effective Java》第一版中推荐的写法。内部类加载时初始化，内部类在第一次被调用时类加载。 优点： 简单。 巧妙的利用内部类实现线程安全。 枚举模式123public enum Singleton &#123; INSTANCE;&#125; 《Effective Java》第二版中推荐的写法。 优点： 极简。 线程安全。 绝对完美单例，可以抵御反序列化、反射。 缺点： 降低可读性。 无法被继承，降低扩展性。 容器模式12345678910111213141516public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125; &#125; public static ObjectgetService(String key) &#123; return objMap.get(key) ; &#125;&#125; 使用单例管理器统一管理所有单例，可以使用统一接口实现操作，这里只是写了简单的实现，没有优化获取操作，没有优化线程。 优点： 方便统一管理。 降低耦合。 缺点： 不能及时找到获取途径，增加开发者的学习成本。 未得到广泛认可。 总结本文一共提供了5种单例模式的实现，最推荐使用静态内部类的方式。饿汉式虽然简单但是容易造成资源浪费，懒汉式过于复杂，即便是双重检查版本也有可能DCL失效，枚举虽然是完美单例但是扩展性低，容器模式需要大量代码优化线程安全和获取操作并且增加了开发者的学习成本。 参考资料： https://www.cnblogs.com/dongyu666/p/6971783.html https://blog.csdn.net/itachi85/article/details/50510124]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Java反射完全解析]]></title>
    <url>%2F2018%2F07%2F20%2F%E8%BD%AC-Java%E5%8F%8D%E5%B0%84%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转载请注明出处：https://www.jianshu.com/p/607ff4e79a13 本文相关知识点大部分总结自Oracle官方文档，对于英文比较好的朋友，建议直接阅读原文档。 按例，首先描述一下定义： Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。 简而言之，你可以在运行状态中通过反射机制做到： 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 在我看来我们平时使用 Java 反射主要涉及两个类(接口) Class， Member，如果把这两个类搞清楚了，反射基本就 ok 了。 Class提到反射就不得不提到 Class，Class 可以说是反射能够实现的基础；注意这里说的 Class与 class 关键字不是同一种东西。class 关键字是在声明 java 类时使用的；而 Class 是 java JDK 提供的一个类,完整路径为 java.lang.Class，本质上与 Math, String 或者你自己定义各种类没什么区别。 123public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; ...&#125; 那 Class 到底在反射中起到什么作用呢？ For every type of object, the Java virtual machine instantiates an immutable instance of java.lang.Class which provides methods to examine the runtime properties of the object including its members and type information. Class also provides the ability to create new classes and objects. Most importantly, it is the entry point for all of the Reflection APIs. 对于每一种类，Java 虚拟机都会初始化出一个 Class 类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应 Class 对象，并且这个 Class 对象会被保存在同名 .class 文件里。当我们 new 一个新对象或者引用静态成员变量时，Java 虚拟机(JVM)中的类加载器系统会将对应 Class 对象加载到 JVM 中，然后 JVM 再根据这个类型信息相关的Class 对象创建我们需要实例对象或者提供静态变量的引用值。 比如创建编译一个 Shapes 类，那么，JVM 就会创建一个 Shapes 对应 Class 类的 Class实例，该 Class 实例保存了 Shapes 类相关的类型信息，包括属性，方法，构造方法等等，通过这个 Class 实例可以在运行时访问 Shapes 对象的属性和方法等。另外通过 Class类还可以创建出一个新的 Shapes 对象。这就是反射能够实现的原因，可以说 Class 是反射操作的基础。 需要特别注意的是，每个 class（注意 class 是小写，代表普通类）类，无论创建多少个实例对象，在 JVM 中都对应同一个 Class 对象。 下面就通过一个简单的例子来说明如何通过反射实例化一个对象。 123456789101112131415161718192021222324252627282930313233343536public class Animal &#123; private String name; private int age; public Animal(String name, int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Animal : name = " + name + " age = " + age; &#125;&#125; public class TestReflection&#123; private static final String TAG = "Reflection"; public void testReflection()&#123; //获取Animal类的Class对象 Class c = Animal.class; try &#123; //通过Class对象反射获取Animal类的构造方法 Constructor constructor = c.getConstructor(String.class, int.class); //调用构造方法获取Animal实例 Animal animal = (Animal) constructor.newInstance( "Jack", 3); //将构造出来的Animal对象打印出来 Log.d(TAG, animal.toString()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面我们来看下打印值 103-28 20:12:00.958 2835-2835/? D/Reflection: Animal : name = Jack age = 3 可以看出我们确实成功构造出了 Animal 对象，而且在这过程中 Class 功不可没。有人说你这也太费事了，都知道 Animal 对象了，我分分钟就能给你 new 出来了。 1Animal animal = new Animal("Jack", 3); 没错！但是如果并不能直接导入 Animal 类呢，如果构造方法都是 private 的呢？这个时候反射就能大展身手了。 如何获取Class说 Class 是反射能够实现的基础的另一个原因是：Java 反射包 java.lang.reflect 中的所有类都没有 public 构造方法，要想获得这些类实例，只能通过 Class 类获取。所以说如果想使用反射，必须得获得 Class 对象。下面列举了几种能够获取 Class 对象的方法。 Object.getClass()通过对象实例获取对应 Class 对象，如 1234567891011121314//Returns the Class for StringClass c = "foo".getClass();enum E &#123; A, B &#125;//Returns the Class corresponding to the enumeration type E.Class c = A.getClass();byte[] bytes = new byte[1024];//Returns the Class corresponding to an array with component type byte.Class c = bytes.getClass();Set&lt;String&gt; s = new HashSet&lt;String&gt;();//Returns the Class corresponding to java.util.HashSet.Class c = s.getClass(); 然而对于基本类型无法使用这种方法 12boolean b;Class c = b.getClass(); // compile-time error The .class Syntax通过类的类型获取Class对象,基本类型同样可以使用这种方法，如 12345//The `.class` syntax returns the Class corresponding to the type `boolean`.Class c = boolean.class; //Returns the Class for StringClass c = String.class; Class.forName()通过类的全限定名获取Class对象， 基本类型无法使用此方法 1Class c = Class.forName("java.lang.String"); 对于数组比较特殊 123Class cDoubleArray = Class.forName("[D"); //相当于double[].classClass cStringArray = Class.forName("[[Ljava.lang.String;"); //相当于String[][].class TYPE Field for Primitive Type Wrappers基本类型和 void 类型的包装类可以使用 TYPE 字段获取 12Class c = Double.TYPE; //等价于 double.class.Class c = Void.TYPE; Methods that Return Classes另外还有一些反射方法可以获取 Class 对象，但前提是你已经获取了一个 Class 对象。有点拗口，比如说你已经获取了一个类的 Class 对象，就可以通过反射方法获取这个类的父类的 Class 对象。 Class.getSuperclass()获得给定类的父类 Class 12// javax.swing.JButton的父类是javax.swing.AbstractButtonClass c = javax.swing.JButton.class.getSuperclass(); 类似方法还有： Class.getClasses()Class.getDeclaredClasses()Class.getDeclaringClass()Class.getEnclosingClass()java.lang.reflect.Field.getDeclaringClass()java.lang.reflect.Method.getDeclaringClass()java.lang.reflect.Constructor.getDeclaringClass() 通过Class获取类修饰符和类型我们知道类的声明一般如下表示 下面我们就以 HashMap 为例，通过一个 Demo 来说明如何获取这些信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestReflection &#123; private static final String TAG = "Reflection"; public void testReflection() &#123; Class&lt;?&gt; c = HashMap.class; //获取类名 Log.d(TAG, "Class : " + c.getCanonicalName()); //获取类限定符 Log.d(TAG, "Modifiers : " + Modifier.toString(c.getModifiers())); //获取类泛型信息 TypeVariable[] tv = c.getTypeParameters(); if (tv.length != 0) &#123; StringBuilder parameter = new StringBuilder("Parameters : "); for (TypeVariable t : tv) &#123; parameter.append(t.getName()); parameter.append(" "); &#125; Log.d(TAG, parameter.toString()); &#125; else &#123; Log.d(TAG, " -- No Type Parameters --"); &#125; //获取类实现的所有接口 Type[] intfs = c.getGenericInterfaces(); if (intfs.length != 0) &#123; StringBuilder interfaces = new StringBuilder("Implemented Interfaces : "); for (Type intf : intfs)&#123; interfaces.append(intf.toString()); interfaces.append(" "); &#125; Log.d(TAG, interfaces.toString()); &#125; else &#123; Log.d(TAG, " -- No Implemented Interfaces --"); &#125; //获取类继承数上的所有父类 List&lt;Class&gt; l = new ArrayList&lt;&gt;(); printAncestor(c, l); if (l.size() != 0) &#123; StringBuilder inheritance = new StringBuilder("Inheritance Path : "); for (Class&lt;?&gt; cl : l)&#123; inheritance.append(cl.getCanonicalName()); inheritance.append(" "); &#125; Log.d(TAG, inheritance.toString()); &#125; else &#123; Log.d(TAG, " -- No Super Classes --%n%n"); &#125; //获取类的注解(只能获取到 RUNTIME 类型的注解) Annotation[] ann = c.getAnnotations(); if (ann.length != 0) &#123; StringBuilder annotation = new StringBuilder("Annotations : "); for (Annotation a : ann)&#123; annotation.append(a.toString()); annotation.append(" "); &#125; Log.d(TAG, annotation.toString()); &#125; else &#123; Log.d(TAG, " -- No Annotations --%n%n"); &#125; &#125; private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123; Class&lt;?&gt; ancestor = c.getSuperclass(); if (ancestor != null) &#123; l.add(ancestor); printAncestor(ancestor, l); &#125; &#125;&#125; 打印结果如下 12345603-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Class : java.util.HashMap03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Modifiers : public03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Parameters : K V 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Implemented Interfaces : java.util.Map&lt;K, V&gt; interface java.lang.Cloneable interface java.io.Serializable 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Inheritance Path : java.util.AbstractMap java.lang.Object 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: -- No Annotations -- Member Reflection defines an interface java.lang.reflect.Member which is implemented by java.lang.reflect.Field, java.lang.reflect.Method, and java.lang.reflect.Constructor . 对于 Member 接口可能会有人不清楚是干什么的，但如果提到实现它的三个实现类，估计用过反射的人都能知道。我们知道类成员主要包括构造函数，变量和方法，Java 中的操作基本都和这三者相关，而 Member 的这三个实现类就分别对应他们。 java.lang.reflect.Field ：对应类变量java.lang.reflect.Method ：对应类方法java.lang.reflect.Constructor ：对应类构造函数 反射就是通过这三个类才能在运行时改变对象状态。下面就让我们通过一些例子来说明如何通过反射操作它们。 首先建一个测试类 12345678910111213141516171819202122232425262728293031323334353637public class Cat &#123; public static final String TAG = Cat.class.getSimpleName(); private String name; @Deprecated public int age; public Cat(String name, int age)&#123; this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void eat(String food)&#123; Log.d(TAG, "eat food " + food); &#125; public void eat(String... foods)&#123; StringBuilder s = new StringBuilder(); for(String food : foods)&#123; s.append(food); s.append(" "); &#125; Log.d(TAG, "eat food " + s.toString()); &#125; public void sleep()&#123; Log.d(TAG, "sleep"); &#125; @Override public String toString() &#123; return "name = " + name + " age = " + age; &#125;&#125; Field通过 Field 你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是 private 的。 获取 Field Class 提供了4种方法获得给定类的 Field getDeclaredField(String name) 获取指定的变量（只要是声明的变量都能获得，包括 private） getField(String name) 获取指定的变量（只能获得 public 的） getDeclaredFields() 获取所有声明的变量（包括 private） getFields() 获取所有的 public 变量 获取变量类型、修饰符、注解 一个例子说明问题 12345678910111213141516171819202122232425262728public void testField()&#123; Class c = Cat.class; Field[] fields = c.getDeclaredFields(); for(Field f : fields)&#123; StringBuilder builder = new StringBuilder(); //获取名称 builder.append("filed name = "); builder.append(f.getName()); //获取类型 builder.append(" type = "); builder.append(f.getType()); //获取修饰符 builder.append(" modifiers = "); builder.append(Modifier.toString(f.getModifiers())); //获取注解 Annotation[] ann = f.getAnnotations(); if (ann.length != 0) &#123; builder.append(" annotations = "); for (Annotation a : ann)&#123; builder.append(a.toString()); builder.append(" "); &#125; &#125; else &#123; builder.append(" -- No Annotations --"); &#125; Log.d(TAG, builder.toString()); &#125; &#125; 打印结果： 123filed name = age type = int modifiers = public annotations = @java.lang.Deprecated() filed name = name type = class java.lang.String modifiers = private -- No Annotations --filed name = TAG type = class java.lang.String modifiers = public static final -- No Annotations -- 获取、设置变量值 给定一个对象和它的成员变量名称，就能通过反射获取和改变该变量的值。什么都不说了，没有什么是不能通过一个例子解决的， Easy~ 仍然是上面的测试类，通过反射获取并改变 Cat 的 name 和 age. 123456789101112131415161718192021public void testField()&#123; Cat cat = new Cat("Tom", 2); Class c = cat.getClass(); try &#123; //注意获取private变量时，需要用getDeclaredField Field fieldName = c.getDeclaredField("name"); Field fieldAge = c.getField("age"); //反射获取名字, 年龄 String name = (String) fieldName.get(cat); int age = fieldAge.getInt(cat); Log.d(TAG, "before set, Cat name = " + name + " age = " + age); //反射重新set名字和年龄 fieldName.set(cat, "Timmy"); fieldAge.setInt(cat, 3); Log.d(TAG, "after set, Cat " + cat.toString()); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; 嗯？竟然报错？ 1234System.err: java.lang.IllegalAccessException: Class java.lang.Class&lt;com.example.ming.testnestscrollview.TestReflection&gt; cannot access private field java.lang.String com.example.ming.testnestscrollview.Cat.name of class java.lang.Class&lt;com.example.ming.testnestscrollview.Cat&gt;System.err: at java.lang.reflect.Field.get(Native Method)System.err: at com.example.ming.testnestscrollview.TestReflection.testField(TestReflection.java:22)System.err: at com.example.ming.testnestscrollview.MainActivity.onCreate(MainActivity.java:17) 观察一下异常信息 java.lang.IllegalAccessException，说我们没有权限操作变量 name；回到 Cat 类中查看一下 name 变量。 1private String name; 原来 name 变量是 private，Java 运行时会进行访问权限检查，private 类型的变量无法进行直接访问，刚刚进行的反射操作并没有打破这种封装，所以我们依然没有权限对 private属性进行直接访问。 难道就没有办法打破这种限制吗？必须有！强大的反射早已暗中为我们准备好了一切。反射包里为我们提供了一个强大的类。 java.lang.reflect.AccessibleObject AccessibleObject 为我们提供了一个方法 setAccessible(boolean flag)，该方法的作用就是可以取消 Java 语言访问权限检查。所以任何继承 AccessibleObject 的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final 类型变量也可以通过这种办法访问） 1public final class Field extends AccessibleObject implements Member Field 正是 AccessibleObject 的子类，那么简单了，只要在访问私有变量前调用 filed.setAccessible(true) 就可以了 12345...fieldName.setAccessible(true);//反射获取名字, 年龄String name = (String) fieldName.get(cat);... 打印结果 12TestReflection: before set, Cat name = Tom age = 2TestReflection: after set, Cat name = Timmy age = 3 Bingo! 注意 Method 和 Constructor 也都是继承 AccessibleObject，所以如果遇到私有方法和私有构造函数无法访问，记得处理方法一样。 Method The java.lang.reflect.Method class provides APIs to access information about a method’s modifiers, return type, parameters, annotations, and thrown exceptions. It also be used to invoke methods. 这节主要介绍如何通过反射访问对象的方法。 获取 Method Class 依然提供了4种方法获取 Method: getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 根据方法名获得指定的方法， 参数 name 为方法名，参数 parameterTypes 为方法的参数类型，如 getDeclaredMethod(“eat”, String.class) getMethod(String name, Class&lt;?&gt;… parameterTypes) 根据方法名获取指定的 public 方法，其它同上 getDeclaredMethods() 获取所有声明的方法 getMethods() 获取所有的 public 方法 注意：获取带参数方法时，如果参数类型错误会报 NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class） 获取方法返回类型 getReturnType() 获取目标方法返回类型对应的 Class 对象 getGenericReturnType() 获取目标方法返回类型对应的 Type 对象 这两个方法有啥区别呢？ getReturnType()返回类型为 Class，getGenericReturnType() 返回类型为 Type; Class 实现 Type。 返回值为普通简单类型如 Object, int, String 等，getGenericReturnType() 返回值和 getReturnType() 一样 例如 public String function1()，那么各自返回值为： getReturnType() : class java.lang.String getGenericReturnType() : class java.lang.String 返回值为泛型 例如 public T function2()，那么各自返回值为： getReturnType() : class java.lang.Object getGenericReturnType() : T 返回值为参数化类型 例如public Class function3()，那么各自返回值为： getReturnType() : class java.lang.Class getGenericReturnType() : java.lang.Class&lt;java.lang.String&gt; 其实反射中所有形如 getGenericXXX()的方法规则都与上面所述类似。 获取方法参数类型getParameterTypes() 获取目标方法各参数类型对应的 Class 对象getGenericParameterTypes() 获取目标方法各参数类型对应的 Type 对象返回值为数组，它俩区别同上 “方法返回类型的区别” 。 获取方法声明抛出的异常的类型getExceptionTypes() 获取目标方法抛出的异常类型对应的 Class 对象getGenericExceptionTypes() 获取目标方法抛出的异常类型对应的 Type 对象返回值为数组，区别同上 获取方法参数名称.class 文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上 -parameters 参数。(构造方法的参数获取方法同样) 12345678910//这里的m可以是普通方法Method，也可以是构造方法Constructor//获取方法所有参数Parameter[] params = m.getParameters();for (int i = 0; i &lt; params.length; i++) &#123; Parameter p = params[i]; p.getType(); //获取参数类型 p.getName(); //获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`, X为参数在方法声明中的位置，从0开始 p.getModifiers(); //获取参数修饰符 p.isNamePresent(); //.class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase&#125; 获取方法参数名称的详细信息请参考 oracle 的官方例子 MethodParameterSpy 获取方法修饰符 方法与 Filed 等类似 1method.getModifiers(); Ps：顺便多介绍几个Method方法 method.isVarArgs() //判断方法参数是否是可变参数 12public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) //返回truepublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; [] parameterTypes) //返回flase method.isSynthetic() //判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法 method.isBridge() //判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。可以参考：https://www.jianshu.com/u/ceba5da6bd7a 通过反射调用方法 反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。 12public native Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 还是以上面测试类 Cat 为例 注意：如果方法是private的，可以使用 method.setAccessible(true) 方法绕过权限检查 12345678910111213141516171819202122Class&lt;?&gt; c = Cat.class; try &#123; //构造Cat实例 Constructor constructor = c.getConstructor(String.class, int.class); Object cat = constructor.newInstance( "Jack", 3); //调用无参方法 Method sleep = c.getDeclaredMethod("sleep"); sleep.invoke(cat); //调用定项参数方法 Method eat = c.getDeclaredMethod("eat", String.class); eat.invoke(cat, "grass"); //调用不定项参数方法 //不定项参数可以当成数组来处理 Class[] argTypes = new Class[] &#123; String[].class &#125;; Method varargsEat = c.getDeclaredMethod("eat", argTypes); String[] foods = new String[]&#123; "grass", "meat" &#125;; varargsEat.invoke(cat, (Object)foods); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; 被调用的方法本身所抛出的异常在反射中都会以 InvocationTargetException 抛出。换句话说，反射调用过程中如果异常 InvocationTargetException 抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。 Constructor这节主要介绍如何通过反射访问构造方法并通过构造方法构建新的对象。 获取构造方法 和 Method 一样，Class 也为 Constructor 提供了4种方法获取 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 获取指定构造函数，参数 parameterTypes 为构造方法的参数类型 getConstructor(Class&lt;?&gt;… parameterTypes) 获取指定 public 构造函数，参数 parameterTypes 为构造方法的参数类型 getDeclaredConstructors() 获取所有声明的构造方法 getConstructors() 获取所有的 public 构造方法 构造方法的名称、限定符、参数、声明的异常等获取方法都与 Method 类似，请参照Method。 创建对象 通过反射有两种方法可以创建对象： java.lang.reflect.Constructor.newInstance() Class.newInstance() 一般来讲，我们优先使用第一种方法；那么这两种方法有何异同呢？ Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法。 Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出; Constructor.newInstance()会将构造方法中抛出的异常都包装成 InvocationTargetException 抛出。 Class.newInstance()需要拥有构造方法的访问权限; Constructor.newInstance()可以通过 setAccessible(true) 方法绕过访问权限访问 private 构造方法。 例子在 Method 一节已经写过，这里直接截取过来 1234567Class&lt;?&gt; c = Cat.class;try &#123; Constructor constructor = c.getConstructor(String.class, int.class); Cat cat = (Cat) constructor.newInstance( "Jack", 3);&#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace();&#125; 注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间） 数组和枚举数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以 Java 反射为数组和枚举提供了一些特定的 API 接口。 数组 数组类型 数组类型：数组本质是一个对象，所以它也有自己的类型。 例如对于int[] intArray，数组类型为class [I。数组类型中的[个数代表数组的维度，例如[代表一维数组，[[ 代表二维数组；[ 后面的字母代表数组元素类型，I 代表 int，一般为类型的首字母大写(long 类型例外，为 J)。 123456789class [B //byte类型一维数组class [S //short类型一维数组class [I //int类型一维数组class [C //char类型一维数组class [J //long类型一维数组，J代表long类型，因为L被引用对象类型占用了class [F //float类型一维数组class [D //double类型一维数组class [Lcom.dada.Season //引用类型一维数组class [[Ljava.lang.String //引用类型二维数组 1234567//获取一个变量的类型Class&lt;?&gt; c = field.getType();//判断该变量是否为数组if (c.isArray()) &#123; //获取数组的元素类型 c.getComponentType()&#125; 创建和初始化数组 Java 反射为我们提供了 java.lang.reflect.Array 类用来创建和初始化数组。 12345678//创建数组， 参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值Array.set(Object array, int index, int value)//获取数组的值，array为数组对象，index为数组的下标Array.get(Object array, int index) 例子,用反射创建 int[] array = new int[]{1, 2} 123Object array = Array.newInstance(int.class, 2);Array.setInt(array , 0, 1);Array.setInt(array , 1, 2); 注意：反射支持对数据自动加宽，但不允许数据 narrowing(变窄?真难翻译)。意思是对于上述 set 方法，你可以在 int 类型数组中 set short 类型数据，但不可以 set long 类型数据，否则会报 IllegalArgumentException。 多维数组 Java 反射没有提供能够直接访问多维数组元素的 API，但你可以把多维数组当成数组的数组处理。 12345678Object matrix = Array.newInstance(int.class, 2, 2);Object row0 = Array.get(matrix, 0);Object row1 = Array.get(matrix, 1);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4); 或者 1234567891011Object matrix = Array.newInstance(int.class, 2);Object row0 = Array.newInstance(int.class, 2);Object row1 = Array.newInstance(int.class, 2);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4);Array.set(matrix, 0, row0);Array.set(matrix, 1, row1); 枚举枚举隐式继承自 java.lang.Enum，Enum 继承自 Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外 java 反射额外提供了几个方法为枚举服务。 Class.isEnum() Indicates whether this class represents an enum type Class.getEnumConstants() Retrieves the list of enum constants defined by the enum in the order they’re declared java.lang.reflect.Field.isEnumConstant() Indicates whether this field represents an element of an enumerated type 反射的缺点没有任何一项技术是十全十美的，Java 反射拥有强大功能的同时也带来了一些副作用。 性能开销 反射涉及类型动态解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部曝光 由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 使用反射的一个原则：如果使用常规方法能够实现，那么就不要用反射。]]></content>
      <categories>
        <category>Java反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCPIP详解卷1》010阅读笔记]]></title>
    <url>%2F2018%2F06%2F13%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B010%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[名词解释 缩写 英文全称 中文 AS Autonomous System 自治系统 IGP Interior Gateway Protocol 内部网关协议/域内选路协议 EGP Exterier Gateway Protocol 外部网关协议/域内选路协议的分隔选路协议 BGP Border Gateway Protocol 边界网关协议 RIP Routing Infomation Protocol 选路信息协议 OSPF Open Shortest Path First 开放最短路径优先协议 CIDR Classless Inter-Domain Routing 无类别域间路由 IGP用于自治系统内。 EGP用于自治系统之间。 BGP意在取代EGP。 动态选路 相邻路由器之间进行通信，告知对方每个路由器当前所连接的网络。 路由守护程序根据从相邻路由器收到的信息更新内核中的路由表。 随时间变化时，路由是由路由守护程序动态地增加或删除。 如果路由守护程序发现前往同一信宿存在多条路由，选择最佳路由加入内核路由表。 如果路由守护程序发现一条链路已经断开，删除受影响的路由或增加一条路由绕过。 每个自治系统由单个实体管理。==什么是实体？== RIP：选路信息协议 正式描述文件RFC 1058 [Hedrick 1988a]。 RIP报文包含在UDP数据报中。 RIP的度量是以跳计数的。 最多携带25个路由。 度量 直接连接接口的跳数为1。 一个路由器到一个网络有多条路由，路由器选择跳数最小的路由。 度量为16表示无路由到达该IP地址。 问题 RIP没有子网地址的概念。 路由器或链路发生故障后在稳定下来这段时间可能发生路由环路。 度量最大值限制了可以使用RIP的网络的大小。 RIP版本2 RFC 1388 [Malkin 1993a] 对RIP定义进行了扩充。 路由域字段：数据报的所有者。 选路标记字段：携带一个EGP和BGP的自治系统号。 子网掩码字段：应用于相应的IP地址。 下一站IP地址字段：指明发往目的IP地址的报文应该发往哪里。 除了支持广播，还支持多播。 OSPF：开放最短路径优先 RFC 1247 [Moy 1991] 对第2版OSPF进行了描述。 OSPF克服了RIP所有限制。 路由器不与临站交换距离信息，主动测试与临站相连的链路状态。 信息发给其他临站，临站将这些信息在自治系统中传播出去。 路由器接收这些链路状态信息，建立完整的路由表。 链路状态协议总是比距离向量协议稳定更快。 OSPF直接使用IP，不使用UDP或TCP。 优于RIP的特点： 可以对每个IP服务类型计算各自的路由集。 给每个接口指派一个无维数的费用。 同一个目的地址存在多个相同费用的路由时，平均分配流量。 支持子网，子网掩码与每个通告相连。 无编号网络。 简单鉴别机制。 采用多播而不是广播形式，减少系统负载。 BGP：边界网关协议 RFC 1267 [Lougheed and Rekhter 1991] 对第3版BGP进行描述。 BGP系统之间交换网络可到达信息，包括所必须经过的自治系统的所有路径。 使用BGP的一个目的是减少通过流量。 允许使用基于策略的选路。 使用TCP作为其传输层协议。 BGP是一个距离测量协议，列举了到每个目的地址的路由，排除了一些距离向量协议的问题。 定期发送keepalive报文给临站来监测TCP连接对端的链路或主机失败。 应用层的keepalive报文与TCP的keepalive报文选项相互独立。 CIDR：无类型域间选路 RFC 1518 [Rekher and Li 1993], RFC 1519 [Fuller et al. 1993]对它描述。 [Ford, Rekhter, and Braun 1993] 综述。 一个防止路由表膨胀的方法，也成为超网。 采用分配多个IP地址的方式，使许多表项总和成更少的数目 必须满足3种特性： IP地址必须具有相同的高位地址比特。 路由表和选路算法必须扩展成根据32 bit IP地址和32 bit 掩码做出选路决策。 选路协议要有32 bit掩码。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCPIP详解卷1》007、008、009阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B007%E3%80%81008%E3%80%81009%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[007，Ping的工作原理Unix系统的实现 把ICMP报文中标识符字段设置成发送进程的ID号（识别多个Ping程序实例）。 序列号从0开始，每发送一次新的回显请求就 + 1。 Ping程序允许我们查看是否有分组丢失、失序或重复。 旧版本Ping程序 每秒发送一个回显请求。 打印返回的每个分组的每个回显应答。 新版本Ping程序 需要加上 - s 选项以旧版本模式运行。 Ping程序只发送一个回显请求。 收到回显应答输出“host is alive”，20秒内没收到输出“no answer”。 008，Traceroute的工作原理 每个处理数据报的路由器都要把TTL的值减1或停留的秒数。 大多数路由器转发数据报的时延都小于1秒，TTL最终成为一个跳站计数器。 如果TTL字段是1，路由器将该数据报丢弃，并向信源机放一份ICMP“超时”信息。 Traceroute程序发送一份TTL字段为1的IP数据报为目的主机，第一个路由器丢弃并发回超时ICMP报文，然后Traceroute程序发送一份TTL字段为2的数据报，得到第二个路由器的地址，以此类推。 目的主机收到TTL值为1的IP数据报，不会丢弃并产生ICMP超时报文。 Traceroute程序发送一份不可能值作为UDP端口号（大于30000）的UDP数据报给目的主机，目的主机产生一份“端口不可达”错误的ICMP报文。 Traceroute程序区分收到的ICMP报文是超时还是端口不可达判断是否结束。 009，IP包选路的工作原理选路的原理 IP搜索路由表的步骤： 搜索匹配的主机地址。 搜索比配的网络地址。 搜索默认表项。 IP层进行的选路是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。 选路策略决定把哪些路由放入路由表的规则，路由守护程序提供选路策略。 初始化路由表 在系统引导时显示地的在初始化文件中运行route命令。 没有到达目的地的路由路由表中没有默认项，又没有找到匹配项。 数据报由本地主机产生：向应用程序返回一个“主机不可达差错”或“网络不可达差错”。 被转发的数据报：向原始发送端发送一份ICMP主机不可达差错报文。 ICMP重定向差错 当数据报应该被发送到另一个路由器时，收到数据报的路由器要发送ICMP重定向差错报文给IP数据报的发送端。 重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。 ICMP重定向报文 重定向报文只能由路由器生成。 重定向报文是为主机使用的。 ICMP路由器发现报文 一份报文可以通告多个地址。 路由器启动时定期在所有广播或多播传送接口上发送通告报文。 某个接口被关闭时，该接口上发送一份通告报文，生命周期值设为0。 监听来自主机的请求报文，并发送通告报文以响应。 主机在引导期间发送请求报文。 监听来自相邻路由器的请求报文。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCPIP详解卷1》006阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B006%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ICMP的正式规范参见 RFC 792 ICMP是IP层的一个组成部分，传递差错报文和其他需要注意的信息。通常被IP层或更高层协议使用。 校验和覆盖整个ICMP报文，算法与IP首部相同 不同类型和代码有不同的内容 ICMP报文的类型 类型字段和代码字段共同决定。 ICMO差错报文始终包含IP首部和产生差错的IP数据报的前8个字节。接收ICMP差错报文的模块可以与某个协议和用户进程联系起来。 下面情况不产生差错报文： ICMP差错报文 目的地址是广播或多播地址 作为链路层广播的数据报 不是IP分片的第一片 源地址不是单个主机的数据报 ICMP地址掩码请求与应答 用于无盘系统在引导过程中获取自己的子网掩码。 系统广播他的ICMP请求报文（类似RARP获取IP地址）。 标识符和序列号由发送端任意设定，在应答中返回进行匹配。 ICMP时间戳请求与应答 请求允许系统向另一个系统查询当前时间。 返回的建议值是自午夜计算的毫秒数，协调的统一时间。 缺陷：必须通过其他方法获知当时的日期。 请求端填写发起时间戳，应答系统收到时填写接收时间戳，发送时填写传送时间戳。 调整值是difference - RTT / 2。 ICMP端口不可达差错以UDP端口不可达为例。 IP首部后面前8个字节是UDP首部（源端口号和目的端口号）。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCPIP详解卷1》004阅读笔记]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B004%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[RFC 826 [Plummer 1982] 是ARP规范描述文档。ARP（地址解析协议）RARP（逆地址解析协议） ARP为IP地址到对应硬件地址之间提供动态映射，因为是自动完成的。RARP被没有磁盘驱动器的系统使用，需要系统管理员手工设置。 ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。称作广播。 点对点链路不使用ARP。设置这些链路时，必须告知内核链路每一端的IP地址，而不需要硬件地址。 ARP高效运行因为每个主机上都有一个ARP高速缓存 ARP的分组格式 以太网目的地址 以太网源地址 帧类型 硬件类型 协议类型 硬件地址长度 协议地址长度 op 发送端以太网地址 发送端IP地址 目的以太网地址 目的IP地址 6 6 2 2 2 1 1 2 6 4 6 4 全1 0x0806 1 0x0800 6 bytes 4 bytes 广播地址 ARP请求或应答 表示以太网地址 表示IP地址 MAC地址长度 IP地址长度 目的地址：全1的特殊地址是广播地址，电缆上的所有以太网接口都要接收广播的数据帧。 操作字段（OP）：ARP请求（1）、ARP应答（2）、RARP请求（3）、RARP应答（4），必须字段，因为ARP请求和应答的帧类型字段相同。 ARP高速缓存超时设置 BSD演变来的系统一般设置完整表项超时20分钟，不完整表项超时3分钟。 表项再次使用时，超时值重设为20分钟。 ARP代理 路由器相当于目的主机的代理，把分组从其他主机转发给它。 免费ARP 是指发送ARP查找自己的IP地址。 两方面作用： 验证IP是否冲突，一个主机能够通过它来确定是否还有一个主机设置了相同的IP地址。 更换物理网卡，假设发送ARP的主机正好改变了物理地址，能够使用此方法通知网络中其他主机及时更新ARP缓存。 ARP命令 arp -a 显示ARP高速缓存。 arp -d 删除ARP高速缓存中某一项。 arp -s 增加高速缓存中的内容，是永久性的，除非末尾加上关键字temp。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCP/IP详解卷1》003阅读笔记]]></title>
    <url>%2F2018%2F06%2F02%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B003%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[IP的正式规范文件：RFC 791 所有TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。不可靠：不能保证IP数据报能够成功到达目的地。可靠性必须由上层提供。无连接：IP不维护后续数据报的状态信息。每个数据报的处理相互独立。IP数据报可以不按发送顺序接收。 传输次序：网络字节序/big endian（大端）字节序 IP首部字段 字段名 长度 版本 4位 4 首部长度 4位 首部占32bit字的数目，没有任何选项，值为5，首部最长60字节 服务类型（TOS） 8位 3bit优先权子字段（已忽略），4bitTOS子字段，1bit未用位（置为0） 总长度 16位 字节为单位，最长65535字节。必要内容 位标识 16位 唯一标识主机发送的每一份数据报 位标志 3位 位片偏移 13位 生存时间（TTL） 8位 经过的最多路由器数，初始值通常为64或32，源主机设置。 协议 8位 首部校验和 16位 根据IP首部计算校验和码。 选项 可选，可变长。32bit为界限，不够时插入值为0的填充字节。 首部长度：从包头格式图看出，是以32bit为一行的，一行包括若干字段。首部长度的数值是以32bit为单位来描述的，比如四位全为1，十六进制本来是0X0F，也就是十进制的15但是，这个字段的1不是数值1，而是指1个单位即一个32bit。所以如果该字段是1111的话。就是15*32bit=60Byte了。 4bit的TOS代表：最小时延、最大吞吐量、最高可靠性、最小费用。 首部长度、总长度计算数据内容的起始位置和长度。 TTL为0时丢弃数据报，发送ICMP报文通知源主机。 首部校验和：如果校验和错误，丢弃数据报，但不生成差错报文，由上层发现并重传。 IP路由选择目的主机与源主机直接相连，或都在一个共享网络上，IP数据报直接送到目的主机。否则发往默认路由，由路由器转发。 IP层可以配置成路由器或主机主机：不转发路由器：转发内含路由器的主机：不转发 收到数据报来自网络接口时（即非本地生成的数据报） 检查IP地址 是本机IP地址之一或IP广播地址：发送到指定协议模块 IP层设置为路由器：转发 否则：丢弃 路由表 项 含义 目的IP地址 表中标志字段指定类型。完整的主机地址：非0主机号。网络地址：主机号为0。 下一跳路由器IP地址 或者有直接连接的网络IP地址。 标志 一个指明目的IP地址类型，==一个标志下一站路由器时真下一站路由器还是直接相连的接口。看不懂这句== 指定网络接口 IP不知道目的的完整路径 IP路由选择主要功能搜索路由表 寻找与目的IP完全匹配（网络号和主机号）的条目 寻找与目的网络号相匹配的条目（必须考虑子网掩码） 寻找“默认”的条目 如果找到，报文发送指定的下一站路由器或直接相连的网络接口。如果都未成功，则不能被传送，向应用返回错误 子网寻址==看不懂图== 所有主机都要求支持子网寻址。 IP地址 = 网络号 + 子网号 + 主机号 B类IP地址 = 网络号（16位）+ 子网号（8位）+ 主机号（8位） 子网对外部路由器来说隐藏了内部网络组织。 子网划分缩减了路由表的规模。 子网对于子网内部的路由器不透明。==不懂== 子网掩码 标识多少bit用于子网号，多少bit用于主机号。 掩码是32bit的值，值为1留给网络号和子网号，值为0留给主机号。 给定IP地址和子网掩码后可以确定： 本子网上的主机。 本网络中其他子网中的主机。 其他网络上的主机。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TCPIP详解卷1》002阅读笔记]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B002%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[名词解释 LLC：逻辑链路控制（Logic Link Control） SNAPL：自网络访问协议（SubNetwork Access Protocol） IEEE：电子电气工程师协会 CRC：循环冗余校验（Cyclic Redundancy Check ） pad字节：padding byte，填充字节 RS-232：异步传输标准接口 BSD：Berkeley Software Distribution，Unix的衍生系统 链路层主要三个目的 为IP模块发送接受IP数据报。 为ARP模块发送ARP请求和接受ARP应答。 为RARP发送RARP请求和接受RARP应答。 以太网与IEEE 802封装对比 以太网 IEEE 802 备注 数据报封装 RFC 894中定义 RFC 1042中定义 长度字段 后续数据的长度字段（不包括CRC） 类型字段 后续数据的类型 由后续子网接入协议的首部给出 格式相同 最小长度 46字节 38字节 不足空间填充pad字节 有效类型值都不相同，可以对两种帧格式进行区分。以太网：类型字段后是数据。IEEE 802：长度字段后是802.2LLC、802.2SNAP。CRC字段（FCS/帧校验序列）：后续字节差错的循环冗余码校验。 尾部封装 在RFC 89C被描述。 通过调整IP数据报中字段次序提高性能。 将IP首部和TCP首部移到尾部CRC之前。 ==当把数据复制到内核是，可以绑数据帧中的数据部分映射到一个硬件页面，节省到内存的复制过程。看不懂？？？== 尾部封装已遭到反对。 SLIP：串行线路IP 串行线路上对IP数据报封装的简单形式。 适用于RS-232串行端口、高速调制解调器接入网络。 以END(0XC0)的特殊字符结束。 如果有线路噪声，开始也传一个END(0XC0)字符。 IP报文中END用0XDB和0XDC取代（称为ESC字符）。 IP报文中ESC用0XDB和0XDD取代。 缺陷： 每一端必须知道对方的IP地址。 没有类型字段，不能和其他协议同时使用。 没有校验和。 压缩的SLIP（CSLIP） 在RFC 1144中被描述。 为了在SLIP上传输1个字节总共需要40字节，CSLIP能把它们压缩到3或5个字节。 每一端维持多达16个TCP连接。 知道每个连接的首部哪些字段一般不会发生变化。 被压缩的首部大大缩短了交互响应时间。 PPP点对点协议修改了SLIP协议中的所有缺陷，最终应该取代SLIP。 PPP包括三个部分： 在串行链路上封装IP数据报的方法。 建立、配置及测试数据链路的链路控制协议。 针对不同网络层协议的网络控制协议体系。数据报帧的格式： 以0X7E开始和结束。 地址字节值始终为0XFF。 协议字段（类似以太网类型字段）：| 协议字段的值 | 标识信息字段的类型 || ———- | —————-|| 0X0021 | IP数据报 || 0XC021 | 链路控制数据 || 0X8021 | 网络控制数据 |信息字段出现0X7E时需要转义。利用链路控制协议，大多数可以省略标识符和地址字段。使用IP网络控制协议，大多数可以采用Van Jacobson报文首部压缩方法。不懂？？？对比SLIP具有的优点 PPP支持在单根串行线路上运行多种协议。 每一帧都有循环冗余校验。 通信双方可以进行IP地址的动态协商。 与CSLIP类似，对TCP和IP报文首部压缩。 链路控制协议可以对多个数据链路选项进行设置。 环回接口（localhost） 大多数系统把IP地址127.0.0.1分配给这个接口。 一个传给环回接口的IP数据报不能在任何网络上出现。 最大传输单元MTU 如果IP层有一个长度大于链路层的MTU的数据报要传，需要进行分片。 MTU不是物理特性，它是一个逻辑限制。 目的：为交互使用提供足够快的响应时间。 路径MTU==两台主机路径中的最小MTU被称作路径MTU（不一定是个常数）。看不懂这句话== 串行线路吞吐量计算 如果线路速率是9600b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960B/s（字节/秒）。 这句话是指每个bit加一个起始一个停止，所有9600 / (8 + 2) = 960 B/s。 如果把SLIP的MTU降到256以下，将降低传输大块数据的最大吞吐量。 平均等待时间的计算（传输大数据帧所需时间的一半）只适用于SLIP或PPP链路。==为什么要等一半的时间？？==]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar的setTitle问题]]></title>
    <url>%2F2018%2F04%2F09%2FToolbar%E7%9A%84setTitle%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在setSupportActionBar(toolbar)之后调用toolbar.setTitle()，在onCreate()中调用无效，在onStart()中调用无效。 解决方案： 在onResume()中调用有效。 getSupportActionBar.setTitle()有效]]></content>
      <categories>
        <category>Android视图</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Android生成验证码]]></title>
    <url>%2F2018%2F02%2F22%2F%E8%BD%AC-Android%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class Code &#123; //随机数数组 private static final char[] CHARS = &#123; '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; private static Code bmpCode; public static Code getInstance() &#123; if(bmpCode == null) bmpCode = new Code(); return bmpCode; &#125; //default settings //验证码默认随机数的个数 private static final int DEFAULT_CODE_LENGTH = 4; //默认字体大小 private static final int DEFAULT_FONT_SIZE = 25; //默认线条的条数 private static final int DEFAULT_LINE_NUMBER = 5; //padding值 private static final int BASE_PADDING_LEFT = 10, RANGE_PADDING_LEFT = 15, BASE_PADDING_TOP = 15, RANGE_PADDING_TOP = 20; //验证码的默认宽高 private static final int DEFAULT_WIDTH = 100, DEFAULT_HEIGHT = 40; //settings decided by the layout xml //canvas width and height private int width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT; //random word space and pading_top private int base_padding_left = BASE_PADDING_LEFT, range_padding_left = RANGE_PADDING_LEFT, base_padding_top = BASE_PADDING_TOP, range_padding_top = RANGE_PADDING_TOP; //number of chars, lines; font size private int codeLength = DEFAULT_CODE_LENGTH, line_number = DEFAULT_LINE_NUMBER, font_size = DEFAULT_FONT_SIZE; //variables private String code; private int padding_left, padding_top; private Random random = new Random(); //验证码图片 public Bitmap createBitmap() &#123; padding_left = 0; Bitmap bp = Bitmap.createBitmap(width, height, Config.ARGB_8888); Canvas c = new Canvas(bp); code = createCode(); c.drawColor(Color.WHITE); Paint paint = new Paint(); paint.setAntiAlias(true); paint.setTextSize(font_size); //画验证码 for (int i = 0; i &lt; code.length(); i++) &#123; randomTextStyle(paint); randomPadding(); c.drawText(code.charAt(i) + "", padding_left, padding_top, paint); &#125; //画线条 for (int i = 0; i &lt; line_number; i++) &#123; drawLine(c, paint); &#125; c.save( Canvas.ALL_SAVE_FLAG );//保存 c.restore();// return bp; &#125; public String getCode() &#123; return code; &#125; //生成验证码 private String createCode() &#123; StringBuilder buffer = new StringBuilder(); for (int i = 0; i &lt; codeLength; i++) &#123; buffer.append(CHARS[random.nextInt(CHARS.length)]); &#125; return buffer.toString(); &#125; //画干扰线 private void drawLine(Canvas canvas, Paint paint) &#123; int color = randomColor(); int startX = random.nextInt(width); int startY = random.nextInt(height); int stopX = random.nextInt(width); int stopY = random.nextInt(height); paint.setStrokeWidth(1); paint.setColor(color); canvas.drawLine(startX, startY, stopX, stopY, paint); &#125; //生成随机颜色 private int randomColor() &#123; return randomColor(1); &#125; private int randomColor(int rate) &#123; int red = random.nextInt(256) / rate; int green = random.nextInt(256) / rate; int blue = random.nextInt(256) / rate; return Color.rgb(red, green, blue); &#125; //随机生成文字样式，颜色，粗细，倾斜度 private void randomTextStyle(Paint paint) &#123; int color = randomColor(); paint.setColor(color); paint.setFakeBoldText(random.nextBoolean()); //true为粗体，false为非粗体 float skewX = random.nextInt(11) / 10; skewX = random.nextBoolean() ? skewX : -skewX; paint.setTextSkewX(skewX); //float类型参数，负数表示右斜，整数左斜 //paint.setUnderlineText(true); //true为下划线，false为非下划线 //paint.setStrikeThruText(true); //true为删除线，false为非删除线 &#125; //随机生成padding值 private void randomPadding() &#123; padding_left += base_padding_left + random.nextInt(range_padding_left); padding_top = base_padding_top + random.nextInt(range_padding_top); &#125; &#125; 调用方法： 12ivCode.setImageBitmap(Code.getInstance().createBitmap());//将验证码图片显示到ImageView String code = Code.getInstance().getCode().toLowerCase();//用一个变量保存验证码，并转为小写，获取输入的验证也转为小写，这样就实现了不区分大小写]]></content>
      <categories>
        <category>Android视图</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
</search>
